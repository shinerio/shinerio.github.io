<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shinerio&#39;s blog</title>
  
  <subtitle>shine is an atitude to life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shinerio.cc/"/>
  <updated>2023-01-24T15:34:38.755Z</updated>
  <id>https://shinerio.cc/</id>
  
  <author>
    <name>shinerio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netstat命令</title>
    <link href="https://shinerio.cc/2023/01/24/linux/netstat%E5%91%BD%E4%BB%A4/"/>
    <id>https://shinerio.cc/2023/01/24/linux/netstat命令/</id>
    <published>2023-01-24T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p><code>netstat</code>是基于Netstat这个命令行工具的指令，它可以用来查询系统上的网络套接字连接情况，包括<code>tcp</code>,<code>udp</code>以及<code>Unix套接字</code>。另外它还能列出路由表，接口状态和多播成员等信息。</p><a id="more"></a><h1 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h1><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>使用数字形式表示网络地址</td></tr><tr><td>-a</td><td>列出所有选项</td></tr><tr><td>-c</td><td>每隔一段时间自动执行netstat命令</td></tr><tr><td>-s</td><td>按照每隔协议来分类统计</td></tr><tr><td>-t</td><td>显示tcp相关选项</td></tr><tr><td>-u</td><td>显示udp相关选项</td></tr><tr><td>-e</td><td>显示额外信息</td></tr><tr><td>-p</td><td>显示与连接有关的程序名和进程</td></tr><tr><td>-r</td><td>显示路由信息，等效于<code>route -n</code></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;netstat&lt;/code&gt;是基于Netstat这个命令行工具的指令，它可以用来查询系统上的网络套接字连接情况，包括&lt;code&gt;tcp&lt;/code&gt;,&lt;code&gt;udp&lt;/code&gt;以及&lt;code&gt;Unix套接字&lt;/code&gt;。另外它还能列出路由表，接口状态和多播成员等信息。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shinerio.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="https://shinerio.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用户和权限</title>
    <link href="https://shinerio.cc/2023/01/23/Tech/Os/Linux/%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/"/>
    <id>https://shinerio.cc/2023/01/23/Tech/Os/Linux/用户和权限/</id>
    <published>2023-01-23T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Linux 系统，不免会和用户和权限打交道，本文介绍了根权限和文件的权限属性等概念和应用。</p><a id="more"></a><h1 id="用户与群组"><a href="#用户与群组" class="headerlink" title="用户与群组"></a>用户与群组</h1><p>使用<code>cat /etc/passwd</code>查看所有用户</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20190830142723.png" alt></p><p>使用<code>cat /etc/group</code>查看所有用户组</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20190830142837.png" alt></p><p>  修改文档所有者或群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span> [-options] [账号/群组] [文件或目录]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变文档所属用户或用户组，-R为可选参数，表示递归表更</span></span><br><span class="line">chown [-R] [账号] [文件或目录]</span><br><span class="line">chown [-R] [账号]:[群组] [文件或目录]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变文档所属用户组</span></span><br><span class="line">chgrp [-R] [群组] [文件或目录]</span><br></pre></td></tr></table></figure><h1 id="Linux权限"><a href="#Linux权限" class="headerlink" title="Linux权限"></a>Linux权限</h1><p>命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod | u g o a | + - = | r w x | 文档路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">chmod | xxx | 文档路径</span><br></pre></td></tr></table></figure></p><ul><li><code>u，g，o</code>代表三种身份owner/group/other，a代表全部身份all</li><li><code>+-=</code>代表三种操作行为（添加/删除/设置权限）  </li><li>rwx表示三种权限，也可以使用4/2/1或者他们的和作为权限，如5代表rx</li><li>xxx代表三位数字，rwx分别为4/2/1，三种权限相加可以得出一种身份的权限  </li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给<span class="built_in">test</span>文件设置所有人拥有所有权限</span></span><br><span class="line">chmod u=rwx,g=rwx,0=rwx test</span><br><span class="line">chmod ugo=rwx test</span><br><span class="line">chmod a=rwx test</span><br><span class="line">chmod ugo+rwx test</span><br><span class="line">chmod 777 test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有人添加执行权限</span></span><br><span class="line">chmod a+x test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有人删除写权限</span></span><br><span class="line">chmod a-w test</span><br></pre></td></tr></table></figure><blockquote><p>对于文件来说x表示文件可以被系统执行的权限，对于目录来说，x代表着可以进入目录的权限，即可以cd进入</p></blockquote><h1 id="文档属性"><a href="#文档属性" class="headerlink" title="文档属性"></a>文档属性</h1><p>使用命令<code>ls -al --full-time</code> 或者<code>ll</code>可以查看文件或者目录的所有属性</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20190830140704.png" alt></p><p>共有7列，分别是：</p><ul><li><font color="red">第一列</font>（共10位） 第1位表示文档类型，<code>d</code>表示目录，-表示普通文件，l表示符号链接，s表示套接字，b表示块设备（光驱、磁盘），c表示字符设备（鼠标、键盘），p表示管道。其中s/b/c/p都是伪文件。第2-10位，共9位，分表对应owner/group/others的权限，rwx分表表示readable/writable/excutable，-表示没有当前权限。</li><li><font color="red">第二列</font> 关联硬链接数，对于一个新建文件夹来说，有两个链接，对于一个新建文件来说，有一个链接。</li><li><font color="red">第三列</font> 表示文档所属owner</li><li><font color="red">第四列</font> 表示文档所属group</li><li><font color="red">第五列</font> 表示文档大小，单位字节，可以通过<code>ls -h</code>选项以最合适的单位显示</li><li><font color="red">第六列</font> 表示文档最后修改时间</li><li><font color="red">第七列</font> 表示文档名，隐藏文件以<code>.</code>开头</li></ul><h1 id="su-和-sudo"><a href="#su-和-sudo" class="headerlink" title="su 和 sudo"></a>su 和 sudo</h1><p>在 Linux 中，<code>su</code>命令和<code>sudo</code>命令有着十分巨大的区别：</p><ul><li><code>su</code>命令会把你切换到根用户<code>root</code></li><li><code>sudo</code>会使用根权限来执行命令</li></ul><p>我们可以通过修改（需要 root 权限）下列文件的中的用户列表，来决定哪些用户可以执行 sudo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/visudo</span><br></pre></td></tr></table></figure><p>默认情况下，这个列表如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">User privilege specification</span></span><br><span class="line">root ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>每一个 sudo 行的语法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user machine=(effective_user) command</span><br></pre></td></tr></table></figure><p>通过上面的语法，我们可以授予某个用户 root 权限，其中每一个域代表：</p><ul><li><code>user</code>是新的<code>sudo</code>用户的用户名 </li><li><code>machine</code>是<code>sudo</code>生效的主机名   </li><li><code>effective_user</code>代表被允许执行命令的有效用户  </li><li><code>command</code>代表这这个用户可以执行的一系列命令</li></ul><h1 id="详解-umask"><a href="#详解-umask" class="headerlink" title="详解 umask"></a>详解 umask</h1><p>每一个文件和文件夹在被创建的时候都会被赋予一定的权限属性，这些值可以通过 umask 来指定。正如 umask 的名称所显示的那样，这个值本身其实就是一个可以禁用相应权限属性的掩码。</p><blockquote><p>掩码由一个有效的<code>4</code>位<code>8</code>进制数值。如果把少于<code>4</code>位的数值作为参数传入，高位会被用 0 补全。</p></blockquote><p>默认情况下，文件夹在被创建的时候能获取的权限属性是<code>777(rwxrwxrwx)</code>，文件在被创建的时候能获取的权限属性是<code>666(rw-rw-rw-)</code>，二者的值都可以被被 umask 的掩码给减掉。</p><p>我们可以这样来查看当前的<code>umask</code>值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">022</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch text_file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir text_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">drwxr-xr-x  2 zhangrui  staff  64 Jan 22 23:15 text_dir</span><br><span class="line">-rw-r--r--  1 zhangrui  staff   0 Jan 22 23:15 text_file</span><br></pre></td></tr></table></figure><p>我们可以通过如下方式修改<code>umask</code>值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前会话中的<span class="built_in">umask</span>设定为077</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> 077</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有者添加所有权限，删除组或其他用户的所有权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> u+rwx,g-rwx,o-rwx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置所有者具有所有权限，设置组或其他用户不具有任何权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> u=rwx,g=,o=</span></span><br><span class="line">drwx------  2 zhangrui  staff  64 Jan 22 23:26 **test_dir**</span><br><span class="line">-rw-------  1 zhangrui  staff   0 Jan 22 23:25 test_file</span><br></pre></td></tr></table></figure></p><blockquote><p>注意默认情况下文件创建不具备x权限，通过umask并不能给文件创建添加x权限，umask只能用来减权限，不能用于添加权限。</p></blockquote><p>如果想要系统上的所有用户或者指定用户都使用设定的<code>umask</code>值的话，我们需要把相应的设定写入<code>/etc/profile</code>或者指定的<code>~/.bashrc</code>文件中去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Linux 系统，不免会和用户和权限打交道，本文介绍了根权限和文件的权限属性等概念和应用。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shinerio.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="https://shinerio.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="https://shinerio.cc/2023/01/23/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://shinerio.cc/2023/01/23/linux/进程管理/</id>
    <published>2023-01-23T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>linux</code>系统中，进程是资源调度的最小单位，进程的管理关乎着你使用<code>linux</code>系统的体验。</p><a id="more"></a><h1 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h1><p>Linux 系统里有几种不同类型的进程：用户进程（User processes）、守护进程（Deamon processes）和内核进程（Kernel processes）。</p><h2 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h2><p>系统里大多数进程都是用户进程。用户进程由通常的用户账户启动，并在用户空间（user space）当中执行。在没有获得额外许可的情况下，通常用户进程无法对处理器进行特殊访问，或是访问启动进程的用户无权访问的文件。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程通常是后台程序，它们往往由一些持续运行的服务来管理。守护进程可以用来监听请求，而后访问某些服务。举例来说，<code>httpd</code>这一守护进程监听访问网络页面的请求。守护进程也可以用来自行启动一些任务。例如，<code>crond</code> 这一守护进程会在预设的时间点启动计划任务。</p><p>尽管用于管理守护进程的服务通常是 <code>root</code> 用户启动的，但守护进程本身往往以非 <code>root</code> 用户启动。这种启动方式，符合「只赋予进程运行所必须的权限」之要求，因而能使系统免于一些攻击。举例来说，若是黑客骇入了 <code>httpd</code> 这一由 <code>Apache</code> 用户启动的守护进程，黑客仍然无法访问包括 <code>root</code> 用户在内的其他用户的文件，或是影响其他用户启动的守护进程。</p><p>守护进程通常由系统在启动时拉起，而后一直运行到系统关闭。当然，守护进程也可以按需启动和终止，以及让守护进程在特定的系统运行级别上执行，或是在运行过程中触发重新加载配置信息。</p><h2 id="内核进程"><a href="#内核进程" class="headerlink" title="内核进程"></a>内核进程</h2><p>内核进程仅在内核空间（kernel space）当中执行。内核进程与守护进程有些相似，它们之间主要的不同在于：</p><ol><li>内核进程对内核数据结构拥有完全的访问权限。</li><li>内核进程不如守护进程灵活：修改配置文件并触发重载即可修改守护进程的行为；但对于内核进程来说，修改行为则需要重新编译内核本身。</li></ol><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p><code>linux</code>是一个多用户、多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。同一时间同一<code>CPU</code>上只能运行一个进程，其他进程只能等待，因此我们可以宽泛地将进程状态分为：</p><ul><li>在CPU上执行，此时进程正在运行</li><li>不在CPU上执行，此时进程不在运行</li></ul><p>进一步来讲，未在运行的进程也可能处于不同的状态：</p><ul><li>TASK_RUNNING</li><li>TASK_INTERRUPTIBLE</li><li>TASK_UNINTERRUPTIBLE</li><li>TASK_STOPPED/TASK_TRACED</li><li>TASK_DEAD - EXIT_ZOMBIE</li><li>TASK_DEAD - EXIT_DEAD</li></ul><h2 id="R-TASK-RUNNING，可执行状态"><a href="#R-TASK-RUNNING，可执行状态" class="headerlink" title="R(TASK_RUNNING，可执行状态)"></a><code>R</code>(TASK_RUNNING，可执行状态)</h2><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为<code>TASK_RUNNING</code>状态。</p><h2 id="S-TASK-INTERRUPTIBLE，可中断状态"><a href="#S-TASK-INTERRUPTIBLE，可中断状态" class="headerlink" title="S(TASK_INTERRUPTIBLE，可中断状态)"></a><code>S</code>(TASK_INTERRUPTIBLE，可中断状态)</h2><p>这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量等）而被挂起，然后当这些事件发生或完成后，对应的等待队列中的一个或多个进程将被唤醒。一般情况下，系统中的大部分进程都处于这个状态。因为系统的CPU数量是有限的，而系统的进程数量是非常多的，所以大部分进程都处于睡眠状态。</p><h2 id="D-TASK-UNINTERRUPTIBLE，不可中断状态"><a href="#D-TASK-UNINTERRUPTIBLE，不可中断状态" class="headerlink" title="D(TASK_UNINTERRUPTIBLE，不可中断状态)"></a><code>D</code>(TASK_UNINTERRUPTIBLE，不可中断状态)</h2><p>与<code>TASK_INTERRUPTIBLE</code>状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</p><p>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，<code>kill -9</code>竟然杀不死一个正在睡眠的进程了！因此我们也很好理解<code>ps</code>命令看到的进程几乎不会出现<code>TASK_UNINTERRUPTIBLE</code>状态，而总是<code>TASK_INTERRUPTIBLE</code>状态。</p><p><code>TASK_UNINTERRUPTIBLE</code>状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用<code>TASK_UNINTERRUPTIBLE</code>状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的<code>TASK_UNINTERRUPTIBLE</code>状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p><p><code>linux</code>系统中也存在容易捕捉的<code>TASK_UNINTERRUPTIBLE</code>状态。执行<code>vfork</code>系统调用后，父进程将进入<code>TASK_UNINTERRUPTIBLE</code>状态，直到子进程调用<code>exit</code>或<code>exec</code>。<br>通过下面的代码就能得到处于<code>TASK_UNINTERRUPTIBLE</code>状态的进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (!vfork()) &#123;</span><br><span class="line">sleep(<span class="number">100</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T-TASK-STOPPED-or-TASK-TRACED-，暂停状态或跟踪状态"><a href="#T-TASK-STOPPED-or-TASK-TRACED-，暂停状态或跟踪状态" class="headerlink" title="T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态"></a><code>T</code> (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态</h2><p>向进程发送一个<code>SIGSTOP</code>信号，它就会因响应该信号而进入<code>TASK_STOPPED</code>状态（除非该进程本身处于<code>TASK_UNINTERRUPTIBLE</code>状态而不响应信号）。（<code>SIGSTOP</code>与<code>SIGKILL</code>信号一样，是非常强制的。不允许用户进程通过<code>signal</code>系列的系统调用重新设置对应的信号处理函数。）  向进程发送一个<code>SIGCONT</code>信号，可以让其从<code>TASK_STOPPED</code>状态恢复到<code>TASK_RUNNING</code>状态。</p><p>当进程正在被跟踪时，它处于<code>TASK_TRACED</code>这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在<code>gdb</code>中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于<code>TASK_TRACED</code>状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p><p>对于进程本身来说，<code>TASK_STOPPED</code>和<code>TASK_TRACED</code>状态很类似，都是表示进程暂停下来。而<code>TASK_TRACED</code>状态相当于在<code>TASK_STOPPED</code>之上多了一层保护，处于<code>TASK_TRACED</code>状态的进程不能响应<code>SIGCONT</code>信号而被唤醒。只能等到调试进程通过<code>ptrace</code>系统调用执行<code>PTRACE_CONT</code>、<code>PTRACE_DETACH</code>等操作（通过<code>ptrace</code>系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复<code>TASK_RUNNING</code>状态。</p><h2 id="Z-TASK-DEAD-EXIT-ZOMBIE-，退出状态，进程成为僵尸进程"><a href="#Z-TASK-DEAD-EXIT-ZOMBIE-，退出状态，进程成为僵尸进程" class="headerlink" title="Z(TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程"></a><code>Z</code>(TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程</h2><p>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除<code>task_struct</code>结构（以及少数资源）以外。于是进程就只剩下<code>task_struct</code>这么个空壳，故称为僵尸。  </p><p>之所以保留<code>task_struct</code>，是因为<code>task_struct</code>里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在<code>shell</code>中，<code>$?</code>变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。  </p><p>当然，内核也可以将这些信息保存在别的地方，而将<code>task_struct</code>结构释放掉，以节省一些空间。但是使用<code>task_struct</code>结构更为方便，因为在内核中已经建立了从<code>pid</code>到<code>task_struct</code>查找关系，还有进程间的父子关系。释放掉<code>task_struct</code>，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p><p>父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是<code>SIGCHLD</code>，在通过<code>clone</code>系统调用创建子进程时，可以设置这个信号。</p><h2 id="X-TASK-DEAD-EXIT-DEAD-，退出状态，进程即将被销毁"><a href="#X-TASK-DEAD-EXIT-DEAD-，退出状态，进程即将被销毁" class="headerlink" title="X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁"></a><code>X</code> (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁</h2><p>进程在退出过程中也可能不会保留它的<code>task_struct</code>。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）<br>此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。</p><h1 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h1><p>每一个进程都是被别的进程启动的，或者说是复刻（Fork）的。当系统刚刚启动的时候，有一个非常特别的根进程 init ，它就是是直接被操作系统内核启动的。</p><p>这样一来，这个系统中运行的所有进程集合就构成了一颗以<code>init</code>进程为根节点的进程树，所有的其他进程都有一个父进程，也有可能有多个子进程。</p><p>比方说，每次我们在<code>bash</code>命令行提示符下执行一个命令的时候，bash 会复刻一个新的进程来执行这个命令，这时这个进程就变成了<code>bash</code>的子进程了。</p><p>相似地，当我们看见一个「登录」提示符时，这其实是<code>login</code>命令在运行着。如果我们成功的登录了，<code>login</code>命令会复刻一个新的进程来执行登录用户选择的<code>shell</code>。</p><p>我们可以使用<code>ps auxf</code>命令来查看树形结构的进程列表，像下面这样:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-+= 00001 root /sbin/launchd</span><br><span class="line"> |--= 00085 root /usr/libexec/logd</span><br><span class="line"> |--= 00086 root /usr/libexec/UserEventAgent (System)</span><br><span class="line"> |--= 00089 root /System/Library/PrivateFrameworks/Uninstall.framework/Resource</span><br><span class="line"> |--= 00090 root /System/Library/Frameworks/CoreServices.framework/Versions/A/F</span><br><span class="line"> |--= 00091 root /System/Library/PrivateFrameworks/MediaRemote.framework/Suppor</span><br><span class="line"> |-+= 00093 root /usr/sbin/systemstats --daemon</span><br><span class="line"> | \--- 00359 root /usr/sbin/systemstats --logger-helper /private/var/db/system</span><br><span class="line"> |--= 00095 root /usr/libexec/configd</span><br><span class="line"> |--= 00096 root endpointsecurityd</span><br></pre></td></tr></table></figure><h1 id="进程归属权"><a href="#进程归属权" class="headerlink" title="进程归属权"></a>进程归属权</h1><p>每一个进程都归属于某个特定的用户，归属于该用户的进程有权限像该用户直接登录了一样执行所有该用户可以执行的所有命令。</p><p>比方说，假如有一个进程归<code>shinerio</code>用户所有，那么这个进程就可以做所有<code>shinerio</code>用户能做的事情了：编辑<code>shinerio</code>用户<code>home</code>目录下的文件，启动一个归属于<code>shinerio</code>用户的新进程，等等。</p><p>系统进程比如<code>init</code>和<code>login</code>归属于<code>root</code>用户，而且当一个根进程复刻一个新进程的时候，它可以改变这个子进程的归属。</p><p>所以，当我们登录后， <code>login</code>命令会复刻一个新的进程我运行我们的<code>shell</code>，但是新的进程是所属于成功登陆的那个用户的。接下来所有的后续命令都会以该用户的名义执行，所启动的进程都归属于他。</p><p>默认情况下，只有 root 进程可以像这样改变归属权。</p><h1 id="Init-System"><a href="#Init-System" class="headerlink" title="Init System"></a>Init System</h1><p>操作系统内核在初始化进程中所做的最后一件事情就是启动「init system」，也就是执行 <code>/sbin/init</code>命令。「init system」有很多种，但它们都有相同的职责：</p><ol><li>控制哪些服务在系统启动时跟随启动</li><li>提供可以开启、停止服务的工具，并且给出服务的状态信息总览</li><li>提供一个可以编写新的服务的框架</li></ol><p>这里的服务涵盖了从<code>web</code>服务器到用来管理登录的系统级服务器在内的所有服务。基本上，一个「init system」的工作就是让所有面向用户（即非内核）的程序和服务运行起来。</p><blockquote><p>例如，Ubuntu和centos都使用<code>systemd</code>作为默认的「init system」。根据 Linux 惯例，字母 d 是守护进程（daemon）的缩写。 Systemd这个名字的含义，就是它要<strong>守护整个系统</strong>。</p></blockquote><p>(1)-(3) 中设计的特定命令和工具会因不同的「init system」而各有不同。<code>Linux</code>系统历史上最通用的一个「init system」叫做「System V Init」，它是以极具影响力的<code>UNIX SYSTEM V</code>来命名的。在现在<code>Linux</code>系统中，同时被<code>CentOS</code>、<code>RedHad</code>、<code>Debian</code>、<code>Ubuntu</code>等等主流发行版本所采用的「init system」叫做「systemd init system」。</p><p>有两点需要铭记：</p><ol><li>不同的 Linux 发行版本可以使用不同的「init system」</li><li>同一 Linux 发型版本的不同版本号可以使用不同的「init system」</li></ol><h1 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h1><p><code>ps</code>命令是process status的简称，用于显示当前运行的进程的信息。在不使用任何标识的情况下，<code>ps</code>会显示所有当前用户启动的进程，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 9961 pts/0    00:00:00 bash</span><br><span class="line"> 9981 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><ul><li>PID: 进程的ID号</li><li>TTY: 终端名称缩写</li><li>TIME: CPU时间，即进程使用CPU的总时间</li><li>CMD: 所执行的命令名称。</li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>ps</code>命令支持的参数很多，这里我们只列出常用的一些。</p><ul><li><code>a</code>显示当前终端所有进程</li><li><code>-A</code>显示系统所有进程</li><li><code>e</code>显示每个进程使用的环境变量</li><li><code>-e</code>显示所有进程，等价于<code>-A</code></li><li><code>-f</code>显示进程之间关系</li><li><code>-H</code>显示树桩结构</li><li><code>u</code>显示进程的归属用户及内存的使用情况</li><li><code>x</code>显示没有控制终端的进程</li></ul><h2 id="常见使用方式"><a href="#常见使用方式" class="headerlink" title="常见使用方式"></a>常见使用方式</h2><h3 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a>ps -ef</h3><p>显示所有进程的pid、启动命令和父进程pid，常配合管道符<code>|</code>和<code>grep</code>来查找某个特定进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class="line">    0     1     0   0 11:36AM ??         1:18.88 /sbin/launchd</span><br><span class="line">    0    85     1   0 11:36AM ??         1:16.91 /usr/libexec/logd</span><br><span class="line">    0    86     1   0 11:36AM ??         0:06.62 /usr/libexec/UserEventAgent (System)</span><br><span class="line">    0    89     1   0 11:36AM ??         0:01.04 /System/Library/PrivateFrameworks/Uninstall.framework/Resources/uninstalld</span><br></pre></td></tr></table></figure><ul><li>UID：启动用户ID</li><li>PID：进程ID</li><li>PPID：父进程 ID</li><li>C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高。</li><li>STIME：进程启动的时间</li><li>TTY：终端名称缩写</li><li>TIME：CPU时间，即进程使用CPU的总时间</li><li>CMD：启动进程所用的命令和参数</li></ul><h3 id="ps-–aux"><a href="#ps-–aux" class="headerlink" title="ps –aux"></a>ps –aux</h3><p>适合于需要查看进程更多的详细信息，包括系统资源占用情况、进程状态等。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.8  77664  8668 ?        Ss    2022   1:08 /sbin/init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S     2022   0:05 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;    2022   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        I&lt;    2022   0:00 [mm_percpu_wq]</span><br></pre></td></tr></table></figure></p><ul><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用CPU的百分比</li><li>%MEM：进程占用物理内存的百分比</li><li>VSZ：进程占用的虚拟内存大小（单位：KB）</li><li>RSS：进程占用的物理内存大小（单位：KB）</li><li>TTY：终端名称缩写</li><li>STAT：进程状态，其中 <code>S（Sleep）可中断，</code>s-表示该进程是会话的先导进程。</li><li>STARTED：进程的启动时间</li><li>TIME：CPU时间，即进程使用CPU的总时间</li><li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li></ul><h1 id="TOP命令"><a href="#TOP命令" class="headerlink" title="TOP命令"></a>TOP命令</h1><p><code>ps</code>为我们提供了进程的一次性的快照，它所提供的查看结果并不动态连续。如果想对进程时间监控，应该使用<code>TOP</code>命令。</p><p>TOP交互式命令：</p><ul><li><code>P</code> 按照 CPU 占用来排序</li><li><code>M</code>  按照内存占用来排序</li><li><code>q</code> 退出</li></ul><p><code>TOP -p pid</code>可以查看指定进程信息。</p><h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p>我们可以使用<code>kill</code>命令或<code>killall</code>命令来终止一个进程。常用的kill命令如下：</p><ul><li>1 (HUP)：重新加载进程。</li><li>2 (INT):    中断（同<code>Ctrl + C</code>）</li><li>3 ( QUIT):   退出（同<code>Ctrl + \</code>）</li><li>9 (KILL)：无条件强制杀死一个进程。</li><li>15 (TERM)：正常停止一个进程。</li><li>18 (CONT):    继续（与STOP相反）</li><li>19 (STOP):    暂停（同<code>Ctrl + Z</code>）</li></ul><blockquote><p>只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略</p></blockquote><p>默认情况下，<code>kill</code>和<code>killall</code>命令会发送<code>TERM</code>信号给特定的进程。<code>TERM</code>信号是一个「优雅」的终止信号，进程收到这个信号时会以合适的方式处理和结束进程。比如，被终止的进程可能想要在终止之前完成当前的任务、或者是清理可能会残留在系统中的临时文件等等。</p><p>如果一个进程有漏洞导致它已经不能响应<code>TERM</code>信号了，这种情况下我们就只能发送另一个比较激进的信号了。有两种方法可以发送这个信号：</p><ol><li>kill -KILL pid</li><li>kill -9 pid</li></ol><p><code>kill -9</code>或者<code>killall -9</code>指令都是非常激进了，粗略地等同于直接拔掉计算机的电源。像这样来终止进程可能会留下一堆麻烦，只不过如果进程真的不响应了，也没啥别的办法。所以，在使用<code>kill -9 PID</code>之前，一定要先尽量尝试使用<code>kill PID</code>才是。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://liam.page/2020/01/10/the-states-of-processes-on-Linux/" target="_blank" rel="noopener"># Linux 系统里的进程状态</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt;系统中，进程是资源调度的最小单位，进程的管理关乎着你使用&lt;code&gt;linux&lt;/code&gt;系统的体验。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shinerio.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="https://shinerio.cc/tags/linux/"/>
    
      <category term="thread" scheme="https://shinerio.cc/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>数据库隔离级别</title>
    <link href="https://shinerio.cc/2023/01/23/Tech/Middleware/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://shinerio.cc/2023/01/23/Tech/Middleware/Database/数据库隔离级别/</id>
    <published>2023-01-23T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要目的是阐明数据库的四种隔离级别以及在mysql下实现隔离的原理。</p><a id="more"></a><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>数据库事务隔离级别从低到高分别是：read uncommitted、read committed、retpeatable read、serializable，依次解决了数据库脏读、不可重复读、幻读问题。</p><ul><li><strong>脏读</strong>：一个事务读到了另一个事务未提交的数据</li><li><strong>不可重复读</strong>：在一个事务中多次读取数据过程中发生了另一个事务对数据进行了<strong>更新</strong>，导致前后两次查询数据结果不同，主要体现在数据库数据前后数据内容的不一致。</li><li><strong>幻读</strong>：一个事务在执行过程中读取到了另一个事务已提交的插入数据；即在第一个事务开始时读取到一批数据，但此后另一个事务又插入了新数据并提交，此时第一个事务又读取这批数据但发现多了一条，即好像发生幻觉一样。主要体现在数据库数据数目不一致的情况（serializable解决了这个问题，需要锁住满足条件的所有记录以及相近的记录）</li></ul><h1 id="隔离原理"><a href="#隔离原理" class="headerlink" title="隔离原理"></a>隔离原理</h1><p>Mysql的默认隔离级别是可重复读，是读已提交。数据库的隔离级别其实是依赖锁实现的。</p><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>读未提交其实就是数据库操作不会加锁，其实就是没有隔离。B事务能看到A事务已经修改但没有提交的数据，这时候如果A事务回滚，B事务看到的其实就是脏数据，一般情况下我们不会选用这种级别。</p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>这个是pg、oracle等数据库的默认隔离级别。一个事务只能读到另一个事务已经提交的数据。在mysql中可重复读和读已提交都是通过<code>MVCC</code>进行实现的，区别在于可重读是事务启动的时候就生成read view整个事务结束都一直使用这个read view，而在读已提交中则是每执行一条语句就重新生成最新的read view。</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>mysql通过MVCC解决了不可重复读的问题，本质上是一种快照读。在事务开启的时候生成快照，后续读到的都是当时的快照数据，即使当前数据已经其他事务修改并提交。具体规则如下：</p><ol><li>当前事务内的更新可以读到</li><li>其实事务未提交的不能读到</li><li>其他事务在快照创建后提交的不能读到</li><li>其他事务在快照创建前提交的可以读到（这种其实另一个事务已经结束了）</li></ol><p>如下，可以看到虽然B事务对数据进行了修改并提交，但是事务A第二次读到的只还是10。</p><p><img src="http://shinerio.oss-cn-beijing.aliyuncs.com/obsidian%2Fmysql%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.svg" alt="mysql可重复读"><br>我们在<code>postgre</code>下进行相同的测试就可以发现<code>postgre</code> 默认隔离级别是读已提交。</p><p><img src="http://shinerio.oss-cn-beijing.aliyuncs.com/obsidian%2Fpostgresql%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.svg" alt="postgresql不可重复读"><br>可以通过命令行设置当前事务隔离级别，即可以得到和mysql相同的预期。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=# show default_transaction_isolation;</span><br><span class="line"> default_transaction_isolation </span><br><span class="line">-------------------------------</span><br><span class="line"> read committed</span><br><span class="line">(1 row)</span><br><span class="line">postgres=# begin;</span><br><span class="line">BEGIN</span><br><span class="line">postgres=*# set default_transaction_isolation='repeatable read';</span><br><span class="line">SET</span><br></pre></td></tr></table></figure><p>通过行级锁可以解决并发写，修改的时候需要对数据行加锁，且在事务提交时才会释放。</p><blockquote><p>这里需要注意一下，如果更新的条件没有用到索引的话，mysql会对所有行加行锁，然后再判断不满足的行进行释放，这个过程其实也比较影响性能。所以，如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。</p></blockquote><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>mysql有两种读数据方式，一种是快照读(普通select)，另一种是当前读(select … for update,update,delete)。mysql可以完全解决快照读下的幻读问题，但是并不能完全解决当前读下的幻读问题。解决方式是使用了行锁+间隙锁，这个锁叫做 Next-Key锁。</p><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>mysql通过mvcc解决了快照读下的幻读问题。当启动事务后执行查询会创建一个read view，后续的查询语句会利用这个read view在undo log版本中找到事务，即便其他事务后续插入或删除了新的数据，原事务也只会读原来的快照，避免了幻读问题。</p><p>以下以<code>select ... for update</code> 举例说明，update和delete同理。</p><p><img src="http://shinerio.oss-cn-beijing.aliyuncs.com/obsidian%2Fmysql%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB.svg" alt="mysql快照读下解决幻读"></p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>mysql数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。如下图被分成了（负无穷,10）、(10,30)、(30,正无穷)三个区间，这三个区间是可以加间隙锁的。注意，mysql的间隙锁依赖于索引，否则会为整个表加上间隙锁，即所有的数据插入、删除都无法执行。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/mysql%E9%97%B4%E9%9A%99%E9%94%81.png" alt="image.png"></p><p>如下操作，事务A对(10,30)区间增加了间隙锁，对数据行10和30增加的行锁，来保证不会出现幻读。<br><img src="http://shinerio.oss-cn-beijing.aliyuncs.com/obsidian%2Fmysql%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB.svg" alt="mysql当前读下解决幻读"></p><blockquote><p>使用等值条件会将值两端区间都增加间隙锁，如<code>price = 10</code> 或<code>price &lt;= 10</code> 都会将(负无穷,10)和(10,30)两个区间加锁。</p></blockquote><p>注意mysql并没有真正意义上解决幻读的问题，如下场景可以看出同一事务的两次查询看到的是不同的现象，因此解决幻读的最好方式是及早使用当前读的方式对数据加间隙锁。</p><p><img src="http://shinerio.oss-cn-beijing.aliyuncs.com/obsidian%2Fmysql%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8B%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98.svg" alt="mysql当前读下幻读问题"></p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>要彻底解决幻读问题，只能采用串行化，简单粗暴地将所有sql命令串行化执行，显然这样会极大地影响数据库性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要目的是阐明数据库的四种隔离级别以及在mysql下实现隔离的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="middleware" scheme="https://shinerio.cc/categories/middleware/"/>
    
    
      <category term="database" scheme="https://shinerio.cc/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>NAT Overview</title>
    <link href="https://shinerio.cc/2022/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4W%20For%20NAT/"/>
    <id>https://shinerio.cc/2022/05/04/计算机网络/4W For NAT/</id>
    <published>2022-05-04T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-NAT"><a href="#1-What-is-NAT" class="headerlink" title="1. What is NAT?"></a>1. What is NAT?</h1><h2 id="1-1-NAT-Level-4"><a href="#1-1-NAT-Level-4" class="headerlink" title="1.1 NAT(Level 4)"></a>1.1 NAT(Level 4)</h2><p>NAT（Network address translation）即网络地址转换，工作在OSI模型的三层或四层（PNAT），用于修改IP数据包中的IP地址和端口。当在专用网内部的一些主机本来已经分配到了local ip地址，但又想和Internet的主机通信时，可使用NAT方法。</p><a id="more"></a><p>从NAT的映射方式来看，NAT可以分为Basic NAT和PNAT：</p><ul><li><strong>Basic NAT</strong>，只转化IP，IP不复用，不映射端口。</li><li><strong>PNAT</strong>，除了转化IP，还复用IP，做端口映射，可以用于多个内部地址映射到少量（甚至一个）外部地址。</li></ul><p>从NAT的生命周期来看，可以分为静态NAT和动态NAT：</p><ul><li><strong>静态NAT</strong>，将内部网络中的每个主机都永久映射成外部网络中的某个地址。</li><li><strong>动态NAT</strong>，在外部网络中定义了一个或多个合法地址池，采用动态分配的方法将内部网络映射为外网网络。会话存在过期时间，过期后自动回收。</li></ul><p>从NAT的形态上来看，可以分为锥型NAT、对称型NAT。</p><ul><li><strong>锥型NAT</strong>，锥形NAT只与源地址、源端口有关，只要源地址和源端口不变，都会分配同一个外网地址和端口。因此外网主机可以通过访问映射后的公网地址和端口，实现访问位于内网的主机设备功能。</li><li><strong>对称NAT</strong>，从同一个内网IP和端口发送到同一个目的IP和端口的请求都会被映射到同一个外网IP和端口。但四元组(SIP，Sport, DIP, Dport)只要有一个发生变化都会使用不同的映射。</li></ul><blockquote><p>锥型NAT的通信双方是对等的，外网主机不管是换IP还是端口，感知到的都是对端的同一个IP和端口在提供某个特定服务，而对称型NAT违反了协议双方对等的原则，外网主机是无法主动访问内网主机的，换个外网地址或端口，NAT后的地址和端口就会变化。对称型NAT下，外网主机主动发起tcp连接，源端口是随机的（对于内网的NAT来说，即目的端口是不固定的），那么对称型NAT分配的端口也是随机的，当然这个随机端口也无法被NAT回内网。</p></blockquote><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1652541034741.png" alt="enter description here"></p><blockquote><p>锥型NAT有两种特殊形态，即地址受限型NAT和端口受限型NAT。地址受限型NAT校验目的IP（外网的IP），因此地址受限型NAT不能主动连接内网中的主机地址，连接必须由内网地址发起。端口受限型校验目的端口和ip，地址受限型NAT只有内网主机与之通讯后，才可以进行通讯，不用担心端口号是否与内网请求的端口相同，但是端口受限型NAT也增加了端口限制。比如内网使用ip1:port1访问外网ip2:port2，地址受限型可以使用ip2:port3访问ip1:port1，但是端口受限型只能使用ip2:port2访问ip1:port1。</p></blockquote><div class="table-container"><table><thead><tr><th>NAT类型</th><th>说明</th></tr></thead><tbody><tr><td>全锥型NAT</td><td>任何公网主机都可与之通讯。双方都可以主动发起。</td></tr><tr><td>地址受限锥型NAT</td><td>只有内网主动连接的公网主机可与之通讯，必须内网主机发起。且此公网主机可通过任意端口与内网主机通讯。</td></tr><tr><td>端口受限锥型NAT</td><td>只有内网主动连接的公网主机的连接可与之通讯，必须内网主机发起。且此公网只能通过固定的端口与之进行通讯。</td></tr><tr><td>对称型NAT</td><td>根据四元组创建NAT映射，四元组中的任何一项发生变化均导致NAT映射的更换。此形状双方一对一映射，因此被称之为对称NAT</td></tr></tbody></table></div><h2 id="1-2-NAT-Level-7"><a href="#1-2-NAT-Level-7" class="headerlink" title="1.2 NAT(Level 7)"></a>1.2 NAT(Level 7)</h2><p>普通NAT实现了对UDP或TCP报文头中的的IP地址及端口转换功能，但对应用层数据载荷中的字段无能为力，在许多应用层协议中，比如多媒体协议（H.323、SIP等）、FTP、SQLNET等，TCP/UDP载荷中带有地址或者端口信息，这些内容不能被NAT进行有效的转换，就可能导致问题。而NAT ALG（Application Level Gateway，应用层网关）技术能对多通道协议进行应用层报文信息的解析和地址转换，将载荷中需要进行地址转换的IP地址和端口或者需特殊处理的字段进行相应的转换和处理，从而保证应用层通信的正确性。ALG需要识别并适配每一种应用协议，不同应用协议的载荷中IP地址和端口的位置不同，因此具有很大的局限性，幸运的是ALG支持了我们常用的大多数协议。</p><h1 id="2-Why-we-need-NAT-and-why-we-hate-NAT"><a href="#2-Why-we-need-NAT-and-why-we-hate-NAT" class="headerlink" title="2. Why we need NAT and why we hate NAT?"></a>2. Why we need NAT and why we hate NAT?</h1><h2 id="2-1-advantage"><a href="#2-1-advantage" class="headerlink" title="2.1 advantage"></a>2.1 advantage</h2><ul><li>多个内网主机共享公网IP，节省IP资源</li><li>作为内网流量统一出口，共享带宽</li><li>隐藏内网主机真实地址，避免直接暴露，可以抵挡port scan之类的攻击</li><li>工作在NAT模式下的lvs四层负载均衡</li></ul><h1 id="2-2-weakness"><a href="#2-2-weakness" class="headerlink" title="2.2 weakness"></a>2.2 weakness</h1><ul><li>NAT下的网络被分为外网和内网两部分，以网关的形式作为私网到公网的路由出口，双向流量都要经过NAT设备，容易成为性能瓶颈</li><li>由于NAT将内部网络信息进行了隐藏和转换，NAT下的设备无法进行对等网络传输（需要穿透NAT）</li><li>NAT不能实现对通信双方的全透明，因为上层协议可能在传输的数据包中携带ip和port信息（需要七层ALG）</li><li>应用层需保持UDP会话连接。由于NAT资源有限，所以UDP的会话会很快被回收（以便端口重用）。由于UDP是无连接的，因此UDP层应用需要在无数据传输、但需要保持连接时通过heartbeat的方式保持会话不过期。</li></ul><h1 id="3-How-to-NAT-in-router"><a href="#3-How-to-NAT-in-router" class="headerlink" title="3. How to NAT in router?"></a>3. How to NAT in router?</h1><p>以下配置了子网10.10.10.0/24的前32个地址和子网10.10.20.0/24的前32个地址可以通过NAT访问外网，内部网络中可能有其他设备具有其他地址，但这些地址不会被转换。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1652546543650.png" alt="enter description here"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">interface ethernet 0</span><br><span class="line"> ip address 10.10.10.1 255.255.255.0</span><br><span class="line"> ip nat inside</span><br><span class="line"></span><br><span class="line">!--- Defines Ethernet 0 with an IP address and as a NAT inside interface.</span><br><span class="line"></span><br><span class="line">interface ethernet 1</span><br><span class="line"> ip address 10.10.20.1 255.255.255.0</span><br><span class="line"> ip nat inside</span><br><span class="line"></span><br><span class="line">!--- Defines Ethernet 1 with an IP address and as a NAT inside interface.</span><br><span class="line"></span><br><span class="line">interface serial 0</span><br><span class="line"> ip address 172.16.10.64 255.255.255.0</span><br><span class="line"> ip nat outside</span><br><span class="line"></span><br><span class="line">!--- Defines serial 0 with an IP address and as a NAT outside interface.</span><br><span class="line"></span><br><span class="line">ip nat pool no-overload 172.16.10.1 172.16.10.63 prefix 24</span><br><span class="line"> !</span><br><span class="line"></span><br><span class="line">!--- Defines a NAT pool named no-overload with a range of addresses !--- 172.16.10.1 - 172.16.10.63</span><br><span class="line"></span><br><span class="line">ip nat inside source list 7 pool no-overload </span><br><span class="line"> !</span><br><span class="line"> !</span><br><span class="line"></span><br><span class="line">!--- Indicates that any packets received on the inside interface that !--- are permitted by access-list 7 has !--- the source address translated to an address out of the !--- NAT pool "no-overload".</span><br><span class="line"></span><br><span class="line">access-list 7 permit 10.10.10.0 0.0.0.31</span><br><span class="line">access-list 7 permit 10.10.20.0 0.0.0.31</span><br><span class="line"></span><br><span class="line">!--- Access-list 7 permits packets with source addresses ranging from !--- 10.10.10.0 through 10.10.10.31 and 10.10.20.0 through 10.10.20.31.</span><br></pre></td></tr></table></figure><h1 id="4-How-to-NAT-in-Linux"><a href="#4-How-to-NAT-in-Linux" class="headerlink" title="4. How to NAT in Linux?"></a>4. How to NAT in Linux?</h1><p>在物理网络中，NAT功能一般由路由器或防火墙之类的设备来承载，而<code>Iptables</code>则是linux提供的用户态命令行工具(实际是工作的是在内核态的<code>netfilter</code>)，可以通过在nat表中增加规则，实现在<code>PREROUTING</code>和<code>POSTROUTING</code>链上的<code>DNAT</code>和<code>SNAT</code>功能。要使用Linux提供的nat功能，首先需要确认主机支持转发，可通过以下方式确认:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>回显结果：1为开启，0为关闭，默认为0。</p><blockquote><p>如未打开，可通过修改<code>/etc/sysctl.conf</code>文件，配置<code>net.ipv4.ip_forward = 1</code>后执行<code>sysctl -p /etc/sysctl.conf</code>启用转发功能。</p></blockquote><h2 id="4-1-SNAT"><a href="#4-1-SNAT" class="headerlink" title="4.1 SNAT"></a>4.1 SNAT</h2><p>SNAT是为了让内网主机访问外网主机，将出方向报文的源地址进行替换，因此可以在<code>POSTROUTING</code>链上添加如下规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将192.168.1.0/24网段的源地址替换为100.32.1.100</span></span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -s 192.168.1.0/24 -j SNAT --to 100.32.1.100</span><br></pre></td></tr></table></figure><h2 id="4-2-DNAT"><a href="#4-2-DNAT" class="headerlink" title="4.2 DNAT"></a>4.2 DNAT</h2><p>DNAT是为了让外网主机访问内网主机，将入方向报文的目的地址进行替换，因此可以在<code>PREROUTING</code>链上添加如下规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全端口映射</span></span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -d 100.32.1.101 -j DNAT --to 192.168.1.101</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单端口映射</span></span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp -d 100.32.1.101 --dport 80 -j DNAT --to 192.168.1.101:80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 范围端口映射</span></span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp -d 100.32.1.101 --dport 10000:20000 -j DNAT --to 192.168.1.101:30000-40000</span><br></pre></td></tr></table></figure><blockquote><p>iptables提供的NAT功能并不会对范围大小、端口冲突功能进行检查。iptables的工作原理为在一条链上从前到后匹配，前面的规则会覆盖后面的规则。 </p></blockquote><h2 id="4-3-Conntrack"><a href="#4-3-Conntrack" class="headerlink" title="4.3 Conntrack"></a>4.3 Conntrack</h2><p>上面我们提到了使用<code>iptables</code>实现SNAT功能，而SNAT存在多个内网主机通过分配端口复用同一个公网IP的情况，因此需要有个状态保持机制来记录这个会话，这个功能模块就是<code>Conntrack</code>。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1651666903738.png" alt="enter description here"><br>连接跟踪（Conntrack），顾名思义，就是跟踪（并记录）连接的状态。例如，上图是一台IP地址为<code>10.1.1.2</code>的Linux机器，我们能看到这台机器上有三条连接：</p><ul><li>内部访问外部HTTP服务的连接（目的端口 80）</li><li>外部访问内部FTP服务的连接（目的端口 21）</li><li>内部访问外部DNS 服务的连接（目的端口 53）</li></ul><p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p><ul><li>从数据包中提取元组（tuple）信息，辨别数据流（flow）和对应的连接（connection）</li><li>为所有连接维护一个状态数据库（conntrack table），例如连接的创建时间、发送包数、发送字节数等等</li><li>回收过期的连接（GC）</li><li>为更上层的功能（例如 NAT）提供服务</li></ul><p><code>Conntrack</code>在Linux中是通过<code>NetFilter</code>实现，<code>Netfilter</code> 是Linux内核中一个对数据包进行控制、修改和过滤（manipulation and filtering）的框架。它在内核协议栈中设置了若干hook点，以此对数据包进行拦截、过滤或其他处理。说地更直白一些，hook机制就是在数据包的必经之路上设置若干检测点，所有到达这些检测点的包都必须接受检测，根据检测的结果决定：</p><ul><li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li><li>修改：修改IP地址或端口进行NAT，然后将包放回正常的包处理逻辑</li><li>丢弃：安全策略或防火墙功能</li></ul><blockquote><p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其他模块（例如 NAT）基于<code>Netfilter hook</code>完成的。</p></blockquote><h1 id="5-How-to-NAT-in-cloud？"><a href="#5-How-to-NAT-in-cloud？" class="headerlink" title="5. How to NAT in cloud？"></a>5. How to NAT in cloud？</h1><p>“NAT网关”作为云服务的一种，面向公有云客户服务，工作在overlay网络，其一般基于通用服务器（一般为Linux服务器）实现。在How to NAT in Linux一节中，我们已经知道，可以通过<code>netfilter</code>来实现，但这种方式只能靠单机工作，存在着<strong>性能瓶颈</strong>和<strong>单点故障</strong>的问题。为了提高性能和可靠性，我们可以从两方面入手，分别是<code>scale up</code>和<code>scale out</code>。同时，公有云服务面向了很多客户，因此云上NAT的功能对我们还有一个特殊的要求，实现多租户配置隔离。</p><h2 id="5-1-Scale-up"><a href="#5-1-Scale-up" class="headerlink" title="5.1 Scale up"></a>5.1 Scale up</h2><h3 id="5-1-1-Better-Hardware"><a href="#5-1-1-Better-Hardware" class="headerlink" title="5.1.1 Better Hardware"></a>5.1.1 Better Hardware</h3><p>Scale up最简单的方式就是增强硬件，这种方式只能在一定程度上提高性能，但受限于硬件能力，还是存在性能上限，且存在单点故障的缺陷。</p><ul><li>bigger cpu core</li><li>greater bandwidth NIC</li></ul><h3 id="5-1-2-Architecture-Refactor"><a href="#5-1-2-Architecture-Refactor" class="headerlink" title="5.1.2 Architecture Refactor"></a>5.1.2 Architecture Refactor</h3><p>Scale up的另外一种方式就是重构，通过这种方式我们可以提高硬件的利用效率，从而增强我们的转发性能。</p><p>网络设备（路由器、交换机等）需要在瞬间进行大量的报文收发，因此在传统的网络设备上，往往能够看到专门的NP（Network Process）处理器，有的用FPGA，有的用ASIC。这些专用器件通过内置的硬件电路（或通过编程形成的硬件电路）高效转发报文，只有需要对报文进行深度处理的时候才需要CPU干涉。</p><p>但在公有云、NFV等应用场景下，基础设施以CPU为运算核心，往往不具备专用的NP处理器，操作系统也以通用Linux为主，软件包的处理通常会经过用户态和内核态之间的切换。在虚拟化环境下，路径则会更长，需要分别经过HostOs和GuestOs两层用户态和内核态的切换。基于Linux服务器的报文转发，主要存在以下问题：</p><ol><li>传统的收发报文方式都必须采用硬中断来做通讯，每次硬中断大约消耗100微秒，这还不算因为终止上下文所带来的Cache Miss。</li><li>数据必须从内核态用户态之间切换拷贝带来大量CPU消耗，全局锁竞争。</li><li>收发包都有系统调用的开销。</li><li>内核工作在多核上，为可全局一致，即使采用Lock Free，也避免不了锁总线、内存屏障带来的性能损耗。</li><li>从网卡到业务进程，经过的路径太长，有些其实未必要的，例如netfilter框架，这些都带来一定的消耗，而且容易Cache Miss。</li></ol><p>为了提升在通用服务器的数据包处理效能，Intel推出了服务于IA（Intel Architecture）系统的DPDK(Data Plane Development Kit)技术。DPDK应用程序运行在操作系统的User Space，利用自身提供的数据面库进行收发包处理，绕过了Linux内核态协议栈，以提升报文处理效率。DPDK的UIO驱动屏蔽了硬件发出中断，然后在用户态采用主动轮询的方式，这种模式被称为<a href="http://doc.dpdk.org/guides/prog_guide/poll_mode_drv.html" target="_blank" rel="noopener">PMD</a>（Poll Mode Driver）。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1652454183396.png" alt="enter description here"></p><p>左边是原来的方式数据从 网卡 -&gt; 驱动 -&gt; 协议栈 -&gt; Socket接口 -&gt; 业务</p><p>右边是DPDK的方式，基于UIO（Userspace I/O）旁路数据。数据从 网卡 -&gt; DPDK轮询模式-&gt; DPDK基础库 -&gt; 业务</p><p>用户态的好处是易用开发和维护，灵活性好。并且Crash也不影响内核运行，鲁棒性强。</p><h2 id="5-2-Scale-out"><a href="#5-2-Scale-out" class="headerlink" title="5.2 Scale out"></a>5.2 Scale out</h2><p>Scale up的本质还是在提高单机的性能，存在理论性能上限和单点故障问题。云计算的本质就是池化，实现网关的动态弹性扩容才是根本解决方案。通过Scale out的方式可以无限扩容，提高性能，且集群化后，可以避免单点故障，提高可靠性。</p><p>由于NAT网关是有状态的网关，因此无法直接横向扩容，每个节点不能单独管理会话，否则很容易出现冲突。因此Aws提出了一种三层架构形态的网络，即<code>HyperPlane</code>。<code>HyperPlane</code>将网络分为以下三种类型：</p><ul><li>TOP: 无状态的转发，一旦网络连接建立后，转发只会在TOP层完成，可以无限横向扩容。</li><li>FLOW MASTER：用来记录网络连接信息，FLOW MASTER是无状态通用的。</li><li>DECIDER：具体实现网络功能逻辑，不同网关实现不同。对于NAT来说，就是实现SNAT和DNAT规则的转换。</li></ul><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1652454138657.png" alt="enter description here"></p><blockquote><p>这里的每个节点都使用的是池化的ECS，具有很强的弹性扩缩能力。</p></blockquote><ul><li>TOP节点成为了无状态的网关，可以理论无限扩容，大大提高了整个网关平台的转发能力</li><li>Flow Master对于所有网关形态来说，不同的五元组都可以交由不同的Flow Master管理链接状态。FLow Master可以做到横向扩容，基于五元组hash，没有会话状态可以向Decider申请。</li><li>Decider不同与Flow Master，对于有状态的网关，不同的实例可以由不同的Decider管理，但同一个实例必须由同一个Decider管理。Decider横向扩容需要考虑hash策略变化带来的会话同步问题。</li><li>Flow Master和Decider存有会话信息，通过绕行两个节点形成主备，消除单点故障问题。</li></ul><h2 id="5-3-Tenant-Isolation"><a href="#5-3-Tenant-Isolation" class="headerlink" title="5.3 Tenant Isolation"></a>5.3 Tenant Isolation</h2><p>这个就比较简单，云上数据包一般都会使用VXLAN协议进行过传递，通过对VXLAN报文中的VNI进行解析，将SNAT规则和DNAT规则与VNI进行绑定，即可实现不同租户之间的规则隔离。</p><h1 id="6-NAT-Traversal"><a href="#6-NAT-Traversal" class="headerlink" title="6. NAT Traversal"></a>6. NAT Traversal</h1><p>目前运营商提供的光猫上网服务和绝大多数的路由器都是锥型NAT，锥型NAT可以实现NAT穿越，从而实现P2P。</p><h2 id="6-1-锥型NAT"><a href="#6-1-锥型NAT" class="headerlink" title="6.1 锥型NAT"></a>6.1 锥型NAT</h2><p>处于不同内网的主机A和主机B，各自先连接服务器，从而在各自NAT设备上打开了一个“孔”，服务器收到主机A和主机B的连接后，知道A与B的公网地址和NAT分配给它们的端口号，然后把这些NAT地址与端口号告诉A与B，由于在锥型NAT的特点，A和B给服务器所打开的“孔”，能给别的任何的主机使用。故A与B可连接对方的公网地址和端口直接进行通信。服务器在这里充当“介绍人”，告诉A与B对方的地址和端口号。</p><h2 id="6-2-地址受限锥型NAT"><a href="#6-2-地址受限锥型NAT" class="headerlink" title="6.2 地址受限锥型NAT"></a>6.2 地址受限锥型NAT</h2><p>A和B还是要先连接服务器，服务器发送A和B的地址和端口信息给A和B，但由于受限制锥形NAT的特点，他们所打开的“孔”，只能与服务器通信。要使他们可以直接通信，解决办法如下：</p><p>假如主机A开始发送一个UDP信息到主机B的公网地址上，与此同时，它又通过服务器中转发送了一个邀请信息给主机B，请求主机B也给主机A发送一个UDP信息到主机A的公网地址上。这时主机A向主机B的公网IP发送的信息导致NAT A打开一个处于主机A的和主机B之间的会话，与此同时，NAT B也打开了一个处于主机B和主机A的会话。一旦这个新的UDP会话各自向对方打开了，主机A和主机B之间就可以直接通信了。</p><h2 id="6-3-端口受限锥型（-Port-Restricted-Cone）NAT"><a href="#6-3-端口受限锥型（-Port-Restricted-Cone）NAT" class="headerlink" title="6.3 端口受限锥型（ Port Restricted Cone）NAT"></a>6.3 端口受限锥型（ Port Restricted Cone）NAT</h2><p>同<a href="#地址受限锥形NAT">地址受限锥形NAT</a></p><h2 id="6-4-对称型（Symmetric）NAT"><a href="#6-4-对称型（Symmetric）NAT" class="headerlink" title="6.4 对称型（Symmetric）NAT"></a>6.4 对称型（Symmetric）NAT</h2><p>对称型NAT，对于不同的四元组，它都会分配不同的端口号，所以进行打孔比较困难，但也可以进行端口预测打孔，不过不能保证成功。通常，对称NAT分配端口有两种策略，一种是按顺序增加，一种是随机分配。如果这里对称NAT使用顺序增加策略，那么，ClientB将两次被分配的外网地址和端口发送给Server后，Server就可以通知ClientA在这个端口范围内猜测刚才ClientB发送给它的socket中被NAT映射后的外网地址和端口，ClientA很有可能在孔有效期内成功猜测到端口号，从而和ClientB成功通信。</p><p>此外对称型NAT可以使用第三方服务器作为中继者，ClientA和ClientB之间的流量都通过中继服务器C中转，但是中继服务器容易成为性能瓶颈。</p><blockquote><ol><li><p>以上的NAT穿透，都是对PNAT来进行穿透，主要是针对UDP协议，语音视频通信是用UDP传输的。Basic NAT不修改经过的数据包的端口号，它们可以看作是完全锥形NAT的精简版本，即Basic NAT也可以被穿透。NAT设备将在一定时间后关闭UDP的一个映射，所以为了保持与服务器能够一直通信，服务器或客户端必须要周期性地发送UDP包，保持映射不被关闭。</p></li><li><p>以上的NAT穿越，都是基于UDP的NAT穿越。UDP的socket允许多个socket绑定到同一个本地端口，而TCP的socket则不允许。想象一下，如果Client A使用IPA:2000端口和服务器通信，那么Client主机已经使用IPA:2000这个socket和服务器建立了一条TCP流，自然也无法再使用IPA:2000端口和client B建立一条TCP流，而UDP是可以做到的。</p></li></ol></blockquote><h2 id="6-5-NAT-DDNS穿透"><a href="#6-5-NAT-DDNS穿透" class="headerlink" title="6.5 NAT-DDNS穿透"></a>6.5 NAT-DDNS穿透</h2><p>NAT-DDNS是将用户的动态IP地址映射到一个固定的域名上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务项目器程序负责提供DNS服务并实现动态域名解析。DDNS的主要作用就是捕获用户每次变化的IP地址，然后将其与域名相对应，这样其他上网用户就可以通过域名来与用户交流了。可以通过NAT-DDNS穿透来实现家用主机面向互联网提供服务。</p><h2 id="6-6-TCP打洞"><a href="#6-6-TCP打洞" class="headerlink" title="6.6 TCP打洞"></a>6.6 TCP打洞</h2><h3 id="6-6-1-套接字和TCP端口的重用"><a href="#6-6-1-套接字和TCP端口的重用" class="headerlink" title="6.6.1 套接字和TCP端口的重用"></a>6.6.1 套接字和TCP端口的重用</h3><p>实现基于TCP协议的p2p”打洞”过程中，最主要的问题不是来自于TCP协议，而是来自于来自于应用程序的API接口。这是由于标准的伯克利(Berkeley)套接字的API是围绕着构建客户端/服务器程序而设计的，API允许TCP流套接字通过调用<code>connect()</code>函数来建立向外的连接，或者通过<code>listen()</code>和<code>accept()</code>函数接受来自外部的连接，但是，API不提供类似UDP那样的，同一个端口既可以向外连接，又能够接受来自外部的连接。而且更糟的是，TCP的套接字通常仅允许建立1对1的响应，即应用程序在将一个套接字绑定到本地的一个端口以后，任何试图将第二个套接字绑定到该端口的操作都会失败。</p><p>为了让TCP”打洞”能够顺利工作，我们需要使用一个本地的TCP端口来监听来自外部的TCP连接，同时建立多个向外的TCP连接。幸运的是，所有的主流操作系统都能够支持特殊的TCP套接字参数，通常叫做<code>SO_REUSEADDR</code>，该参数允许应用程序将多个套接字绑定到本地的一个端口（只要所有要绑定的套接字都设置了SO_REUSEADDR参数即可）。BSD系统引入了SO_REUSEPORT参数，该参数用于区分端口重用还是地址重用，在这样的系统里面，上述所有的参数必须都设置才行。</p><h3 id="6-6-2-打开p2p的TCP流"><a href="#6-6-2-打开p2p的TCP流" class="headerlink" title="6.6.2 打开p2p的TCP流"></a>6.6.2 打开p2p的TCP流</h3><p>假定客户端A希望建立与B的TCP连接。我们像通常一样假定A和B已经与公网上的已知服务器、建立了TCP连接。服务器记录下来每个连入的客户端的公网地址和端口，如同为UDP服务的时候一样。从协议层来看，TCP”打洞”与UDP”打洞”是几乎完全相同的过程。</p><p>1、客户端A使用其与服务器的连接向服务器发送请求，要求服务器协助其连接客户端B。<br>2、服务器将B的公网IP和端口返回给A，同时，服务器将A的公网地址和端口发送给B。<br>3、客户端A和B使用连接服务器的端口异步地发起向对方的公网地址和端口的TCP连接，同时监听各自的本地TCP端口是否有外部的连接。<br>4、A和B开始等待向外的连接是否成功，检查是否有新连接进入。如果向外的连接由于某种网络错误而失败，如：”连接被重置”或者”节点无法访问”，客户端只需要延迟一小段时间（例如延迟一秒钟），然后重新发起连接即可，延迟的时间和重复连接的次数可以由应用程序编写者来确定。A发出SYN报文到达B的NAT设备，B的NAT设备如果是全锥型NAT，则连接直接建立，否则B的NAT设备丢弃该报，此时B的SYN报文到达A端NAT设备，而A端NAT设备由于看到了A主动访问B的流，因此将SYN报文NAT后转给了A，A的<code>listen()</code>函数生效，连接建立成功。<br>6、TCP连接建立起来以后，客户端之间应该开始鉴权操作，确保目前联入的连接就是所希望的连接。如果鉴权失败，客户端将关闭连接，并且继续等待新的连接接入。客户端通常采用”先入为主”的策略，只接受第一个通过鉴权操作的客户端，然后将进入p2p通信过程不再继续等待是否有新的连接接入。</p><h1 id="7-Other-Tech"><a href="#7-Other-Tech" class="headerlink" title="7. Other Tech"></a>7. Other Tech</h1><h2 id="7-1-会话结构"><a href="#7-1-会话结构" class="headerlink" title="7.1 会话结构"></a>7.1 会话结构</h2><p>首先定义几个概念：</p><ul><li>CIP，内网主机的IP</li><li>Cport，内网主机的port</li><li>DIP，外网主机的IP</li><li>Dport，外网主机的port</li><li>TIP，NAT后的IP</li><li><p>Tport，NAT后的port</p><h3 id="7-1-1-完全锥型NAT"><a href="#7-1-1-完全锥型NAT" class="headerlink" title="7.1.1 完全锥型NAT"></a>7.1.1 完全锥型NAT</h3></li><li><p>Up Key，内部四元组（CIP、Cport、Protocol）</p></li><li>Down Key，外部四元组（TIP、Tport、Protocol）</li><li>Session，Up key + Down key + Start Time + ExpireTime</li></ul><p>上行，内网主机访问外网只要CIP、Cport不变，一定会映射到TIP、Tport；下行，外网主机访问TIP、Tport总能NAT会内网的CIp和Cport；在Key中添加protocol可以实现TCP和UDP单独管理，也可以不使用Protocol作为key字段来统一管理。</p><h3 id="7-1-2-地址受限型NAT"><a href="#7-1-2-地址受限型NAT" class="headerlink" title="7.1.2 地址受限型NAT"></a>7.1.2 地址受限型NAT</h3><ul><li>Up Key，内部四元组（CIP、Cport、Protocol）</li><li>Down Key，外部四元组（TIP、Tport、DIP、Protocol）</li><li>Session，Up key + Down key + Start Time + ExpireTime</li></ul><p>上行，内网主机访问外网只要CIP、Cport不变，一定会映射到TIP、Tport；下行，外网主机以DIP为源地址，端口任意访问TIP、Tport可以NAT回内网的CIp和Cport，换个DIP则不行</p><h3 id="7-1-3-端口受限型NAT"><a href="#7-1-3-端口受限型NAT" class="headerlink" title="7.1.3 端口受限型NAT"></a>7.1.3 端口受限型NAT</h3><ul><li>Up Key，内部四元组（CIP、Cport、Protocol）</li><li>Down Key，外部四元组（TIP、Tport、DIP、DPORT、Protocol）</li><li>Session，Up key + Down key + Start Time + ExpireTime</li></ul><p>上行，内网主机访问外网只要CIP、Cport不变，一定会映射到TIP、Tport；下行，外网主机以DIP为源地址、DPort访问TIP、Tport可以NAT回内网的CIp和Cport，换个DIP或DPORT都不行。</p><h3 id="7-1-4-对称型NAT"><a href="#7-1-4-对称型NAT" class="headerlink" title="7.1.4 对称型NAT"></a>7.1.4 对称型NAT</h3><ul><li>Up Key，内部四元组（CIP、Cport、DIP、Dport、Protocol）</li><li>Down Key，外部四元组（TIP、Tport、DIP、Dport、Protocol）</li><li>Session，Up key + Down key + Start Time + ExpireTime</li></ul><p>上行，内网主机访问外网主机，只有(CIP、Cport、DIP、Dport)任意一个发生变化都会产生新会话，即分配新的TIP或TPORT；下行，外网主机只能以固定的DIP和Dport访问固定的TIP、Tport。</p><h2 id="7-2-会话分配"><a href="#7-2-会话分配" class="headerlink" title="7.2 会话分配"></a>7.2 会话分配</h2><p>这里假设TIP只有一个，实际可以配置多个，通过hash的方式随机选择一个TIP就行了，因此以下我们只讨论在一个TIP的情况下保证会话分配不冲突。</p><h3 id="7-2-1-锥型NAT"><a href="#7-2-1-锥型NAT" class="headerlink" title="7.2.1 锥型NAT"></a>7.2.1 锥型NAT</h3><p>仅需要管理TIP对应的PORT即可，TIP + PORT会固定映射为某个CIP + CPORT的逻辑。因此数据结构可以设置为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_port_key</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> tip;</span><br><span class="line"><span class="keyword">uint32_t</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> *<span class="title">nat_port_table</span>;</span> <span class="comment">// nat_port_key 映射到 nat_port_warehouse</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_port_warehouse</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> allocated_port_bmp; <span class="comment">// 使用bitmap记录占用状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-对称型NAT"><a href="#7-2-2-对称型NAT" class="headerlink" title="7.2.2 对称型NAT"></a>7.2.2 对称型NAT</h3><p>对于内网主机来说，NAT后的地址和端口并不感知，而对于外网主机来说是感知的，因此对称型NAT需要保证（TIP,Tport,DIP,Dport,Protocl）不一致即可，这五元组只有任意一个不一致，就会对应不同的DOWN Key，自然也能找到对应的Session来找到UP Key，保证可以NAT回去。所以我们只需要基于DOWN Key进行管理会话即可，其中TIP我们可以作为固定值，也就是我们要基于(DIP,Dport,Protocol)来分配Tport。可设计如下数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_port_key</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tip;</span><br><span class="line"><span class="keyword">uint32_t</span> dip;</span><br><span class="line"><span class="keyword">uint32_t</span> dport;</span><br><span class="line"><span class="keyword">uint32_t</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> *<span class="title">nat_port_table</span>;</span><span class="comment">//port_key 映射到 nat_port_warehouse</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_port_warehouse</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> port_allocated_state_bmp; <span class="comment">// 使用bitmap记录占用状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此方案存在一个缺陷，因为Tport的端口被复用了。假设以下场景，DIP1和DIP2都是提供代理的VIP，他们有同一个后端(SIP,SPORT)。由于DIP1和DIP2不同，因此有可能分配到相同Tport，此时对于后端server来说就会很迷惑，因为它看到了两条不一样的（TIP,TPORT,SIP,SPORT）流，后端服务的协议栈处理的数据流必然也是乱套的，流量就会不同。</p></blockquote><h1 id="8-Refrence"><a href="#8-Refrence" class="headerlink" title="8. Refrence"></a>8. Refrence</h1><ol><li><a href="https://arthurchiao.art/blog/conntrack-design-and-implementation-zh/" target="_blank" rel="noopener">连接跟踪（conntrack）：原理、应用及 Linux 内核实现</a></li><li><a href="https://cloud.tencent.com/developer/article/1198333" target="_blank" rel="noopener">一文看懂DPDK</a></li><li><a href="https://zhuanlan.zhihu.com/p/397919872" target="_blank" rel="noopener">什么是DPDK？DPDK的原理及学习学习路线总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/188735635" target="_blank" rel="noopener">AWS Hyperplane浅谈</a></li><li><a href="http://arthurchiao.art/blog/nat-zh/" target="_blank" rel="noopener">NAT - 网络地址转换</a></li><li><a href="http://www.h3c.com/cn/d_201206/747033_97665_0.htm" target="_blank" rel="noopener">NAT ALG原理与应用</a></li><li><a href="https://juejin.cn/post/6844904098572009485" target="_blank" rel="noopener">NAT基本原理及穿透详解(打洞)</a></li><li><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/network-address-translation-nat/13772-12.html" target="_blank" rel="noopener">配置网络地址转换：入门指南</a></li><li><a href="https://www.cisco.com/c/en/us/support/docs/ip/network-address-translation-nat/13778-9.html" target="_blank" rel="noopener">Configuring Static and Dynamic NAT Simultaneously</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-What-is-NAT&quot;&gt;&lt;a href=&quot;#1-What-is-NAT&quot; class=&quot;headerlink&quot; title=&quot;1. What is NAT?&quot;&gt;&lt;/a&gt;1. What is NAT?&lt;/h1&gt;&lt;h2 id=&quot;1-1-NAT-Level-4&quot;&gt;&lt;a href=&quot;#1-1-NAT-Level-4&quot; class=&quot;headerlink&quot; title=&quot;1.1 NAT(Level 4)&quot;&gt;&lt;/a&gt;1.1 NAT(Level 4)&lt;/h2&gt;&lt;p&gt;NAT（Network address translation）即网络地址转换，工作在OSI模型的三层或四层（PNAT），用于修改IP数据包中的IP地址和端口。当在专用网内部的一些主机本来已经分配到了local ip地址，但又想和Internet的主机通信时，可使用NAT方法。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://shinerio.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NAT" scheme="https://shinerio.cc/tags/NAT/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="https://shinerio.cc/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://shinerio.cc/2022/05/01/计算机网络/负载均衡/</id>
    <published>2022-05-01T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个简单的demo项目来说，我们可以用一个单体架构完成，而实际的线上应用普遍面临着高并发、高流量问题。作为一个上线的项目，对服务的可靠性还是有很高要求的，因此会选择使用一组服务器作为集群来提供服务，以此来保证单节点的处理性能以及保证服务的高可靠。如何将请求分担到不同的后端节点上，这就是负载均衡做的事情。</p><a id="more"></a><h2 id="1-四层负载均衡和七层负载均衡"><a href="#1-四层负载均衡和七层负载均衡" class="headerlink" title="1. 四层负载均衡和七层负载均衡"></a>1. 四层负载均衡和七层负载均衡</h2><p>四层负载均衡工作在OSI模型的传输层，主要工作就是流量转发，它在接口到客户端的流量以后通过修改数据包地址信息的方式将流量转发到应用服务器。七层负载均衡工作在OSI模型的应用层，因此需要解析应用层的流量，所以七层负载均衡在接收到客户端的流量以后需要经过一个完成的TPC/IP协议栈。七层负载均衡与客户端建立一条完成的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送出去，因此七层负载均衡的本质就是反向代理。七层负载均衡在四层负载均衡的基础上，再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据IP+PORT，还可根据七层的URL、浏览器类别、语言、Cookie来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。目前主流的负载均衡主要是基于nginx，haproxy和lvs实现，其中nginx和haproxy主要用于七层负载均衡，lvs主要用于四层lvs。</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategoryload+balance.png" alt></p><blockquote><p>四层的本质是转发，七层的本质是代理。</p></blockquote><p>由于七层负载均衡经过的协议栈链路更长，解析内容更多，且需要分别和client和server建立独立的两条tcp连接，因此通常情况下七层负载均衡的性能是要<strong>稍</strong>弱于四层负载均衡的，而七层应用负载均衡的好处，是使得整个网络更“智能化”。一个常见的场景就是API网关，其就是通过七层的方式实现的，可以将不同的url转发到不同的后端服务器组上，作为内部多个微服务组件的统一外部访问入口。且正是由于API网关工作在七层，API网关能承担起鉴权、过滤、流控和防SYN攻击的能力。API网关在可以对用户的请求header进行重写或响应response添加字段等。云服务时代，网络常见的鉴权方式有TOKEN、AK/SK等，API网关可以对API进行统一鉴权，在鉴权通过后统一转化为TOKEN放入到请求header中，对内部服务屏蔽细节，减少内部服务的适配难度。API网关还可以对请求body提进行过滤，防止命令注入和sql注入等。另外一个常常被提到功能就是安全性，网络中最常见的SYN Flood攻击，即使用虚假IP地址对同一目标发送SYN攻击。通常这种攻击会大量发送SYN报文，快速耗尽服务器的连接资源，以达到Denial of Service(DoS) 的目的。从技术原理上也可以看出，四层模式下这些 SYN 攻击都会被转发到后端的服务器上，而七层负载均衡由于client和负载均衡器无法建立完整的tcp连接，自然也不会对后端发起请求，不会影响后端服务器的正常运行。现在的七层负载均衡，主要还是着重于应用广泛的 HTTP 协议，所以其应用范围主要是众多的网站或者内部信息平台等基于 B/S 开发的系统，4 层负载均衡则对应其他 TCP 应用，例如基于 C/S 开发的 ERP 等系统。</p><h2 id="2-七层负载均衡"><a href="#2-七层负载均衡" class="headerlink" title="2. 七层负载均衡"></a>2. 七层负载均衡</h2><h3 id="2-1-nginx"><a href="#2-1-nginx" class="headerlink" title="2.1 nginx"></a>2.1 nginx</h3><p>Nginx是开源的轻量级Web服务器、反向代理服务器，以及负载均衡器和 HTTP 缓存器。其特点是高并发，高性能和低内存。</p><h3 id="2-2-haproxy"><a href="#2-2-haproxy" class="headerlink" title="2.2 haproxy"></a>2.2 haproxy</h3><p>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p><h2 id="3-四层负载均衡lvs"><a href="#3-四层负载均衡lvs" class="headerlink" title="3. 四层负载均衡lvs"></a>3. 四层负载均衡lvs</h2><p>四层负载均衡存在以下几个概念：</p><ul><li>DS：Director Server。指的是负载均衡器节点</li><li>RS：Real Server。后端真实的工作服务器</li><li>VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址</li><li>DIP：Director Server IP，主要用于负载均衡器节点和内部主机通讯的IP地址</li><li>RIP：Real Server IP，后端服务器的IP地址</li><li>CIP：Client IP，访问客户端的IP地址</li></ul><p>lvs四层转发，存在以下四种转发模式：DR模式、NAT模式、TUNNEL模式、FULLNAT模式。</p><div class="table-container"><table><thead><tr><th>模式</th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>DR</td><td>通过修改数据包目的mac地址的方式经过二层转发到达应用服务器，真实后端服务器可以不经过负载均衡器直接以源ip是vip，目的ip是cip的方式应答给应用服务器</td><td>由于返程流量不需要经过DS，因此性能较好</td><td>1. DS和RS需要在同一个二层网络中<br>2. RS需要配置vip地址，且关闭vip的arp应答</td></tr><tr><td>NAT</td><td>通过修改该数据包目的ip地址的方式经过三层转发到达应用服务器</td><td>因为NAT后的目的ip是RIP，所以不需要在应用服务器上配置VIP了</td><td>1. 由于目的ip被修改了，所以应用服务器如果直接响应给客户端的话，其源ip是RIP，而客户端看到的是VIP，客户端就不会正常接收这个应答，因此需要将回程流量回到负载均衡器，修改源IP为VIP后再回到客户端。由于来回流量都会经过DS，因此DS很容易成为性能瓶颈，此种模式下性能比DR模式差。<br>2. 为了流量能够回到负载均衡器的前提就是负载均衡器需要以网关的形式存在网络中，让默认路由指向负载均衡器。</td></tr><tr><td>tunnel</td><td>采用NAT模式时，由于请求和响应报文都必须经过DS，为了解决这个问题，DS可以把请求报文通过IP隧道转发到真实服务器，真实服务器解IP隧道封装，将响应直接返回给客户端。</td><td>由于DS只处理入方向报文，而一般服务应答数据要比请求数据大得多，采用TUN模式后，集群吞吐量一般可以 提高10倍。</td><td>1. 需要RS支持隧道技术</td></tr><tr><td>FULLNAT</td><td>为了解决NAT模式下，负载均衡器必须以网关形式存在，可以在做目的地址替换的前提下，在做一次源地址替换，这样回程流量就可以正常走路由到达DS</td><td>对网络要求比较低，负载均衡可以对RS完全透明，DS和RS之间走正常的三层路由，对组网无要求。</td><td>1. 由于做了两次NAT，所以性能要稍弱于NAT模式<br>2. 由于做了SNAT，因此RS丢失了CIP的信息<br>3. 由于做了SNAT，因为DS需要维护会话状态</td></tr></tbody></table></div><h2 id="5-硬件负载均衡"><a href="#5-硬件负载均衡" class="headerlink" title="5. 硬件负载均衡"></a>5. 硬件负载均衡</h2><p>典型的硬件负载均衡服务器有F5服务器，主流互联网公司目前都倾向于用软件负载均衡替代硬件负载均衡，主要是其主要存在以下问题</p><ul><li>硬件成本：中低端硬件负载均衡价格在数十万，高端的上百万，价格非常昂贵。当我们需要组成一个高可用集群时，需要数台机器，成本异常高。</li><li>人力成本：硬件负载均衡功能比较强大，配置比较灵活，这也导致在维护上，我们需要一些经过专业培训的人员，就增加了人力成本。</li><li>时间成本：当使用的过程中遇到bug或者新需求需要厂商提供新版本的时候，我们需要经过繁琐的流程向厂商上报，然后厂商再发布新版本供我们升级，时间周期非常长，在高速发展的互联网行业，这种周期是无法接受的。</li></ul><h2 id="6-负载均衡算法"><a href="#6-负载均衡算法" class="headerlink" title="6. 负载均衡算法"></a>6. 负载均衡算法</h2><ol><li><p>轮询调度<br>轮询调度（Round Robin 简称’RR’）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。</p></li><li><p>加权轮询调度<br>加权轮询（Weight Round Robin 简称’WRR’）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。</p></li><li><p>最小连接调度<br>最小连接调度（Least Connections 简称’LC’）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。</p></li><li><p>加权最小连接调度<br>加权最少连接（Weight Least Connections 简称’WLC’）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p></li><li><p>基于局部的最少连接<br>基于局部的最少连接调度（Locality-Based Least Connections 简称’LBLC’）算法是针对请求报文的目标IP地址的负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用’最少连接’的原则选出一个可用的服务器，将请求发送到服务器。</p></li><li><p>带复制的基于局部性的最少连接<br>带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称’LBLCR’）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按’最小连接’原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按’最小连接’原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p></li><li><p>目标地址散列调度<br>目标地址散列调度（Destination Hashing 简称’DH’）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</p></li><li><p>源地址散列调度U<br>源地址散列调度（Source Hashing  简称’SH’）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。</p></li><li><p>最短的期望的延迟<br>最短的期望的延迟调度（Shortest Expected Delay 简称’SED’）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算</p></li></ol><p>A：（1+1）/1=2   B：（1+2）/2=3/2   C：（1+3）/3=4/3   就把请求交给得出运算结果最小的服务器。</p><ol><li>最少队列调度<br>最少队列调度（Never Queue 简称’NQ’）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</li></ol><h2 id="7-DNS-ECMP-LVS-NGINX的高可靠、高性能方案"><a href="#7-DNS-ECMP-LVS-NGINX的高可靠、高性能方案" class="headerlink" title="7. DNS + ECMP + LVS + NGINX的高可靠、高性能方案"></a>7. DNS + ECMP + LVS + NGINX的高可靠、高性能方案</h2><p>在真实生产环境中， 有时候一种负载均衡器并不能完全解决问题，我们可以用多种组合方式来实现高可靠和高性能。</p><ol><li>通过DNS解析器，将来自不同区域的请求解析到不同的IDC机房，如将背景客户解析到北京机房，将上海客户解析到上海机房，以此来实现基于DNS的负载均衡和流量路径优化。</li><li>一台lvs机器在面临高并发的情况下存在性能瓶颈且有单点故障风险，因此可以利用OSPF + ECMP，通过五元组hash将请求调度到不同的lvs节点。同时为了解决由于lvs节点上下线以及交换机hash策略变化带来的流量路径改变问题，需要在不同的lvs节点之间进行会话同步。</li><li>在web应用场景下，由于nginx在api网关场景下的出色表现，我们可以考虑在lvs后面在加一层nginx作为反向代理服务器，同时充当部分负载均衡的能力。</li></ol><h2 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8. 参考链接"></a>8. 参考链接</h2><ol><li><a href="https://tech.meituan.com/2017/01/05/mgw.html" target="_blank" rel="noopener">MGW——美团点评高性能四层负载均衡</a></li><li><a href="https://cloud.tencent.com/developer/article/1082047" target="_blank" rel="noopener">四层、七层负载均衡的区别</a></li><li><a href="https://www.cnblogs.com/jing99/p/14616653.html" target="_blank" rel="noopener">Nginx学习之Nginx高性能的实现原理</a></li><li><a href="https://segmentfault.com/a/1190000020299695" target="_blank" rel="noopener">【均衡负载之LVS 系列四】 - OSPF(ECMP)-LVS 集群</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个简单的demo项目来说，我们可以用一个单体架构完成，而实际的线上应用普遍面临着高并发、高流量问题。作为一个上线的项目，对服务的可靠性还是有很高要求的，因此会选择使用一组服务器作为集群来提供服务，以此来保证单节点的处理性能以及保证服务的高可靠。如何将请求分担到不同的后端节点上，这就是负载均衡做的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://shinerio.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ELB" scheme="https://shinerio.cc/tags/ELB/"/>
    
      <category term="负载均衡" scheme="https://shinerio.cc/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于Micrometer和Prometheus实现度量和监控的方案</title>
    <link href="https://shinerio.cc/2022/01/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E4%BA%8EMicrometer%E5%92%8CPrometheus%E5%AE%9E%E7%8E%B0%E5%BA%A6%E9%87%8F%E5%92%8C%E7%9B%91%E6%8E%A7%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>https://shinerio.cc/2022/01/16/系统设计/基于Micrometer和Prometheus实现度量和监控的方案/</id>
    <published>2022-01-16T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序的监控是微服务中很重要的一环。监控主要包括四个方面的内容：指标（metrics）的统计、采集、存储、监控、展示和报警机制。</p><a id="more"></a><h2 id="1-指标统计"><a href="#1-指标统计" class="headerlink" title="1. 指标统计"></a>1. 指标统计</h2><p>指标的统计使用Mircometer(千分尺)，正如其官方文档所说的那样，Micrometer就是监控界的slf4j，致力于通过外观模式的方式打造一套数据采集的标准。</p><p>Micrometer provides a simple facade over the instrumentation clients for the most popular monitoring systems, allowing you to instrument your JVM-based application code without vendor lock-in. Think SLF4J, but for metrics.</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1642313496803.png" alt="enter description here"></p><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可。Micrometer 会负责完成与不同监控系统的适配工作。这就使得切换监控系统变得很容易。Micrometer 还支持推送数据到多个不同的监控系统。</p><h3 id="1-1-MeterRegistry"><a href="#1-1-MeterRegistry" class="headerlink" title="1.1 MeterRegistry"></a>1.1 MeterRegistry</h3><p>Meter是收集关于你的应用的一系列指标的接口。Meter是由MeterRegistry创建的，MeterRegistry是Meter的注册中心，每个支持的监控系统都必须实现MeterRegistry。 MeterRegistry在Micrometer是一个抽象类，主要实现包括：</p><ol><li><strong>SimpleMeterRegistry</strong>：每个Meter的最新数据可以收集到SimpleMeterRegistry实例中，但是这些数据不会发布到其他系统，也就是数据是位于应用的内存中的。如果你还没有一个首选的监测系统，你可以先用SimpleMeterRegistry。</li><li><strong>CompositeMeterRegistry</strong>：多个MeterRegistry聚合，内部维护了一个MeterRegistry的列表，允许同时向多个监视系统发布指标。</li><li><strong>全局的MeterRegistry</strong>：工厂类io.micrometer.core.instrument.Metrics中持有一个静态final的CompositeMeterRegistry实例globalRegistry。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 内存条中维护数据</span></span><br><span class="line">MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line"><span class="comment">// 2. CompositeMeterRegistry初始化的时候，内部持有的MeterRegistry列表是空的，如果此时用这个registry创建一个Meter实例，Meter实例的操作都是无效的</span></span><br><span class="line">CompositeMeterRegistry compositeMeterRegistry = <span class="keyword">new</span> CompositeMeterRegistry();</span><br><span class="line"><span class="comment">// 3. 通过Metrics提供的静态属性，可以获得一个全局的meterRegistry，其本质是一个CompositeMeterRegistry</span></span><br><span class="line">CompositeMeterRegistry globalRegistry = Metrics.globalRegistry;</span><br><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br></pre></td></tr></table></figure><h3 id="1-2-Tag"><a href="#1-2-Tag" class="headerlink" title="1.2 Tag"></a>1.2 Tag</h3><p>Tag（标签）是Micrometer的一个重要的功能，严格来说，一个度量框架只有实现了标签的功能，才能真正地多维度进行度量数据收集。Tag的命名一般需要是有意义的，所谓有意义就是可以根据Tag的命名可以推断出它指向的数据到底代表什么维度或者什么类型的度量指标。Meter由name和tag来唯一标识，在Micrometer中tag等价于dimension。具体举例来说比如监控一个Http Server的API请求数量，对于接口A的Meter可以定义为name=http.requests, tag=uri:/api/a,desc=api-a，对于接口B的Meter可以定义为name=http.requests, tag=uri:/api/b,desc=api-b，也就是说名称应该是对类别的描述而tag是针对某项具体统计的描述，这样便于数据分组，既可以统计某类的总体情况也可以对单个数据进行分析。假设我们需要监控不同用户的数据库调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">registry.counter(<span class="string">"database.calls"</span>, <span class="string">"user"</span>, <span class="string">"openstack"</span>);</span><br><span class="line">registry.counter(<span class="string">"database.calls"</span>, <span class="string">"user"</span>, <span class="string">"neutron"</span>);</span><br><span class="line">Search.in(registry).meters().forEach(each -&gt; &#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.append(<span class="string">"name:"</span>)</span><br><span class="line">            .append(each.getId().getName())</span><br><span class="line">            .append(<span class="string">",tags:"</span>)</span><br><span class="line">            .append(each.getId().getTags())</span><br><span class="line">            .append(<span class="string">",type:"</span>).append(each.getId().getType())</span><br><span class="line">            .append(<span class="string">",value:"</span>).append(each.measure());</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>name:database.calls,tags:[tag(user=neutron)],type:COUNTER,value:[Measurement{statistic=’COUNT’, value=0.0}]<br>name:database.calls,tags:[tag(user=openstack)],type:COUNTER,value:[Measurement{statistic=’COUNT’, value=0.0}]</p></blockquote><p>我们还可以定义全局的Tag，也就是全局的Tag定义之后，会附加到所有的使用到的Meter上(只要是使用同一个MeterRegistry)，全局的Tag可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">registry.config().commonTags(<span class="string">"Region"</span>, <span class="string">" us-east-1"</span>, <span class="string">"Service"</span>, <span class="string">"vpc"</span>);</span><br><span class="line">registry.config().commonTags(Arrays.asList(Tag.of(<span class="string">"Region"</span>, <span class="string">"us-east-1"</span>), Tag.of(<span class="string">"Service"</span>, <span class="string">"vpc"</span>)));</span><br><span class="line">registry.counter(<span class="string">"database.calls"</span>, <span class="string">"user"</span>, <span class="string">"neutron"</span>);</span><br><span class="line">Search.in(registry).meters().forEach(each -&gt; &#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.append(<span class="string">"name:"</span>)</span><br><span class="line">            .append(each.getId().getName())</span><br><span class="line">            .append(<span class="string">",tags:"</span>)</span><br><span class="line">            .append(each.getId().getTags())</span><br><span class="line">            .append(<span class="string">",type:"</span>).append(each.getId().getType())</span><br><span class="line">            .append(<span class="string">",value:"</span>).append(each.measure());</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>name:database.calls,tags:[tag(Region= us-east-1), tag(Service=vpc), tag(user=neutron)],type:COUNTER,value:[Measurement{statistic=’COUNT’, value=0.0}]</p></blockquote><h3 id="1-3-MeterFilter"><a href="#1-3-MeterFilter" class="headerlink" title="1.3 MeterFilter"></a>1.3 MeterFilter</h3><p>Registry可以通过MeterFilter功能提供过滤功能，可以实现基于标签或者名称进行统计，或者为Meter的名称添加白名单。MeterFilter本身提供一些列的静态方法，多个MeterFilter可以叠加或者组成链实现用户最终的过滤策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();</span><br><span class="line">    registry.config()</span><br><span class="line">            .meterFilter(MeterFilter.ignoreTags(<span class="string">"url"</span>))</span><br><span class="line">            .meterFilter(MeterFilter.denyNameStartsWith(<span class="string">"database"</span>));</span><br><span class="line">    registry.config().commonTags(<span class="string">"Region"</span>, <span class="string">" us-east-1"</span>, <span class="string">"Service"</span>, <span class="string">"vpc"</span>);</span><br><span class="line">    registry.config().commonTags(Arrays.asList(Tag.of(<span class="string">"Region"</span>, <span class="string">"us-east-1"</span>), Tag.of(<span class="string">"Service"</span>, <span class="string">"vpc"</span>)));</span><br><span class="line">    <span class="comment">// 以database开头的Meter被过滤掉</span></span><br><span class="line">    registry.counter(<span class="string">"database.calls"</span>, <span class="string">"user"</span>, <span class="string">"neutron"</span>);</span><br><span class="line">    <span class="comment">// 名为url的tag被忽略</span></span><br><span class="line">    registry.counter(<span class="string">"api.calls"</span>, <span class="string">"url"</span>, <span class="string">"/v1/heartbeat"</span>);</span><br><span class="line">    registry.counter(<span class="string">"api.calls"</span>, <span class="string">"service"</span>, <span class="string">"nova"</span>);</span><br><span class="line">    Search.in(registry).meters().forEach(each -&gt; &#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(<span class="string">"name:"</span>)</span><br><span class="line">                .append(each.getId().getName())</span><br><span class="line">                .append(<span class="string">",tags:"</span>)</span><br><span class="line">                .append(each.getId().getTags())</span><br><span class="line">                .append(<span class="string">",type:"</span>).append(each.getId().getType())</span><br><span class="line">                .append(<span class="string">",value:"</span>).append(each.measure());</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>name:api.calls,tags:[tag(Region= us-east-1), tag(Service=vpc), tag(service=nova)],type:COUNTER,value:[Measurement{statistic=’COUNT’, value=0.0}]<br>name:api.calls,tags:[tag(Region= us-east-1), tag(Service=vpc)],type:COUNTER,value:[Measurement{statistic=’COUNT’, value=0.0}]</p></blockquote><h3 id="1-4-Meters"><a href="#1-4-Meters" class="headerlink" title="1.4 Meters"></a>1.4 Meters</h3><h4 id="1-4-1-Counter"><a href="#1-4-1-Counter" class="headerlink" title="1.4.1 Counter"></a>1.4.1 Counter</h4><p>Counter是一种比较简单的Meter，它是一种单值的度量类型，或者说是一个单值计数器。Counter接口允许使用者使用一个固定值（必须为正数）进行计数。准确来说：Counter就是一个增量为正数的单值计数器。Counter的作用是记录总量，适用于一些增长类型的统计，例如下单、支付次数、HTTP请求总量记录等等。通过Tag可以区分不同的场景，对于下单，可以使用不同的Tag标记不同的平台来源，对于HTTP请求总量记录，可以使用Tag区分不同的URL。</p><ol><li>创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line"><span class="comment">// 1. registry创建</span></span><br><span class="line">Counter counter1 = registry.counter(<span class="string">"counter1"</span>, <span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line"><span class="comment">// 2. Counter静态方法</span></span><br><span class="line">Counter counter2 = Counter</span><br><span class="line">        .builder(<span class="string">"counter2"</span>)</span><br><span class="line">        .baseUnit(<span class="string">"beans"</span>) <span class="comment">// optional</span></span><br><span class="line">        .description(<span class="string">"a description of what this counter does"</span>) <span class="comment">// optional</span></span><br><span class="line">        .tags(<span class="string">"region"</span>, <span class="string">"us-east-1"</span>) <span class="comment">// optional</span></span><br><span class="line">        .register(registry);</span><br><span class="line"><span class="comment">// 3. Metrics静态方法</span></span><br><span class="line">Counter counter3 = Metrics.counter(<span class="string">"counter3"</span>, <span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. FunctionCounter，自定义计数器，提供一个计数对象以及把计数对象转换成double型计数值的方法</span></span><br><span class="line">AtomicInteger adder = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">FunctionCounter counter4 = FunctionCounter.builder(<span class="string">"functionCounter"</span>, adder, AtomicInteger::get)</span><br><span class="line">        .baseUnit(<span class="string">"function"</span>)</span><br><span class="line">        .description(<span class="string">"functionCounter"</span>)</span><br><span class="line">        .tag(<span class="string">"createOrder"</span>, <span class="string">"CHANNEL-A"</span>)</span><br><span class="line">        .register(registry);</span><br></pre></td></tr></table></figure><ol><li>计数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line"><span class="comment">// 1. registry创建</span></span><br><span class="line">Counter counter1 = registry.counter(<span class="string">"counter1"</span>, <span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line"><span class="comment">// 2. Counter静态方法</span></span><br><span class="line">Counter counter2 = Counter</span><br><span class="line">        .builder(<span class="string">"counter2"</span>)</span><br><span class="line">        .baseUnit(<span class="string">"beans"</span>) <span class="comment">// optional</span></span><br><span class="line">        .description(<span class="string">"a description of what this counter does"</span>) <span class="comment">// optional</span></span><br><span class="line">        .tags(<span class="string">"region"</span>, <span class="string">"us-east-1"</span>) <span class="comment">// optional</span></span><br><span class="line">        .register(registry);</span><br><span class="line"><span class="comment">// 3. Metrics静态方法</span></span><br><span class="line">Counter counter3 = Metrics.counter(<span class="string">"counter3"</span>, <span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. FunctionCounter，自定义计数器，提供一个计数对象以及把计数对象转换成double型计数值的方法</span></span><br><span class="line">AtomicInteger adder = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">FunctionCounter counter4 = FunctionCounter.builder(<span class="string">"functionCounter"</span>, adder, AtomicInteger::get)</span><br><span class="line">        .baseUnit(<span class="string">"function"</span>)</span><br><span class="line">        .description(<span class="string">"functionCounter"</span>)</span><br><span class="line">        .tag(<span class="string">"createOrder"</span>, <span class="string">"CHANNEL-A"</span>)</span><br><span class="line">        .register(registry);</span><br><span class="line"></span><br><span class="line">counter1.increment();</span><br><span class="line">counter2.increment();</span><br><span class="line">counter3.increment();</span><br><span class="line">adder.incrementAndGet();</span><br><span class="line">System.out.println(counter1.measure());</span><br><span class="line">System.out.println(counter2.measure());</span><br><span class="line">System.out.println(counter3.measure());</span><br><span class="line">System.out.println(counter4.measure());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[Measurement{statistic=’COUNT’, value=1.0}]<br>[Measurement{statistic=’COUNT’, value=1.0}]<br>[Measurement{statistic=’COUNT’, value=1.0}]<br>[Measurement{statistic=’COUNT’, value=1.0}]</p></blockquote><h4 id="1-4-2-Timer"><a href="#1-4-2-Timer" class="headerlink" title="1.4.2 Timer"></a>1.4.2 Timer</h4><p>Timer（计时器）适用于记录耗时比较短的事件的执行时间，通过时间分布展示事件的序列和发生频率。所有的Timer的实现至少记录了发生的事件的数量和这些事件的总耗时，从而生成一个时间序列。Timer在事件结束时记录数据，每条记录代表一个时间段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">       MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line">       Timer timer = Timer.builder(<span class="string">"api.call"</span>)</span><br><span class="line">               .tag(<span class="string">"vpc"</span>, <span class="string">"/v1/network"</span>)</span><br><span class="line">               .register(registry);</span><br><span class="line">       timer.record(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">       System.out.println(timer.record(() -&gt; createVpc()));</span><br><span class="line">       timer.record(() -&gt; deleteVpc());</span><br><span class="line">       System.out.println(wrapperCreateVpc(timer).call());</span><br><span class="line">       wrapperDeleteVpc(timer).run();</span><br><span class="line">       System.out.println(<span class="string">"Total record: "</span> + timer.count());</span><br><span class="line">       System.out.println(timer.measure());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;String&gt; <span class="title">wrapperCreateVpc</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">       Callable&lt;String&gt; createVpc = () -&gt; createVpc();</span><br><span class="line">       <span class="keyword">return</span> timer.wrap(createVpc);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">wrapperDeleteVpc</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">       Runnable deleteVpc = () -&gt; deleteVpc();</span><br><span class="line">       <span class="keyword">return</span> timer.wrap(deleteVpc);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteVpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createVpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"test-vpc"</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"None"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>test-vpc<br>test-vpc<br>Total record: 5<br>[Measurement{statistic=’COUNT’, value=5.0}, Measurement{statistic=’TOTAL_TIME’, value=6.1028661}, Measurement{statistic=’MAX’, value=2.000589}]</p></blockquote><p>另外，Timer的使用还可以基于它的内部类Timer.Sample，通过start和stop两个方法记录两者之间的逻辑的执行耗时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line">Timer timer = Timer.builder(<span class="string">"api.call"</span>)</span><br><span class="line">        .tag(<span class="string">"vpc"</span>, <span class="string">"/v1/network"</span>)</span><br><span class="line">        .register(registry);</span><br><span class="line">Timer.Sample sample = Timer.start(registry);</span><br><span class="line">deleteVpc();</span><br><span class="line">sample.stop(timer);</span><br><span class="line">System.out.println(timer.measure());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[Measurement{statistic=’COUNT’, value=1.0}, Measurement{statistic=’TOTAL_TIME’, value=1.0003523}, Measurement{statistic=’MAX’, value=1.0003523}]</p></blockquote><p>类似于FunctionCounter，FunctionTimer也提供了自定义计时的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyTimer myTimer = <span class="keyword">new</span> MyTimer();</span><br><span class="line"><span class="comment">// 第二参数为计时对象，第三个参数为计数方法，第四个参数为总时长计时方式</span></span><br><span class="line">FunctionTimer timer = FunctionTimer.builder(<span class="string">"functionTimer"</span>, myTimer, t -&gt; t.totalCount.get(),</span><br><span class="line">        t -&gt; t.totalTimeNanos.get(), TimeUnit.NANOSECONDS)</span><br><span class="line">        .register(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">myTimer.totalTimeNanos.addAndGet(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">myTimer.totalCount.incrementAndGet();</span><br><span class="line">System.out.println(timer.measure());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[Measurement{statistic=’COUNT’, value=1.0}, Measurement{statistic=’TOTAL_TIME’, value=1.0}]</p></blockquote><h4 id="1-4-3-Long-task-timers"><a href="#1-4-3-Long-task-timers" class="headerlink" title="1.4.3  Long task timers"></a>1.4.3  Long task timers</h4><p>LongTaskTimer是Timer的一种特殊类型，主要统计的是当前有多少正在执行的任务，以及这些这任务已经耗费了多少时间，适用于监控长时间执行的方法，统计类似当前负载量的相关指标。Long Task Timer在事件开始时记录，在事件结束后将事件移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">    MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line">    LongTaskTimer timer = registry.more().longTaskTimer(<span class="string">"longTime.task"</span>);</span><br><span class="line">    Schedulers.boundedElastic().schedule(() -&gt; timer.record(() -&gt; deleteVpc()));</span><br><span class="line">    Schedulers.boundedElastic().schedule(() -&gt; timer.record(() -&gt; createVpc()));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(timer.measure());</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">1500</span>);</span><br><span class="line">    System.out.println(timer.measure());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(timer.measure());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteVpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createVpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test-vpc"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"None"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[Measurement{statistic=’ACTIVE_TASKS’, value=2.0}, Measurement{statistic=’DURATION’, value=2.005069E9}]<br>[Measurement{statistic=’ACTIVE_TASKS’, value=1.0}, Measurement{statistic=’DURATION’, value=2.5038645E9}]<br>[Measurement{statistic=’ACTIVE_TASKS’, value=0.0}, Measurement{statistic=’DURATION’, value=0.0}]</p></blockquote><h4 id="1-4-4-Gauge"><a href="#1-4-4-Gauge" class="headerlink" title="1.4.4 Gauge"></a>1.4.4 Gauge</h4><p>gauge是获取当前值的句柄。典型的例子是，获取集合、map、或运行中的线程数等。MeterRegistry接口包含了用于构建gauges的方法，用于观察数字值、函数、集合和map。当指标不是递增的而是一个上下浮动的值时，你应该采用Gauge，同时Gauge也翻译为仪表盘，典型如汽车的速度仪。使用Gauge可以观察动态的数值，如数据库活跃连接数、api活跃线程数量、消息队列中消息数量等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line"><span class="comment">// 第三参数为监控对象，第四个参数没监控值</span></span><br><span class="line">List&lt;Thread&gt; list = registry.gauge(<span class="string">"jvm"</span>, Tags.of(<span class="string">"thread"</span>, <span class="string">"num"</span>), <span class="keyword">new</span> ArrayList&lt;&gt;(), List::size);</span><br><span class="line"><span class="comment">// 监控list大小</span></span><br><span class="line">List&lt;String&gt; list2 = registry.gaugeCollectionSize(<span class="string">"ListSize"</span>, Tags.empty(), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="comment">// 监控map大小</span></span><br><span class="line">Map&lt;String, Integer&gt; map = registry.gaugeMapSize(<span class="string">"mapSize"</span>, Tags.empty(), <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">list.add(<span class="keyword">new</span> Thread());</span><br><span class="line">list2.add(<span class="string">"aa"</span>);</span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">Search.in(registry).meters().forEach(each -&gt; &#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.append(<span class="string">"name:"</span>)</span><br><span class="line">            .append(each.getId().getName())</span><br><span class="line">            .append(<span class="string">",tags:"</span>)</span><br><span class="line">            .append(each.getId().getTags())</span><br><span class="line">            .append(<span class="string">",type:"</span>).append(each.getId().getType())</span><br><span class="line">            .append(<span class="string">",value:"</span>).append(each.measure());</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>name:mapSize,tags:[],type:GAUGE,value:[Measurement{statistic=’VALUE’, value=1.0}]<br>name:ListSize,tags:[],type:GAUGE,value:[Measurement{statistic=’VALUE’, value=1.0}]<br>name:jvm,tags:[tag(thread=num)],type:GAUGE,value:[Measurement{statistic=’VALUE’, value=1.0}]</p></blockquote><p>上面的三个方法通过MeterRegistry构建Gauge并且返回了List或者Map实例，使用这些集合或者映射实例就能在其size变化过程中记录这个变更值。更重要的优点是，我们不需要感知Gauge接口的存在，只需要像平时一样使用集合或者映射实例就可以了。我们还可以通过如下方法监控一个已有实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">MeterRegistry registry = Metrics.globalRegistry;</span><br><span class="line">List&lt;Thread&gt; listThread = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Gauge gauge = Gauge.builder(<span class="string">"jvm"</span>, listThread, List::size).register(registry);</span><br><span class="line">listThread.add(<span class="keyword">new</span> Thread());</span><br><span class="line">System.out.println(gauge.measure());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[Measurement{statistic=’VALUE’, value=1.0}]</p></blockquote><h4 id="1-4-5-DistributionSummary"><a href="#1-4-5-DistributionSummary" class="headerlink" title="1.4.5 DistributionSummary"></a>1.4.5 DistributionSummary</h4><p>分布概要（Distribution summary）用来记录事件的分布情况。分布概要根据每个事件所对应的值，把事件分配到对应的桶（bucket）中。Micrometer 默认的桶的值从 1 到最大的 long 值。可以通过minimumExpectedValue和maximumExpectedValue来控制值的范围。如果事件所对应的值较小，可以通过 scale 来设置一个值来对数值进行放大。与分布概要密切相关的是直方图和百分比（percentile）。大多数时候，我们并不关注具体的数值，而是数值的分布区间。比如在查看 HTTP 服务响应时间的性能指标时，通常关注是的几个重要的百分比，如 50%，75%和 90%等。所关注的是对于这些百分比数量的请求都在多少时间内完成。Micrometer 提供了两种不同的方式来处理百分比。</p><ul><li>对于Prometheus 这样本身提供了对百分比支持的监控系统，Micrometer 直接发送收集的直方图数据，由监控系统完成计算。</li><li>对于其他不支持百分比的系统，Micrometer 会进行计算，并把百分比结果发送到监控系统。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">DistributionSummary summary = DistributionSummary.builder(<span class="string">"api.call.time"</span>)</span><br><span class="line">        .description(<span class="string">"simple distribution summary"</span>)</span><br><span class="line">        .maximumExpectedValue(<span class="number">100.0</span>D)</span><br><span class="line">        .publishPercentiles(<span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1</span>)</span><br><span class="line">        .register(Metrics.globalRegistry);</span><br><span class="line">summary.record(<span class="number">30</span>);</span><br><span class="line">summary.record(<span class="number">51</span>);</span><br><span class="line">summary.record(<span class="number">74</span>);</span><br><span class="line">summary.record(<span class="number">90</span>);</span><br><span class="line">summary.record(<span class="number">97</span>);</span><br><span class="line">System.out.println(summary.takeSnapshot());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>HistogramSnapshot{count=5, total=342.0, mean=68.4, max=97.0, percentileValues=[(75.0 at 50.0%), (91.0 at 80.0%), (99.0 at 100.0%)]}</p></blockquote><h3 id="1-5-Histograms-and-percentiles（直方图和百分比）"><a href="#1-5-Histograms-and-percentiles（直方图和百分比）" class="headerlink" title="1.5 Histograms and percentiles（直方图和百分比）"></a>1.5 Histograms and percentiles（直方图和百分比）</h3><p>Timers 和 distribution summaries 支持收集数据来观察它们的百分比。查看百分比有两种主要方法：</p><ol><li><strong>Percentile histograms（百分比直方图）</strong>：  Micrometer将值累积到底层直方图，并将一组预先确定的buckets发送到监控系统。监控系统的查询语言负责从这个直方图中计算百分比。目前，只有Prometheus , Atlas , Wavefront支持基于直方图的百分位数近似值，并且通过histogram_quantile , :percentile , hs()依次表示。</li><li><strong>Client-side percentiles（客户端百分比）</strong>：Micrometer为每个meter ID（一组name和tag）计算百分位数近似值，并将百分位数值发送到监控系统。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Metrics.addRegistry(<span class="keyword">new</span> SimpleMeterRegistry());</span><br><span class="line">Timer timer = Timer.builder(<span class="string">"my.timer"</span>)</span><br><span class="line">        .publishPercentiles(<span class="number">0.5</span>, <span class="number">0.95</span>) <span class="comment">// median and 95th percentile</span></span><br><span class="line">        .publishPercentileHistogram()</span><br><span class="line">        .sla(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .minimumExpectedValue(Duration.ofMillis(<span class="number">1</span>))</span><br><span class="line">        .maximumExpectedValue(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">        .register(Metrics.globalRegistry);</span><br></pre></td></tr></table></figure><blockquote><p>publishPercentileHistogram: 用于发布直方图, 适用于计算聚合 (多维度) 百分位近似值，在prometheus中用histogram_quantile，在atlas 中用:percentile。直方图结果中的buckets，由micrometer预先生成，生成器默认会产生 276 个 buckets，且micrometer只会将那些范围在minimumExpectedValue和maximumExpectedValue之内的发送给监控系统。sla用于发布基于SLA定义的桶的累积直方图。与publishPercentileHistogram用法一致，在支持百分比聚合的监视系统中，此设置用于向已发布的直方图中添加额外的桶。对于不支持百分比聚合的系统上使用时，将仅使用这些桶发布直方图。</p></blockquote><h3 id="1-6-Cumulate-amp-Step"><a href="#1-6-Cumulate-amp-Step" class="headerlink" title="1.6 Cumulate &amp; Step"></a>1.6 Cumulate &amp; Step</h3><p>对于一个完整的监控体系来说，通常至少会有三个部分：应用程序、监控数据存储、监控数据表现，而某些框架或者工具会同时包含其中的多个或者多个工具共同组成一个部分，从而产生各种各样的组合。对于速率、平均值、事件分布、延迟等与时间窗口相关的监控指标（Rate aggregation）可以在不同的部分进行处理，例如对于某个接口请求速度的监控，可以在应用层计算好直接发送速度值；也可以直接发送请求数量到存储层然后由表现层来计算速度；又或者是由应用层存储累加值，由其他工具主动来抓取每个时刻的状态。</p><p>所以在应用层，有的Meter会有两种类型：累加（Accumulate）与滚动（Step）。以Counter为例，该基接口在core包提供的默认实现中包括：CumulativeCounter和StepCounter，源码并不复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CumulativeCounter</span> <span class="keyword">extends</span> <span class="title">AbstractMeter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DoubleAdder value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CumulativeCounter</span><span class="params">(Id id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> DoubleAdder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        value.add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> <span class="keyword">extends</span> <span class="title">AbstractMeter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StepDouble value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StepCounter</span><span class="params">(Id id, Clock clock, <span class="keyword">long</span> stepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> StepDouble(clock, stepMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        value.getCurrent().add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向监视系统报告间隔速率的计数器，count()方法将报告上一个完整周期的数值</span></span><br><span class="line"><span class="comment">// 而非整个生命周期的总数。可以查看StepDouble(StepValue)源码来查看滚动的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> <span class="keyword">extends</span> <span class="title">AbstractMeter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StepDouble value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StepCounter</span><span class="params">(Id id, Clock clock, <span class="keyword">long</span> stepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> StepDouble(clock, stepMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        value.getCurrent().add(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、-指标采集和监控"><a href="#2、-指标采集和监控" class="headerlink" title="2、 指标采集和监控"></a>2、 指标采集和监控</h2><p>指标采集介绍statsd和Prometheus两种方式。</p><h3 id="2-1-statsd"><a href="#2-1-statsd" class="headerlink" title="2.1 statsd"></a>2.1 statsd</h3><p>Statsd最早是2008年Flickr公司用Perl写的针对Graphite、datadog等监控数据后端存储开发的前端网络应用，2011 年 Etsy 公司用 node.js 重构。statsd狭义来讲，其实就是一个监听UDP（默认）或者TCP的守护程序，根据简单的协议收集statsd客户端发送来的数据，聚合之后，定时推送给后端，如graphite和influxdb等，再通过grafana等展示。statsd系统包括三部分：客户端（client）、服务器（server）和后端（backend）。客户端植入于应用代码中，将相应的metrics上报给statsd server。statsd server聚合这些metrics之后，定时发送给backends。backends则负责存储这些时间序列数据，并通过适当的图表工具展示。</p><p>statsd采用简单的行协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bucket&gt;:&lt;value&gt;|&lt;type&gt;[|@sample_rate]</span><br></pre></td></tr></table></figure></p><p>bucket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucket是一个metric的标识，可以看成一个metric的变量。</span><br></pre></td></tr></table></figure></p><p>value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric的值，通常是数字。</span><br></pre></td></tr></table></figure></p><p>type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metric的类型，通常有timer、counter、gauge和get</span><br></pre></td></tr></table></figure></p><p>sample_rate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果数据上报量过大，很容易溢满statsd。所以适当的降低采样，减少server负载。这个频率容易误解，需要解释一下。客户端减少数据上报的频率，然后在发送的数据中加入采样频率，如0.1。statsd server收到上报的数据之后，如cnt=10，得知此数据是采样的数据，然后flush的时候，按采样频率恢复数据来发送给backend，即flush的时候，数据为cnt=10/0.1=100，而不是容易误解的10*0.1=1。</span><br></pre></td></tr></table></figure></p><h4 id="2-1-1-UDP和TCP"><a href="#2-1-1-UDP和TCP" class="headerlink" title="2.1.1 UDP和TCP"></a>2.1.1 UDP和TCP</h4><p>statsd可配置相应的server为UDP和TCP。默认为UDP。UDP和TCP各有优劣。但UDP确实是不错的方式。UDP不需要建立连接，速度很快，不会影响应用程序的性能。“fire-and-forget”机制，就算statsd server挂了，也不会造成应用程序crash。当然，UDP更适合于上报频率比较高的场景，就算丢几个包也无所谓，对于一些一天已上报的场景，任何一个丢包都影响很大。另外，对于网络环境比较差的场景，也更适合用TCP，会有相应的重发，确保数据可靠。</p><h4 id="2-1-2-Metric"><a href="#2-1-2-Metric" class="headerlink" title="2.1.2 Metric"></a>2.1.2 Metric</h4><p>statsd 有四种指标类型：counter、timer、gauge和set。</p><ol><li><p>计数器 counter<br>counter类型的指标，用来计数。在一个flush区间，把上报的值累加。值可以是正数或者负数。<br>user.logins:10|c        // user.logins + 10<br>user.logins:-1|c        // user.logins - 1<br>user.logins:10|c|@0.1   // user.logins + 100</p><pre><code>                              // users.logins = 10-1+100=109</code></pre><ol><li>计时器 timer<br>timers用来记录一个操作的耗时，单位ms。statsd会记录平均值（mean）、最大值（upper）、最小值（lower）、累加值（sum）、平方和（sum_squares）、个数（count）以及部分百分值。 如下是在一个flush期间，发送了一个rpt的timer值100<br>rpt:100|g<br>以下是记录的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">count_80: 1,</span><br><span class="line">mean_80: 100,</span><br><span class="line">upper_80: 100,</span><br><span class="line">sum_80: 100,</span><br><span class="line">sum_squares_80: 10000,</span><br><span class="line">std: 0,</span><br><span class="line">upper: 100,</span><br><span class="line">lower: 100,</span><br><span class="line">count: 1,</span><br><span class="line">count_ps: 0.1,</span><br><span class="line">sum: 100,</span><br><span class="line">sum_squares: 10000,</span><br><span class="line">mean: 100,</span><br><span class="line">median: 100</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>对于百分数相关的数据需要解释一下。以90为例。statsd会把一个flush期间上报的数据，去掉10%的峰值，即按大小取cnt*90%（四舍五入）个值来计算百分值。举例说明，假如10s内上报以下10个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,3,5,7,13,9,11,2,4,8</span><br></pre></td></tr></table></figure></p><p>则只取10*90%=9个值，则去掉13。百分值即按剩下的9个值来计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$KEY.mean_90   // (1+3+5+7+9+2+11+4+8)/9</span><br><span class="line">$KEY.upper_90  // 11</span><br><span class="line">$KEY.lower_90  // 1复制代码</span><br></pre></td></tr></table></figure></p><ol><li><p>标量 gauge<br>gauge是任意的一维标量值。gague值不会像其它类型会在flush的时候清零，而是保持原有值。statsd只会将flush区间内最后一个值发到后端。另外，如果数值前加符号，会与前一个值累加。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age:10|g    // age 为 10</span><br><span class="line">age:+1|g    // age 为 10 + 1 = 11</span><br><span class="line">age:-1|g    // age为 11 - 1 = 10</span><br><span class="line">age:5|g     // age为5,替代前一个值复制代码</span><br></pre></td></tr></table></figure></li><li><p>sets<br>记录flush期间，不重复的值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request:1|s  // user 1</span><br><span class="line">request:2|s  // user1 user2</span><br><span class="line">request:1|s  // user1 user2</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-Prometheus"><a href="#2-2-Prometheus" class="headerlink" title="2.2 Prometheus"></a>2.2 Prometheus</h3><p>Prometheus是一个开源监控系统，它前身是SoundCloud的警告工具包。从2012年开始，许多公司和组织开始使用Prometheus。该项目的开发人员和用户社区非常活跃，越来越多的开发人员和用户参与到该项目中。目前它是一个独立的开源项目，且不依赖与任何公司。Prometheus 基于服务发现的模式，定时从应用程序实例上拉取指标数据，它支持自定义查询的语言以及数学操作。</p><h4 id="2-2-1-接入"><a href="#2-2-1-接入" class="headerlink" title="2.2.1 接入"></a>2.2.1 接入</h4><p>接入 Prometheus 时首先需要引入如下的 maven 依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;micrometer.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-创建"><a href="#2-2-2-创建" class="headerlink" title="2.2.2 创建"></a>2.2.2 创建</h4><p>创建Prometheus Registry，同时需要给Prometheus的scraper暴露一个 HTTP 端点用于数据拉取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PrometheusMeterRegistry prometheusRegistry = <span class="keyword">new</span> PrometheusMeterRegistry(PrometheusConfig.DEFAULT);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpServer server = HttpServer.create(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>), <span class="number">0</span>);</span><br><span class="line">    server.createContext(<span class="string">"/prometheus"</span>, httpExchange -&gt; &#123;</span><br><span class="line">        String response = prometheusRegistry.scrape(); (<span class="number">1</span>)</span><br><span class="line">        httpExchange.sendResponseHeaders(<span class="number">200</span>, response.getBytes().length);</span><br><span class="line">        <span class="keyword">try</span> (OutputStream os = httpExchange.getResponseBody()) &#123;</span><br><span class="line">            os.write(response.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> Thread(server::start).start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    Counter counter = prometheusRegistry.counter(<span class="string">"counter"</span>, <span class="string">"region"</span>, <span class="string">"us-east-1"</span>);</span><br><span class="line">    counter.increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问127.0.0.1:8080/prometheus可得到如下结果</p><blockquote><p># HELP counter_total<br># TYPE counter_total counter<br>Counter_total{region=”us-east-1”,} 1.0</p></blockquote><p>设置拉取的数据格式。默认情况下PrometheusMeterRegistry的scrape()方法返回的是 Prometheus 默认的文本格式。从 Micrometer 1.7.0 开始，也可以通过如下方式指定数据格式为OpenMetrics定义的数据格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String openMetricsScrape = registry.scrape(TextFormat.CONTENT_TYPE_OPENMETRICS_100);</span><br></pre></td></tr></table></figure></p><h4 id="2-2-3-安装"><a href="#2-2-3-安装" class="headerlink" title="2.2.3 安装"></a>2.2.3 安装</h4><p>从<a href="https://prometheus.io/download/获取安装压缩包，解压后编辑prometheus.xml配置文件。" target="_blank" rel="noopener">https://prometheus.io/download/获取安装压缩包，解压后编辑prometheus.xml配置文件。</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=<span class="tag">&lt;<span class="name">job_name</span>&gt;</span>` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: "prometheus"</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to '/metrics'</span><br><span class="line">    metrics_path: /prometheus</span><br><span class="line">    # scheme defaults to 'http'.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: ["localhost:8080"]</span><br></pre></td></tr></table></figure><p>运行后，访问<a href="http://localhost:9090/classic/graph可执行表达式，获取监控数据" target="_blank" rel="noopener">http://localhost:9090/classic/graph可执行表达式，获取监控数据</a></p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1642328537059.png" alt="enter description here"></p><p>prometheus只提供了简单查询界面，如果需要更直观的监控GUI，可以安装Grafana来对接prometheus</p><h2 id="3-集成"><a href="#3-集成" class="headerlink" title="3. 集成"></a>3. 集成</h2><p>集成了Micrometer框架的JVM应用使用到Micrometer的API收集的度量数据位于内存之中，因此，需要额外的存储系统去存储这些度量数据，需要有监控系统负责统一收集和处理这些数据，还需要有一些UI工具去展示数据。常见的存储系统就是时序数据库，主流的有Influx、Datadog等。比较主流的监控系统（主要是用于数据收集和处理）就是Prometheus（一般叫普罗米修斯，下面就这样叫吧）。而展示的UI目前相对用得比较多的就是Grafana。另外，Prometheus已经内置了一个时序数据库的实现，因此，在做一套相对完善的度量数据监控的系统只需要依赖目标JVM应用，Prometheus组件和Grafana组件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序的监控是微服务中很重要的一环。监控主要包括四个方面的内容：指标（metrics）的统计、采集、存储、监控、展示和报警机制。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://shinerio.cc/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="https://shinerio.cc/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Reactor编程（三）</title>
    <link href="https://shinerio.cc/2021/12/19/java/Reactor%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://shinerio.cc/2021/12/19/java/Reactor编程（三）/</id>
    <published>2021-12-19T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中，我们已经对reactor有了一个简单的认识，这篇我们将详细地介绍一些Reactor常见的operator。</p><a id="more"></a><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><p>buffer操作符的作用是把当前流中的元素收集到集合中，并把集合对象作为流中的新元素。在进行收集时可以指定不同的条件：所包含的元素的最大数量或收集的时间间隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buffer 20个，输出5 个包含 20 个元素的数组</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).buffer(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// buffer1秒，输出2个包括10个元素的数组</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).buffer(Duration.ofMillis(<span class="number">1001</span>)).take(<span class="number">2</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// buffer 10个，500毫秒超时</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).bufferTimeout(<span class="number">10</span>, Duration.ofMillis(<span class="number">500</span>)).take(<span class="number">2</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// bufferUntil 会一直收集直到 Predicate 返回为 true。使得 Predicate 返回 true 的那个元素可以选择添加到当前集合或下一个集合中；</span></span><br><span class="line"><span class="comment">// 输出的是 5 个包含 2 个元素的数组</span></span><br><span class="line"><span class="comment">// 每当遇到一个偶数就会结束当前的收集</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferUntil(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// bufferWhile 则只有当 Predicate 返回 true 时才会收集。一旦值为 false，会立即开始下一次收集。</span></span><br><span class="line"><span class="comment">// 输出的是 5 个包含 1 个元素的数组</span></span><br><span class="line"><span class="comment">// 数组里面包含的只有偶数</span></span><br><span class="line"> Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferWhile(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>// 第四行语句输出的是 5 个包含 1 个元素的数组</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter操作符对流中的元素进行过滤，只留下满足 Predicate 指定条件的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码的输出的是 1 到 10 中的所有偶数。</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window操作符把流中的元素收集到另外的Flux 序列中。window操作符的作用类似于buffer，所不同的是window操作符是把当前流中的元素收集到另外的Flux序列中，因此返回值类型是 Flux<flux>。</flux></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Flux.range(<span class="number">1</span>, <span class="number">100</span>).window(<span class="number">20</span>).subscribe(item -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"buffer handle start"</span>);</span><br><span class="line">    item.subscribe(System.out::println);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).window(Duration.ofMillis(<span class="number">1001</span>)).take(<span class="number">2</span>).subscribe(item -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"buffer handle begin"</span>);</span><br><span class="line">item.subscribe(System.out::println);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce和reduceWith操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的Mono序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出5050</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).reduce(Integer::sum).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//下面的示例代码中也是同样的相加操作，不过通过Supplier给出了初始值 100，所以结果为 5050 + 100 = 5150；</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).reduceWith(() -&gt; <span class="number">100</span>, Integer::sum).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h2><p>zipWith 操作符把当前流中的元素与另外一个流中的元素按照一对一的方式进行合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并时可以不做任何处理，由此得到的是一个元素类型为 Tuple2 的流；</span></span><br><span class="line">Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; tupleResults = Flux.range(<span class="number">1</span>, <span class="number">100</span>).zipWith(Flux.range(<span class="number">101</span>, <span class="number">100</span>));</span><br><span class="line">tupleResults.subscribe(t -&gt; System.out.println(t.getT1() + t.getT2()));</span><br><span class="line"><span class="comment">//zipWith 操作符也可以通过一个 BiFunction 函数对合并的元素进行处理，所得到的流的元素类型为该函数的返回值</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).zipWith(Flux.range(<span class="number">101</span>, <span class="number">100</span>), Integer::sum).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><p>take系列操作符用来从当前流中提取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取前10个，输出的是数字 1 到 10</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>).take(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// 取最后10个，输出的是数字 991 到 1000</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>).takeLast(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//提取元素直到 Predicate 返回 true（Predicate 返回 true 的元素也是包含在内的），输出的是数字 1 到 10</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>).takeUntil(i -&gt; i == <span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//当 Predicate 返回 true 时才进行提取，输出的是数字 1 到 9</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>).takeWhile(i -&gt; i &lt; <span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">//提取元素直到另外一个流开始产生元素，输出的数字0到9</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).takeUntilOther(Flux.interval(Duration.ofMillis(<span class="number">1001</span>))).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>merge和mergeSequential操作符用来把多个流合并成一个Flux序列。不同之处在于 ：</p><ul><li>merge按照所有流中元素的实际产生顺序来合并</li><li>mergeSequential则按照所有流被订阅的顺序，以流为单位进行合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出00 11 22 33 44</span></span><br><span class="line">Flux.merge(Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">5</span>), Flux.interval(Duration.ofMillis(<span class="number">50</span>), Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">5</span>))</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"><span class="comment">// 输出0 1 2 3 4 0 1 2 3 4</span></span><br><span class="line">Flux.mergeSequential(Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">5</span>), Flux.interval(Duration.ofMillis(<span class="number">50</span>), Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">5</span>))</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map操作用来将序列转换成另一个类型的序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int类型转换成String类型</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).map(v -&gt; <span class="string">"value is "</span> + v).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>flatMap和flatMapSequential操作符把流中的每个元素转换成一个流，再把所有流中的元素进行合并。flatMapSequential和flatMap之间的区别与 mergeSequential 和 merge 之间的区别是一样的：</p><ul><li>flatMap 按照所有流中元素的实际产生顺序来合并。</li><li>flatMapSequential 则按照所有流被订阅的顺序，以流为单位进行合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出0 1 0 2 1 2</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">2</span>).flatMap(v -&gt; Flux.interval(Duration.ofMillis(<span class="number">100L</span> * v)).take(<span class="number">3</span>)).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 输出0 1 2 0 1 2</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">2</span>).flatMapSequential(v -&gt; Flux.interval(Duration.ofMillis(<span class="number">100L</span> * v)).take(<span class="number">3</span>)).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h2><p>concatMap操作符的作用也是把流中的每个元素转换成一个流，再把所有流进行合并。与flatMap不同的是，concatMap会根据原始流中的元素顺序依次把转换之后的流进行合并；与flatMapSequential不同的是，concatMap对转换之后的流的订阅是动态进行的，而flatMapSequential在合并之前就已经订阅了所有的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出0 1 2 0 1 2</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">2</span>).concatMap(v -&gt; Flux.interval(Duration.ofMillis(<span class="number">100L</span> * v)).take(<span class="number">3</span>)).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h2><p>combineLatest操作符把所有流中的最新产生的元素合并成一个新的元素，作为返回结果流中的元素。只要其中任何一个流中产生了新的元素，合并操作就会被执行一次，结果流中就会产生新的元素。</p><p>Flux.combineLatest(<br>        Arrays::toString,<br>        Flux.intervalMillis(100).take(5),<br>        Flux.intervalMillis(50, 100).take(5)<br>).toStream().forEach(System.out::println);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0  1 2</span></span><br><span class="line"><span class="comment">// 0    1   2</span></span><br><span class="line"><span class="comment">// 0 1 23   4</span></span><br><span class="line"><span class="comment">//输出0,1,2,3,4</span></span><br><span class="line">Flux.combineLatest(Flux.interval(Duration.ofMillis(<span class="number">100L</span>)).take(<span class="number">3</span>), Flux.interval(Duration.ofMillis(<span class="number">10L</span>), Duration.ofMillis(<span class="number">200L</span>)).take(<span class="number">3</span>), (v1, v2) -&gt; v1 + v2)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="concatWith"><a href="#concatWith" class="headerlink" title="concatWith"></a>concatWith</h2><p>将另一个流连接到当前流后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出0 1 2 0 1 2</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">3</span>).concatWith(Flux.interval(Duration.ofMillis(<span class="number">100</span>)).take(<span class="number">3</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h2><p>当出现错误时，可以通过 retry 操作符来进行重试。重试的动作是通过重新订阅序列来实现的。在使用 retry 操作符时可以指定重试的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的代码指定了重试次数为 1，所输出的结果是 0 1 2 0 1 2和exception</span></span><br><span class="line">Flux.range(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">.concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">.retry(<span class="number">1</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>log操作符将流相关的事件记录在日志中。下面的代码添加了 log 操作符并指定了日志分类的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">2</span>).log(<span class="string">"Range Seq"</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>22:16:12.950 [main] INFO Range Seq - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)<br>22:16:12.952 [main] INFO Range Seq - | request(unbounded)<br>22:16:12.952 [main] INFO Range Seq - | onNext(1)<br>1<br>22:16:12.953 [main] INFO Range Seq - | onNext(2)<br>2<br>22:16:12.953 [main] INFO Range Seq - | onComplete()</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中，我们已经对reactor有了一个简单的认识，这篇我们将详细地介绍一些Reactor常见的operator。&lt;/p&gt;
    
    </summary>
    
      <category term="异步编程" scheme="https://shinerio.cc/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://shinerio.cc/tags/java/"/>
    
      <category term="异步编程" scheme="https://shinerio.cc/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="reactor" scheme="https://shinerio.cc/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>Reactor编程（二）</title>
    <link href="https://shinerio.cc/2021/12/18/java/Reactor%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://shinerio.cc/2021/12/18/java/Reactor编程（二）/</id>
    <published>2021-12-18T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>Java 提供了两种异步编程模型：</p><ul><li><strong>回调</strong>：异步方法没有返回值，但需要一个额外的 callback参数（一个 lambda 或匿名类），当结果可用时会被调用。</li><li><strong>Futures</strong>：异步方法立即返回一个Future<t>。异步过程计算一个T值，但Future对象包装了对它的访问。该值不会立即可用，并且可以轮询该对象直到该值可用。例如，一个ExecutorService正在运行的Callable<t>任务使用Future对象。</t></t></li></ul><p>两种方式各有优劣，回调代码很难组合在一起，很快导致代码难以阅读和维护。Future比回调稍微好点，通过CompleteFuture，我们将多个Future对象编排 在一起。但Future也有一些缺点，它不支持惰性计算，没有背压能力，缺乏对多个值和高级错误处理的支持。</p><a id="more"></a><h2 id="1-CompleteFuture"><a href="#1-CompleteFuture" class="headerlink" title="1. CompleteFuture"></a>1. CompleteFuture</h2><p>在学习Reactor之前，我们先尝试使用CompleteFuture实现一段功能，稍后我们会使用Reactor就行重构，以此来体现Reactor代码编程的优美。 </p><p>我们根据用户订单获取到一个bookId的list，然后需要找出每个bookId对应的书名和作者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CompletableFuture&lt;List&lt;Integer&gt;&gt; ids = CompletableFuture.supplyAsync(() -&gt; Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">ids.thenComposeAsync(idList -&gt; &#123;</span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; nameAuthorPair = idList.stream().map(</span><br><span class="line">id -&gt; &#123;</span><br><span class="line">CompletableFuture&lt;String&gt; name = CompletableFuture.supplyAsync(() -&gt; books.get(id).getName());</span><br><span class="line">CompletableFuture&lt;String&gt; author = CompletableFuture.supplyAsync(() -&gt; books.get(id).getAuthor());</span><br><span class="line"><span class="keyword">return</span> name.thenCombineAsync(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line">).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.allOf(</span><br><span class="line">nameAuthorPair.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]))</span><br><span class="line">.thenApply(v -&gt; nameAuthorPair.stream().map(CompletableFuture::join).collect(Collectors.toList()));</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; v.forEach(System.out::println));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for compute</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="2-Reactor"><a href="#2-Reactor" class="headerlink" title="2. Reactor"></a>2. Reactor</h2><p>反应式库，例如 Reactor，旨在解决 JVM 上“经典”异步方法的这些缺点，同时还关注一些其他方面：</p><ul><li>可组合性和可读性</li><li>使用一系列丰富的运算符来流式处理数据</li><li>惰性计算，在subscribe之前，不会进行任何计算</li><li>背压能力，消费者向生产者发出生产速率过高的信号的能力</li><li>与并发无关的，具有高价值的高阶抽象</li></ul><h3 id="2-1-组合型和可读性"><a href="#2-1-组合型和可读性" class="headerlink" title="2.1 组合型和可读性"></a>2.1 组合型和可读性</h3><p>“可组合性”是指编排多个异步任务的能力，我们使用先前任务的结果作为后续任务的输入。或者，我们可以以 fork-join 方式运行多个任务。此外，我们可以在更高级别的系统中将异步任务重用为离散组件。</p><p>编排任务的能力与代码的可读性和可维护性紧密相关。随着异步进程层数和复杂性的增加，编写和读取代码变得越来越困难。正如我们所见，回调模型很简单，但它的主要缺点之一是，对于复杂的流程，您需要从回调中执行回调，回调本身嵌套在另一个回调中，依此类推。这种混乱被称为“回调地狱”。您可以猜到（或从经验中知道），这样的代码很难回溯和推理。</p><p>Reactor 提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且所有内容通常都保持在同一级别（最小化嵌套）。</p><h3 id="2-2-流失处理"><a href="#2-2-流失处理" class="headerlink" title="2.2 流失处理"></a>2.2 流失处理</h3><p>您可以将反应式应用程序处理的数据想象成一个商品在一个流水线上处理。Reactor即是传送带又是工作站。原材料从一个来源（原始Publisher）倾倒并最终成为准备推向消费者（或Subscriber）的成品。</p><p>原材料可以经过各种转换和其他中间步骤，或者成为将中间件聚合在一起的更大装配线的一部分。如果某一点出现故障或堵塞（可能装箱产品花费的时间过长），受影响的工作站可以向上游发出信号以限制原材料的流动。</p><h3 id="2-3-operator"><a href="#2-3-operator" class="headerlink" title="2.3 operator"></a>2.3 operator</h3><p>在Reactor中，operator可以类比为流水线上的工作站。每个operator代表了Publisher的一种行为，用来将上一步的Publisher输出包装到一个新实例中。整个链条因此被链接起来，使得数据从第一个Publisher开始并沿着链条向下移动，由每个节点转换。最终，最后一个Subscriber完成了该过程。并且在 Subscriber订阅Publisher之前什么也不会发生。</p><p>Reactor等响应式库最有价值的一点就是它们提供的丰富的operate能力，涵盖从简单的转换和过滤到复杂的编排和错误处理等多方面。</p><h3 id="2-4-惰性计算"><a href="#2-4-惰性计算" class="headerlink" title="2.4 惰性计算"></a>2.4 惰性计算</h3><p>在 Reactor 中，当您编写Publisher链时，默认情况下数据不会开始注入其中。因此，可以基于此创建异步流程的抽象描述（这有助于可重用性和组合）。</p><p>通过订阅行为，将绑定Publisher到Subscriber，这会触发整个链中的数据流。内部实现原理是，通过一个subscriber的一个request信号触发，并逐级传播到上游，以至于最终的源publisher</p><h3 id="2-5-背压（Backpressure）"><a href="#2-5-背压（Backpressure）" class="headerlink" title="2.5 背压（Backpressure）"></a>2.5 背压（Backpressure）</h3><p>像上游传播的信号也可以用来实现背压，我们可以类比在生产流水线中，某个生产节点处理比上游的节点慢时，可以向上游反馈信号。</p><p>Reactive Streams规范定义的真正机制与类比非常接近。订阅者可以在无界模式下工作，让源以最快的速度推送所有数据，也可以通过request机制向源发送信号，表示他最多可以处理n个元素。整个流中，中间的operator还可以改变这个request，比如可以通过buffer将元素以10个一组进行分组。一些中间的节点还可以有自己的缓存机制，如果下游从上游拉元素，如果有缓存，则可以直接push，否则会向上游请求。</p><h3 id="2-6-hot-vs-cold"><a href="#2-6-hot-vs-cold" class="headerlink" title="2.6 hot vs cold"></a>2.6 hot vs cold</h3><p>Rx系列响应式库区主要分为两类响应序列：hot和cold。这种区别主要与响应流如何对订阅者做出响应有关：</p><ul><li><strong>cold</strong>：一个冷序列对每个Subscriber提供从头开始的完整的元数据。例如，如果源包装了一个HTTP调用，那么每一个订阅都是一个新的HTTP请求。</li><li><strong>hot</strong>：一个热序列不对每个subscriber提供完整的数据。相反，迟到的订阅者会收到订阅后发出的消息。但是可能存在一些热响应流可以全部或部分缓存或重放消息历史。从一般的角度来看，当没有订阅者正在监听时，热序列甚至可以推出消息（这是“订阅前什么都不会发生”规则的一个例外）。</li></ul><h3 id="2-7-reactor-core"><a href="#2-7-reactor-core" class="headerlink" title="2.7 reactor-core"></a>2.7 reactor-core</h3><p>Reactor工程的主要artifact是<code>reactor-core</code>，一个Java 8下面，专注于响应式流lib。可以通过如下方式引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Reactor引入了可组合的反应类型，其实现Publisher接口，同时也提供了丰富的operator：Flux和Mono。一个Flux对象表示一个包含0..N个对象的序列，而一个Mono对象表示一个单值或空 (0..1) 结果。</p><p>这两种有类型本身携带了一些语义信息，可以对其自身代表的数据容量有个大致预估。比如一个HTTP请求只产生一个响应，所以做一个Flux操作没有多大意义。因此，将此类 HTTP 调用的结果表示为Mono<httpresponse>比将其表示为Flux<httpresponse>更有意义，因为它仅提供与零项或一项的上下文相关的operator。</httpresponse></httpresponse></p><p>有时候，流式处理过程中operator也会有切换。例如，count运算符存在于中Flux，但它返回一个 Mono<long>。</long></p><h4 id="2-7-1-Flux-0-N-项的异步序列"><a href="#2-7-1-Flux-0-N-项的异步序列" class="headerlink" title="2.7.1 Flux, 0-N 项的异步序列"></a>2.7.1 Flux, 0-N 项的异步序列</h4><p>下图是Flux的一个典型工作流：</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639834040985.png" alt="enter description here"></p><p>Flux<t>是一个标准Publisher<t>，表示 0 到 N 个异步消息序列，可以由完成信号或错误信号终止。如图所示，有三种信号可以分别触发下游订阅者的onNext，onComplete和onError方法。</t></t></p><p>重要的是所有事件，包括终止事件，都是可选的。没有onNext事件，但是有onComplete事件代表一个空的有限序列。但是移除onComplete，代表一个无限的空序列（不是特别有用，除了围绕取消的测试）。同样，无限序列也不一定是空的。例如，Flux.interval(Duration) 产生一个时钟触发的规律的无限序列Flux<long></long></p><h4 id="2-7-2-Mono-0-1异步结果"><a href="#2-7-2-Mono-0-1异步结果" class="headerlink" title="2.7.2 Mono, 0-1异步结果"></a>2.7.2 Mono, 0-1异步结果</h4><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639834718028.png" alt="enter description here"></p><p>Mono<t>是一种特殊的Publisher<t>，它通过onNext信号产生最多一个事件，随着一个onComplete信号（成功Mono，有或没有值）而终止，或者只发出一个onError信号（失败Mono）。</t></t></p><p>大多数Mono实现预计会在调用onNext成功后立即调用onComplete。Mono.never()是一个异常值：它不发出任何信号，这在技术上并没有被禁止，尽管其在测试之外并不是非常有用。另一方面，onNext和onError的组合是明确禁止的。</p><p>Mono仅提供Flux可用的operator的子集，并且一些operator会转换结果为Flux。比如, Mono#concatWith(Publisher)返回一个Flux，而Mono#then(Mono) 返回另一个Mono。</p><p>我们可以使用Mono来表示只有完成概念的无值异步进程（类似于 a Runnable），可以使用一个空的 Mono<void>实现。</void></p><h4 id="2-7-3-工厂方法"><a href="#2-7-3-工厂方法" class="headerlink" title="2.7.3 工厂方法"></a>2.7.3 工厂方法</h4><p>最简单的创建Flux或Mono的是使用一系列工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; empty = Mono.empty();</span><br><span class="line">Mono&lt;String&gt; name = Mono.just(<span class="string">"jack"</span>);</span><br><span class="line">Mono&lt;String&gt; monoResult = Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; <span class="string">"result"</span>));</span><br><span class="line">Mono&lt;Void&gt; monoFromRunnable = Mono.fromRunnable(() -&gt; System.out.println(<span class="string">"do nothing"</span>));</span><br><span class="line">Mono&lt;String&gt; monoFromOtherMono = Mono.from(monoResult);</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; nums = Flux.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">Flux&lt;String&gt; colors = Flux.just(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>);</span><br><span class="line">Flux&lt;String&gt; colorFromArray = Flux.fromArray(<span class="keyword">new</span> String[]&#123;<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>&#125;);</span><br><span class="line">Flux&lt;String&gt; colorFromList = Flux.fromIterable(Arrays.asList(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>));</span><br><span class="line">Flux&lt;String&gt; colorFromStream = Flux.fromStream(Stream.of(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>));</span><br><span class="line">Flux&lt;String&gt; colorFromOtherFlux = Flux.from(colors);</span><br></pre></td></tr></table></figure><h4 id="2-7-4-subscribe"><a href="#2-7-4-subscribe" class="headerlink" title="2.7.4 subscribe"></a>2.7.4 subscribe</h4><p>Flux和Mono使用java8的lambda表达式来提供订阅的能力，这些方法使用不同形式组合的回调函数作为参数。这些方法的返回值都是Disposable类型，可以用来取消订阅以及停止source的数据产生和清理已经创建的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅并触发流</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理流中的每一个数据</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理六中每一个数据，同时也有处理异常的能力</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer)</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理六中每一个数据，也有处理异常的能力，也可以在流完成的时候运行一些代码</span></span><br><span class="line"><span class="function">Disposable  <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,  Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,  Runnable completeConsumer)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">.map(i -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= <span class="number">3</span>) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Got to 4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ints.subscribe(System.out::println,</span><br><span class="line">error -&gt; System.err.println(<span class="string">"Error: "</span> + error));</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1<br>2<br>3<br>Error: java.lang.RuntimeException: Got to 4</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(System.out::println, error -&gt; System.err.println(<span class="string">"Error: "</span> + error),</span><br><span class="line">() -&gt; System.out.println(<span class="string">"Done"</span>));</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1<br>2<br>3<br>4<br>Done</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can control backpressure here</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1<br>2<br>3<br>4<br>Done</p></blockquote><h4 id="2-7-5-Disposable"><a href="#2-7-5-Disposable" class="headerlink" title="2.7.5 Disposable"></a>2.7.5 Disposable</h4><p>通过调用Disposable的 dispose()方法我们可以取消订阅。对于Flux或者Mono，取消信号意味者源应该停止生产数据，但是这种行为并不保证立即生效。有些源数据可能数据产生的非常快，以至于在收到取消信号之前已经完成数据生产。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">Disposable disposable = ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can control backpressure here</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">disposable.dispose();</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1<br>2<br>3<br>4<br>Done</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Long&gt; ints = Flux.interval(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">Disposable disposable = ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Long&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can control backpressure here</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">subscription.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">disposable.dispose();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>0<br>1</p></blockquote><h4 id="2-7-6-自定义序列器"><a href="#2-7-6-自定义序列器" class="headerlink" title="2.7.6 自定义序列器"></a>2.7.6 自定义序列器</h4><h5 id="2-7-6-1-同步生成"><a href="#2-7-6-1-同步生成" class="headerlink" title="2.7.6.1 同步生成"></a>2.7.6.1 同步生成</h5><p>在有些情况下，序列的生成可能是有状态的，需要用到某些状态对象。此时可以使用<code>generate(Callable&lt;S&gt; stateSupplier, BiFunction&lt;S,SynchronousSink&lt;T&gt;,S&gt; generator)</code>，其中 stateSupplier 用来提供初始的状态对象。在进行序列生成时，状态对象会作为 generator 使用的第一个参数传入，可以在对应的逻辑中对该状态对象进行修改以供下一次生成时使用。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639899001379.png" alt="enter description here"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">() -&gt; <span class="number">0</span>,</span><br><span class="line"><span class="comment">// 生产序列元素，返回下一个状态</span></span><br><span class="line">(state, sink) -&gt; &#123;</span><br><span class="line">sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span> * state);</span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">10</span>) sink.complete();</span><br><span class="line"><span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>3 x 0 = 0<br>3 x 1 = 3<br>3 x 2 = 6<br>3 x 3 = 9<br>3 x 4 = 12<br>3 x 5 = 15<br>3 x 6 = 18<br>3 x 7 = 21<br>3 x 8 = 24<br>3 x 9 = 27<br>3 x 10 = 30</p></blockquote><h5 id="2-7-6-2-异步多线程生成"><a href="#2-7-6-2-异步多线程生成" class="headerlink" title="2.7.6.2 异步多线程生成"></a>2.7.6.2 异步多线程生成</h5><p>create()方法与 generate()方法的不同之处在于所使用的是FluxSink对象。FluxSink声明了next, error和complete方法。支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。create另一特性就是很容易把其他的接口与响应式桥接起来。注意，它是异步多线程并不意味着create可以并行化你写的代码或者异步执行，create方法里面的Lambda表达式代码还是单线程阻塞的。如果你在创建序列的地方阻塞了代码，那么可能造成订阅者即使请求了数据，也得不到，因为序列被阻塞了，没法生成新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span></span>;</span><br><span class="line"><span class="function">MyEventListener&lt;T&gt; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">MyEventProcessor&lt;String&gt; myEventProcessor = <span class="keyword">new</span> MyEventProcessor&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyEventListener&lt;String&gt; myEventListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.myEventListener = stringTestListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyEventListener&lt;String&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.myEventListener;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">myEventProcessor.register(</span><br><span class="line"><span class="keyword">new</span> MyEventListener&lt;&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">sink.next(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sink.complete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bridge.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">list.add(i+<span class="string">"-run1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEventProcessor.get().onDataChunk(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">list.add(i+<span class="string">"-run2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEventProcessor.get().onDataChunk(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">list.add(i+<span class="string">"-run3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEventProcessor.get().onDataChunk(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">myEventProcessor.get().processComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-run1</span><br><span class="line"><span class="number">0</span>-run2</span><br><span class="line"><span class="number">0</span>-run3</span><br><span class="line"><span class="number">1</span>-run2</span><br><span class="line"><span class="number">1</span>-run3</span><br><span class="line"><span class="number">2</span>-run2</span><br><span class="line"><span class="number">2</span>-run3</span><br><span class="line"><span class="number">3</span>-run2</span><br><span class="line"><span class="number">3</span>-run3</span><br><span class="line"><span class="number">4</span>-run2</span><br><span class="line"><span class="number">4</span>-run3</span><br><span class="line"><span class="number">5</span>-run2</span><br><span class="line"><span class="number">5</span>-run3</span><br><span class="line"><span class="number">6</span>-run2</span><br><span class="line"><span class="number">6</span>-run3</span><br><span class="line"><span class="number">7</span>-run2</span><br><span class="line"><span class="number">7</span>-run3</span><br><span class="line"><span class="number">8</span>-run2</span><br><span class="line"><span class="number">8</span>-run3</span><br><span class="line"><span class="number">9</span>-run2</span><br><span class="line"><span class="number">9</span>-run3</span><br><span class="line"><span class="number">1</span>-run1</span><br><span class="line"><span class="number">2</span>-run1</span><br><span class="line"><span class="number">3</span>-run1</span><br><span class="line"><span class="number">4</span>-run1</span><br><span class="line"><span class="number">5</span>-run1</span><br><span class="line"><span class="number">6</span>-run1</span><br><span class="line"><span class="number">7</span>-run1</span><br><span class="line"><span class="number">8</span>-run1</span><br><span class="line"><span class="number">9</span>-run1</span><br></pre></td></tr></table></figure></p><p>上述代码通过多个线程持有MyEventListener对象，并发地执行onDataTrunk方法，通过sink.next()产生消息。</p><h5 id="2-7-6-3-异步单线程生成"><a href="#2-7-6-3-异步单线程生成" class="headerlink" title="2.7.6.3 异步单线程生成"></a>2.7.6.3 异步单线程生成</h5><p>reate允许多线程环境下调用.next()方法，只管生成元素，元素的顺序不可控。但是push只允许一个线程生产元素，所以是有序的，至于异步指的是在新的线程中也可以，而不必非得在当前线程。顺带一提，push和create都支持onCancel()和onDispose()操作。一般来说，onCancel只响应于cancel操作，而onDispose响应于error，cancel，complete等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span></span>;</span><br><span class="line"><span class="function">MyEventListener&lt;T&gt; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">MyEventProcessor&lt;String&gt; myEventProcessor = <span class="keyword">new</span> MyEventProcessor&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyEventListener&lt;String&gt; myEventListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.myEventListener = stringTestListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyEventListener&lt;String&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.myEventListener;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; &#123;</span><br><span class="line">myEventProcessor.register(</span><br><span class="line"><span class="keyword">new</span> MyEventListener&lt;&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">sink.next(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sink.complete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bridge.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">list.add(i+<span class="string">"-run1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">myEventProcessor.get().onDataChunk(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">myEventProcessor.get().processComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>0-run1<br>1-run1<br>2-run1<br>3-run1<br>4-run1<br>5-run1<br>6-run1<br>7-run1<br>8-run1<br>9-run1</p></blockquote><h4 id="2-7-7-filter和map"><a href="#2-7-7-filter和map" class="headerlink" title="2.7.7 filter和map"></a>2.7.7 filter和map</h4><p>filter和map方法是实例方法，一般链接在一个已经存在的源上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10</span>).filter(i -&gt; i &gt; <span class="number">3</span>).map(i -&gt; <span class="string">"value is "</span> + i).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>value is 4<br>value is 5<br>value is 6<br>value is 7<br>value is 8<br>value is 9</p></blockquote><h4 id="2-7-8-handle"><a href="#2-7-8-handle" class="headerlink" title="2.7.8 handle"></a>2.7.8 handle</h4><p>handle方法是一个实例方法，一般链接在一个已经存在的源上。handle和generate类似，只能同步地诸葛处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10</span>).handle((v, sink) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (v &gt; <span class="number">3</span>) &#123;</span><br><span class="line">sink.next(<span class="string">"value is "</span> + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>value is 4<br>value is 5<br>value is 6<br>value is 7<br>value is 8<br>value is 9</p></blockquote><h4 id="2-7-9-Threading-and-Schedulers"><a href="#2-7-9-Threading-and-Schedulers" class="headerlink" title="2.7.9 Threading and Schedulers"></a>2.7.9 Threading and Schedulers</h4><p>一般来说，响应式框架并不一定是并发的(create那个是生产者并发，它本身不是并发的)，依赖开发者自己通过一些lib库来实现并发。Flux或Mono并不意味着其运行在一个新的线程，大多数运算都在其上一个线程执行的线程里执行。除非特别指定，最顶层（源）运算运行在subscribe()被调用的线程里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10</span>).filter(v -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;).map(v -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">&#125;).subscribe(v -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">test.join();</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 4<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 5<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 6<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 7<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 8<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 9</p></blockquote><p>在Reactor里，Scheduler决定了操作在哪个线程被怎么执行，它的作用类似于ExecutorService。不过功能稍微多点。如果你想实现一些并发操作，那么可以考虑使用Schedulers提供的静态方法。</p><ul><li><code>Schedulers.immediate()</code>：在当前线程运行</li><li><code>Schedulers.single()</code>：可重用的单线程。所有调用Schedulers.single()的方法都使用同样一个线程。如果每次想要不一样的线程，可以使用<code>Schedulers.newSingle()</code></li><li><code>Schedulers.elastic()</code>：一个弹性无界线程池。有时候太多的线程对于计算机计算来说反而是中负担。</li><li><code>Schedulers.bounededElastic()</code>：有界可复用的线程池。可以在需要的时候创建工作线程池，并复用空闲的池。同时，某些池如果空闲时间超过一个限定的数值就会被抛弃。同时，它还有一个容量限制，一般10倍于CPU核心数，这是它后备线程池的最大容量。当线程不够用时，允许最多提交10万条任务，进入等待队列，等到有可用时再调度，如果是延时调度，那么延时开始时间是在有线程可用时才开始计算。由此可见Schedulers.boundedElastic()对于阻塞的I/O操作是一个不错的选择，因为它可以让每一个操作都有自己的线程。但是记得，太多的线程会让系统备受压力。</li><li><code>Schedulers.parallel()</code>：固定大小的线程池，会创建数量等于CPU核心数的线程来实现这一功能。</li><li><code>Schedulers.fromExecutorService(ExecutorService)</code>：除了使用已经存在的schedulers，还可以基于executorService产生自定义的Scheduler。</li></ul><p>当然，我们也可以通过调用newXXX之类的方法来创建自己的Scheduler。比如<code>Schedulers.newParallel(&quot;My scheduler Name&quot;)</code>来创建一个新的并行调度器。boudedElastic被用来处理无法避免阻塞的代码，而single和parallel不被允许，在single和parallel线程中调用阻塞 API（block(), blockFirst(), blockLast()（以及迭代toIterable() 或toStream()）会导致抛出IllegalStateException异常。自定义Schedulers也可以通过创建实现了NonBlocking接口的线程来禁止阻塞调用。</p><p>一些运算其实默认使用了一些Scheduler。比如，<code>Flux.interval(Duration.ofMillis(300))</code>创建了一个每300ms触发一次的Flux<long>，默认使用了Schedulers.parallel()。</long></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.interval(Duration.ofMillis(<span class="number">300</span>)).take(<span class="number">1</span>).subscribe(v -&gt; System.out.println(<span class="string">"Thread is "</span> + Thread.currentThread().getName()));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Thread is parallel-1</p></blockquote><h4 id="2-7-10-publishOn和subscribeOn"><a href="#2-7-10-publishOn和subscribeOn" class="headerlink" title="2.7.10 publishOn和subscribeOn"></a>2.7.10 publishOn和subscribeOn</h4><p>Reactor提供了两种切换执行上下文的方法，<code>publishOn</code>和<code>subscribeOn</code>。这两个方法接收一个scheduler，用于让后续流操作的执行上下文切换到此scheduler。<code>publishOn</code>在流式链中被调用，而<code>subscribeOn</code>则不是这么用的。</p><h5 id="2-7-10-1-publishOn"><a href="#2-7-10-1-publishOn" class="headerlink" title="2.7.10.1 publishOn"></a>2.7.10.1 publishOn</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 工作在Teat-Thread线程</span></span><br><span class="line">System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;).publishOn(Schedulers.single()).map(v -&gt; &#123;    <span class="comment">// 切换后续执行线程到single线程</span></span><br><span class="line">System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">&#125;).subscribe(v -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>filter thread is Test-thread<br>map thread is single-1<br>subscribe thread is single-1<br>value is 4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 运行在Test-Thread线程</span></span><br><span class="line">System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;).publishOn(Schedulers.single()).map(v -&gt; &#123;  <span class="comment">// 后续线程运行在single线程</span></span><br><span class="line">System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">&#125;).publishOn(Schedulers.newSingle(<span class="string">"My Single Thread"</span>)).subscribe(v -&gt; &#123;   <span class="comment">// 后续线程运行在My Single Thread线程</span></span><br><span class="line">System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>filter thread is Test-thread<br>map thread is single-2<br>subscribe thread is My Single Thread-1<br>value is 4</p></blockquote><h5 id="2-7-10-2-subscribeOn"><a href="#2-7-10-2-subscribeOn" class="headerlink" title="2.7.10.2 subscribeOn"></a>2.7.10.2 subscribeOn</h5><p>subscribeOn工作在subscription过程，也就是整个流式链创建的地方。因此，不管你把subscribeOn放在链中的哪个位置，它总是影响数据源的上下文，并且不影响后续使用publishOn来执行上下文切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 继承自源序列的线程</span></span><br><span class="line">System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;).subscribeOn(Schedulers.parallel()) <span class="comment">// 源序列产生于parallel线程</span></span><br><span class="line">.publishOn(Schedulers.single()).map(v -&gt; &#123;  <span class="comment">// 切换到single线程</span></span><br><span class="line">System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">&#125;).publishOn(Schedulers.parallel()).subscribe(v -&gt; &#123;   <span class="comment">// 切换到parallel线程</span></span><br><span class="line">System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>filter thread is parallel-2<br>map thread is single-1<br>subscribe thread is parallel-1<br>value is 4</p></blockquote><h2 id="3-Reactor重构"><a href="#3-Reactor重构" class="headerlink" title="3. Reactor重构"></a>3. Reactor重构</h2><p>还记得开头我们用completeFuture写的例子吗？现在是时候重构他了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.publishOn(Schedulers.boundedElastic()).map(id -&gt; &#123;</span><br><span class="line">Mono&lt;String&gt; name = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getName());</span><br><span class="line">Mono&lt;String&gt; author = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getAuthor());</span><br><span class="line"><span class="keyword">return</span> name.zipWith(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">&#125;)</span><br><span class="line">.publishOn(Schedulers.boundedElastic()).subscribe(zip -&gt; zip.subscribe(System.out::println));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>map返回的是一个Flux<string>对象，如果对于流中的每一个数据，我们处理map的期望的结果是从String-&gt;String，这点我们可以使用flatMap实现</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.publishOn(Schedulers.boundedElastic()).flatMap(id -&gt; &#123;</span><br><span class="line">Mono&lt;String&gt; name = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getName());</span><br><span class="line">Mono&lt;String&gt; author = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getAuthor());</span><br><span class="line"><span class="keyword">return</span> name.zipWith(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">&#125;)</span><br><span class="line">.publishOn(Schedulers.boundedElastic()).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Name is test1,author is Jack<br>Name is test2,author is Tom<br>Name is test4,author is Blue<br>Name is test3,author is mary</p></blockquote><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><ol><li><a href="https://projectreactor.io/docs/core/release/reference/#error.handling" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#error.handling</a></li><li><a href="https://skyao.io/learning-reactor/docs/concept/flux/create.html" target="_blank" rel="noopener">https://skyao.io/learning-reactor/docs/concept/flux/create.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/283903217" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/283903217</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 提供了两种异步编程模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回调&lt;/strong&gt;：异步方法没有返回值，但需要一个额外的 callback参数（一个 lambda 或匿名类），当结果可用时会被调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Futures&lt;/strong&gt;：异步方法立即返回一个Future&lt;t&gt;。异步过程计算一个T值，但Future对象包装了对它的访问。该值不会立即可用，并且可以轮询该对象直到该值可用。例如，一个ExecutorService正在运行的Callable&lt;t&gt;任务使用Future对象。&lt;/t&gt;&lt;/t&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种方式各有优劣，回调代码很难组合在一起，很快导致代码难以阅读和维护。Future比回调稍微好点，通过CompleteFuture，我们将多个Future对象编排 在一起。但Future也有一些缺点，它不支持惰性计算，没有背压能力，缺乏对多个值和高级错误处理的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="异步编程" scheme="https://shinerio.cc/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://shinerio.cc/tags/java/"/>
    
      <category term="异步编程" scheme="https://shinerio.cc/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="reactor" scheme="https://shinerio.cc/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>Reactor编程（一）</title>
    <link href="https://shinerio.cc/2021/12/18/java/Reactor%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://shinerio.cc/2021/12/18/java/Reactor编程（一）/</id>
    <published>2021-12-18T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>Reactor是响应式编程的一种实现方式。响应式编程关心数据流以及数据变化的传播，是一种异步编程的一种范式。这意味着通过编程语言实现的响应式编程可以轻松地表达静态（例如arrays）或动态（例如event emitters）数据。</p><a id="more"></a><h2 id="1-Flow"><a href="#1-Flow" class="headerlink" title="1. Flow"></a>1. Flow</h2><p>响应式编程最初由Microsoft创建，其在.NET生态中创造了响应式扩展库（Rx）。RxJava和Akka流是JAVA生态下反应是编程的流行实现。随着时间的推移，通过 Reactive Streams 的努力出现了 Java 的标准化，该规范为 JVM 上的反应库定义了一组接口和交互规则。 它的接口已集成到 Java 9的java.util.concurrent.Flow类下。</p><p>反应流是关于流的异步处理，其实是观察者模式的一种实现，所以应该有一个发布者和一个订阅者，发布者发布数据流，订阅者使用数据。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639806474119.png" alt="enter description here"></p><p>以上是一个最简单的流式模型，实际上流中的每一个节点即可以是Subscriber，消费上一个流结果，也可以是Publisher，为下一个流提供数据来源。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639806573224.png" alt="enter description here"></p><p>当然，一个良好的编程设计，具备工作流的前提下，还需要考虑到异常处理和任务完成，提供onError和onComplete机制。因此可以总结为如下机制：</p><p><code>onNext 0...N | [onError | onComplete|</code></p><h3 id="1-1-java-util-concurrent-Flow"><a href="#1-1-java-util-concurrent-Flow" class="headerlink" title="1.1  java.util.concurrent.Flow"></a>1.1  java.util.concurrent.Flow</h3><p>Flow是流API的主要类,这个类封装了流API的所有重要接口。</p><ul><li><code>java.util.concurrent.Flow.Publisher</code>，这是一个功能接口，每个发布者都必须实现其subscribe方法，以便能够添加对应的subscriber</li><li><code>java.util.concurrent.Flow.Subscriber</code>，每个订阅者都必须实现此接口。包括四个方法：<ul><li>onSubscribe：当订阅者像发布者发起订阅时触发，这是发布者给订阅者的第一条消息。</li><li>onNext：当从publisher每接收到一个消息时，就会调用这个方法，用来实现业务逻辑来处理流。</li><li>onError：当发生不可恢复的错误时调用此方法，我们可以在此方法中处理异常及执行清理资源，例如关闭数据库连接。</li><li>onComplete：当publisher没有生成其他项并且publisher关闭时调用它。我们可以用它来发送流处理成功的通知、</li></ul></li><li><code>java.util.concurrent.Flow.Subscription</code>，用于控制发布者和订阅者之间的链接。订阅者只有在requested的时候可以收到消息，并且可以在任何时候调用cancel方法取消。订阅者可以通过调用<code>request(long n)</code>方法来实现订阅之多n个消息。</li><li><code>java.util.concurrent.Flow.Processor</code>，此接口扩展发布服务器和订阅服务器，用于在发布服务器和订阅服务器之间转换消息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Flow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Flow</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 不可实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">     * A producer of items (and related control messages) received by</span></span><br><span class="line"><span class="comment">     * Subscribers.  Each current &#123;<span class="doctag">@link</span> Subscriber&#125; receives the same</span></span><br><span class="line"><span class="comment">     * items (via method &#123;<span class="doctag">@code</span> onNext&#125;) in the same order, unless</span></span><br><span class="line"><span class="comment">     * drops or errors are encountered. If a Publisher encounters an</span></span><br><span class="line"><span class="comment">     * error that does not allow items to be issued to a Subscriber,</span></span><br><span class="line"><span class="comment">     * that Subscriber receives &#123;<span class="doctag">@code</span> onError&#125;, and then receives no</span></span><br><span class="line"><span class="comment">     * further messages.  Otherwise, when it is known that no further</span></span><br><span class="line"><span class="comment">     * messages will be issued to it, a subscriber receives &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * onComplete&#125;.  Publishers ensure that Subscriber method</span></span><br><span class="line"><span class="comment">     * invocations for each subscription are strictly ordered in &lt;a</span></span><br><span class="line"><span class="comment">     * href="package-summary.html#MemoryVisibility"&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Publishers may vary in policy about whether drops (failures</span></span><br><span class="line"><span class="comment">     * to issue an item because of resource limitations) are treated</span></span><br><span class="line"><span class="comment">     * as unrecoverable errors.  Publishers may also vary about</span></span><br><span class="line"><span class="comment">     * whether Subscribers receive items that were produced or</span></span><br><span class="line"><span class="comment">     * available before they subscribed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the published item type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds the given Subscriber if possible.  If already</span></span><br><span class="line"><span class="comment">         * subscribed, or the attempt to subscribe fails due to policy</span></span><br><span class="line"><span class="comment">         * violations or errors, the Subscriber's &#123;<span class="doctag">@code</span> onError&#125;</span></span><br><span class="line"><span class="comment">         * method is invoked with an &#123;<span class="doctag">@link</span> IllegalStateException&#125;.</span></span><br><span class="line"><span class="comment">         * Otherwise, the Subscriber's &#123;<span class="doctag">@code</span> onSubscribe&#125; method is</span></span><br><span class="line"><span class="comment">         * invoked with a new &#123;<span class="doctag">@link</span> Subscription&#125;.  Subscribers may</span></span><br><span class="line"><span class="comment">         * enable receiving items by invoking the &#123;<span class="doctag">@code</span> request&#125;</span></span><br><span class="line"><span class="comment">         * method of this Subscription, and may unsubscribe by</span></span><br><span class="line"><span class="comment">         * invoking its &#123;<span class="doctag">@code</span> cancel&#125; method.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> subscriber the subscriber</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> NullPointerException if subscriber is null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A receiver of messages.  The methods in this interface are</span></span><br><span class="line"><span class="comment">     * invoked in strict sequential order for each &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Subscription&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the subscribed item type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked prior to invoking any other Subscriber</span></span><br><span class="line"><span class="comment">         * methods for the given Subscription. If this method throws</span></span><br><span class="line"><span class="comment">         * an exception, resulting behavior is not guaranteed, but may</span></span><br><span class="line"><span class="comment">         * cause the Subscription not to be established or to be cancelled.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Typically, implementations of this method invoke &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">         * subscription.request&#125; to enable receiving items.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> subscription a new subscription</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked with a Subscription's next item.  If this</span></span><br><span class="line"><span class="comment">         * method throws an exception, resulting behavior is not</span></span><br><span class="line"><span class="comment">         * guaranteed, but may cause the Subscription to be cancelled.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> item the item</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T item)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked upon an unrecoverable error encountered by a</span></span><br><span class="line"><span class="comment">         * Publisher or Subscription, after which no other Subscriber</span></span><br><span class="line"><span class="comment">         * methods are invoked by the Subscription.  If this method</span></span><br><span class="line"><span class="comment">         * itself throws an exception, resulting behavior is</span></span><br><span class="line"><span class="comment">         * undefined.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> throwable the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when it is known that no additional</span></span><br><span class="line"><span class="comment">         * Subscriber method invocations will occur for a Subscription</span></span><br><span class="line"><span class="comment">         * that is not already terminated by error, after which no</span></span><br><span class="line"><span class="comment">         * other Subscriber methods are invoked by the Subscription.</span></span><br><span class="line"><span class="comment">         * If this method throws an exception, resulting behavior is</span></span><br><span class="line"><span class="comment">         * undefined.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Message control linking a &#123;<span class="doctag">@link</span> Publisher&#125; and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Subscriber&#125;.  Subscribers receive items only when requested,</span></span><br><span class="line"><span class="comment">     * and may cancel at any time. The methods in this interface are</span></span><br><span class="line"><span class="comment">     * intended to be invoked only by their Subscribers; usages in</span></span><br><span class="line"><span class="comment">     * other contexts have undefined effects.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds the given number &#123;<span class="doctag">@code</span> n&#125; of items to the current</span></span><br><span class="line"><span class="comment">         * unfulfilled demand for this subscription.  If &#123;<span class="doctag">@code</span> n&#125; is</span></span><br><span class="line"><span class="comment">         * less than or equal to zero, the Subscriber will receive an</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> onError&#125; signal with an &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">         * IllegalArgumentException&#125; argument.  Otherwise, the</span></span><br><span class="line"><span class="comment">         * Subscriber will receive up to &#123;<span class="doctag">@code</span> n&#125; additional &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">         * onNext&#125; invocations (or fewer if terminated).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n the increment of demand; a value of &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">         * Long.MAX_VALUE&#125; may be considered as effectively unbounded</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Causes the Subscriber to (eventually) stop receiving</span></span><br><span class="line"><span class="comment">         * messages.  Implementation is best-effort -- additional</span></span><br><span class="line"><span class="comment">         * messages may be received after invoking this method.</span></span><br><span class="line"><span class="comment">         * A cancelled subscription need not ever receive an</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> onComplete&#125; or &#123;<span class="doctag">@code</span> onError&#125; signal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A component that acts as both a Subscriber and Publisher.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the subscribed item type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; the published item type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a default value for Publisher or Subscriber buffering,</span></span><br><span class="line"><span class="comment">     * that may be used in the absence of other constraints.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment">     * The current value returned is 256.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the buffer size value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">defaultBufferSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String name, <span class="keyword">int</span> price, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSubscriber</span> <span class="keyword">implements</span> <span class="title">Flow</span>.<span class="title">Subscriber</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">        <span class="keyword">this</span>.subscription.request(<span class="number">1</span>); <span class="comment">//requesting data from publisher</span></span><br><span class="line">        System.out.println(<span class="string">"receive subscription"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Order item)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"receive item %s\n"</span>, item.getName());</span><br><span class="line">        <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exception happened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Processing Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Publisher</span></span><br><span class="line">SubmissionPublisher&lt;Order&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register Subscriber</span></span><br><span class="line">OrderSubscriber subs = <span class="keyword">new</span> OrderSubscriber();</span><br><span class="line">publisher.subscribe(subs);</span><br><span class="line"></span><br><span class="line">List&lt;Order&gt; orders = Arrays.asList(<span class="keyword">new</span> Order(<span class="string">"Iphone"</span>, <span class="number">6000</span>, <span class="number">1</span>), <span class="keyword">new</span> Order(<span class="string">"Book"</span>, <span class="number">20</span>, <span class="number">3</span>), <span class="keyword">new</span> Order(<span class="string">"Paper"</span>, <span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish items</span></span><br><span class="line">System.out.println(<span class="string">"Publishing Items to Subscriber"</span>);</span><br><span class="line">orders.forEach(publisher::submit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logic to wait till processing of all messages are over</span></span><br><span class="line"><span class="keyword">while</span> (orders.size() != subs.getCounter()) &#123;</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// close the Publisher</span></span><br><span class="line">publisher.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p>Publishing Items to Subscriber<br>receive subscription<br>receive item Iphone<br>receive item Book<br>receive item Paper<br>All Processing Done</p></blockquote><p>接着，我们可以简单来做个性能测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSubscriber</span> <span class="keyword">implements</span> <span class="title">Flow</span>.<span class="title">Subscriber</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderSubscriber</span><span class="params">(<span class="keyword">int</span> num, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">        <span class="keyword">this</span>.subscription.request(num); <span class="comment">//requesting data from publisher</span></span><br><span class="line">        System.out.println(<span class="string">"receive subscription"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Order item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.printf("receive item %s\n", item.getName());</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exception happened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Processing Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">orders.add(<span class="keyword">new</span> Order(<span class="string">"Iphone"</span>, <span class="number">6000</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Publisher</span></span><br><span class="line">SubmissionPublisher&lt;Order&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register Subscriber</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(orders.size());</span><br><span class="line">OrderSubscriber subs = <span class="keyword">new</span> OrderSubscriber(orders.size(), countDownLatch);</span><br><span class="line">publisher.subscribe(subs);</span><br><span class="line"><span class="comment">// Publish items</span></span><br><span class="line">System.out.println(<span class="string">"Publishing Items to Subscriber"</span>);</span><br><span class="line">orders.forEach(publisher::submit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logic to wait till processing of all messages are over</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// close the Publisher</span></span><br><span class="line">publisher.close();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Tps is: "</span> + orders.size() * <span class="number">1000000000L</span> / (System.nanoTime() - t) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Publishing Items to Subscriber<br>receive subscription<br>All Processing Done<br>Tps is: 31</p></blockquote><p>此处，我们模拟了每个订单处理的过程是阻塞式的，需要30ms左右，最终看到TPS只有31，没有想象中的高。这是因为onNext是顺序执行的，每个阻塞30ms左右，自然最终TPS只有31。基于此，我们可以将onNext也改成异步非阻塞式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSubscriber</span> <span class="keyword">implements</span> <span class="title">Flow</span>.<span class="title">Subscriber</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderSubscriber</span><span class="params">(<span class="keyword">int</span> num, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">        <span class="keyword">this</span>.subscription.request(num); <span class="comment">//requesting data from publisher</span></span><br><span class="line">        System.out.println(<span class="string">"receive subscription"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Order item)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool.commonPool().execute(<span class="keyword">new</span> OrderProcessor(countDownLatch, item));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exception happened"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Processing Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OrderProcessor</span><span class="params">(CountDownLatch countDownLatch, Order order)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">            <span class="keyword">this</span>.order = order;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String name = order.getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Publishing Items to Subscriber<br>receive subscription<br>All Processing Done<br>Tps is: 298</p></blockquote><p>可以看到TPS提升了10倍左右，性能的提升与计算机的性能和异步线程池的大小有关，这里我们用的Forjoin线程池。接着，我们尝试调整线程池中线程的数量。</p><p>如果我们将线程池大小提高到与order数量一致，会得到如下输出。如果计算机核心够多，则此时所有任务都是并行的，所有任务一起阻塞30ms左右。TPS理论极限应该为1000 / 30 * N，其中N为CPU核心数量。</p><blockquote><p>Publishing Items to Subscriber<br>receive subscription<br>All Processing Done<br>Tps is: 1469</p></blockquote><p>如果我们将线程池大小改成1，会得到如下输出，此时所有任务共享一个线程，相当于是串行阻塞的。</p><blockquote><p>Publishing Items to Subscriber<br>receive subscription<br>All Processing Done<br>Tps is: 31</p></blockquote><p>所以在使用异步流工作的时候，我们的任务中的每一环最好都是无阻塞的，否则整个异步流都会因为一个阻塞点而大大降低性能。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://projectreactor.io/docs/core/release/reference/#about-doc" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#about-doc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reactor是响应式编程的一种实现方式。响应式编程关心数据流以及数据变化的传播，是一种异步编程的一种范式。这意味着通过编程语言实现的响应式编程可以轻松地表达静态（例如arrays）或动态（例如event emitters）数据。&lt;/p&gt;
    
    </summary>
    
      <category term="异步编程" scheme="https://shinerio.cc/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://shinerio.cc/tags/java/"/>
    
      <category term="异步编程" scheme="https://shinerio.cc/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="reactor" scheme="https://shinerio.cc/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="https://shinerio.cc/2021/12/14/java/CompletableFuture/"/>
    <id>https://shinerio.cc/2021/12/14/java/CompletableFuture/</id>
    <published>2021-12-14T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.751Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA 5中引入了Future特性，可以获取异步执行结果。Future多用于使用线程池执行任务后获取任务结果，当我们submit一个callable的任务时可以获取一个Future对象，通过调用get()方法阻塞获得任务结果，或者通过轮训isDone()来判断任务是否执行完成。阻塞式的方式与异步的初衷相违背，而轮询的方式又会浪费CPU资源，通过观察者模式则可以实现在完成计算时通知订阅者。JAVA8引入了一系列优秀的特性，包括lambda表达式，steam流式操作，同时也引入了CompletableFuture来提供更优雅的异步编程手段。</p><a id="more"></a><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p> CompletableFuture除了实现了Future接口之外，还实现了CompletionStage接口。CompletionStage提供了一系列丰富的接口和函数式编程的能力，可以添加一些回调函数用于任务完成时触发，通过这个异步任务流的方式可以构建出一个非阻塞的系统。</p><h2 id="开启异步方法"><a href="#开启异步方法" class="headerlink" title="开启异步方法"></a>开启异步方法</h2><p>completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。此外，CompletableFuture提供了四个方法来开启一个异步方法，其中CompletableFuture.supplyAsync()支持返回值，而CompletableFuture.runAsync()不支持返回值。如果不指定Executor，则使用ForkJoinPool.commonPool()，ForkJoinPool的commonPool是一个静态方法，提供公共的线程池共业务使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">CompletableFuture&lt;String&gt; result = CompletableFuture.completedFuture(<span class="string">"Run Over!"</span>);</span><br><span class="line">      CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"test run async, ForkJoin.commonPool!"</span>));</span><br><span class="line">      CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"test run async, customize thread pool!"</span>), executor);</span><br><span class="line">      CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supply async, ForJoin.CommonPool!"</span>);</span><br><span class="line">      CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supply async, customize thread pool!"</span>, executor);</span><br></pre></td></tr></table></figure><h2 id="主动完成计算"><a href="#主动完成计算" class="headerlink" title="主动完成计算"></a>主动完成计算</h2><p>CompletableFuture类实现了CompletionStage和Future接口，所以可以像Future以前一样通过阻塞或者轮询的方式获得结果，但是这种方式不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞式等待任务执行完成，获得执行结果或异常，抛出的异常为checked exception</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 等待超时时间后，抛出TimeoutException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//立即获得结果，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的valueIfAbsent值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 阻塞式等待任务执行完成，获得执行结果或异常，抛出的异常为unchecked exception（CompletionException）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>checked exception异常通常指RunTimeException及其子类，RuntimeException在默认情况下会得到自动处理。所以通常用不着捕获RuntimeException，但在自己的封装里，也许仍然要选择抛出一部分RuntimeException。RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException的任何子类都无需在throws子句中进行声明。例如NullPointerException。除了RuntimeException以外的异常，都属于checkedException，它们都在java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。例如InterruptedException。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.getNow(<span class="string">"get Now"</span>));</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>get Now</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(future.get(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Timeout"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Timeout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If not already completed, sets the value returned by get() and related methods to the given value.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//f not already completed, causes invocations of get() and related methods to throw the given exception.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Forcibly sets or resets the value subsequently returned by method get() and related methods, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Forcibly causes subsequent invocations of method get() and related methods to throw the given exception, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeException</span><span class="params">(Throwable ex)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>obtrudeValue、obtrudeException可以在计算完成的时候重新设置结果值，但是使用的时候要非常谨慎，因为complete已经触发了后续流程，有可能导致得不到期望的结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.complete(<span class="string">"run over now!"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>run over now!</p></blockquote><figure class="highlight java"><figcaption><span>CompletableFuture<string> future </string></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">future.obtrudeValue(<span class="string">"reset run over"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>reset run over</p></blockquote><h2 id="计算完成时处理"><a href="#计算完成时处理" class="headerlink" title="计算完成时处理"></a>计算完成时处理</h2><p>当completableFuture计算结果完成，或者抛出异常的时候，可以通过如下方法指定特定的Action。action参数的类型为<code>(BiConsumer&lt;? super T,? super Throwable&gt;</code>，代表可以处理正常的计算结果，也可以处理异常情况。when开头的方法当action执行完成后，会返回原始的CompletableFuture计算结果或异常，而exceptionally则返回一个新的CompletableFuture对象。exceptionally用来处理当原始CompletableFuture抛出异常的时候，触发计算，否则以原始CompletableFuture作为返回结果。方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure><p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由BiFunction参数计算而得。因此这组方法兼有whenComplete和转换的两个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; System.out.println(v));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>run over</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; System.out.println(e)).exceptionally(Throwable::toString);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero<br>java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</p></blockquote><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>通过回调机制，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉CompletableFuture当计算完成的时候请执行某个function。而且我们还可以将这些操作串联起来，或者将CompletableFuture组合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>这一组函数的作用在于当原始CompletableFuture计算完成后，可以将结果传递给回调函数fn，将fn的结果作为新的CompletableFuture结果计算。将<code>CompletableFuture&lt;T&gt;</code>转换成<code>CompletableFuture&lt;U&gt;</code>。这里的转换不是阻塞式的，而是等去前一个stage完成后，回调执行的。这些方法和handle方法的区别在于，这些方案只会计算正常值，有异常就会抛出，而handle方法可以处理异常，避免异常继续抛出。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenApply(ret -&gt; ret + <span class="string">"\nrun over"</span>).whenComplete((v, e) -&gt; System.out.println(v));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>run over<br>run over</p></blockquote><h2 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h2><p>上面的方法是当计算完成的时候，会生成新的计算结果(thenApply, handle)，或者返回同样的计算结果whenComplete，CompletableFuture还提供了一种处理结果的方法，只对结果执行Action，而不返回新的计算值，因此计算值为Void。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenAccept(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>run over</p></blockquote><p>thenAcceptBoth以及相关方法提供了类似的功能，当原始completableFuture和传入的other completableFuture都正常完成计算的时候，就会执行提供的action。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenAcceptBoth(other, (v1, v2) -&gt; System.out.println(v1 + <span class="string">"\n"</span> + v2));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>run over<br>other run over</p></blockquote><p>thenRun是当原始completableFuture计算完成是，就会执行另一个runnable；runAfterBoth是当两个CompletionStage都正常完成计算的时候，执行一个Runnable。这个Runnable并不使用计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,  Runnable action)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenRun(() -&gt; System.out.println(<span class="string">"no input, do nothing"</span>));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>no input, do nothing</p></blockquote><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>compose系列方法接收一个Function作为参数，这个Function的输入是当前CompletableFuture的计算值，返回结果是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>compose和apply的区别在于，compose中提供的Function返回是CompletionStage，而apply中的Function返回的是一个普通对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"run over"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; compose = future.thenCompose((v) -&gt; other);</span><br><span class="line">CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt; apply = future.thenApply(v -&gt; other);</span><br></pre></td></tr></table></figure><p>combine方法用来组合两个stage，将两个stage的输出作为后续异步流的输入，combine和acceptBoth方法的区别在于，acceptBoth没有返回值，combine有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line">future.thenCombine(other, (v1, v2) -&gt; v1 * v2).whenComplete((v, e) -&gt; System.out.println(v));</span><br></pre></td></tr></table></figure></p><p>输出：</p><blockquote><p>200</p></blockquote><h2 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h2><p>thenAcceptBoth和runAfterBoth是当两个CompletableFuture都计算完成，either实现是当任意一个CompletableFuture计算完成的时候就会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span> + random.nextInt(<span class="number">3</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;&#125;);</span><br><span class="line">CompletableFuture&lt;Integer&gt; other = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span> + random.nextInt(<span class="number">3</span>) );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;&#125;);</span><br><span class="line">future.acceptEither(other, System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>以上代码有时候输出10，有时候输出20</p><h2 id="allOf和anyOf"><a href="#allOf和anyOf" class="headerlink" title="allOf和anyOf"></a>allOf和anyOf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt;  <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure><p>allOf方法是当所有的CompletableFuture都执行完后执行计算。anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。anyOf的返回值是其中一个CompletableFuture的计算结果，而applyToEither返回值的计算结果要结果Function处理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">https://colobu.com/2016/02/29/Java-CompletableFuture/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA 5中引入了Future特性，可以获取异步执行结果。Future多用于使用线程池执行任务后获取任务结果，当我们submit一个callable的任务时可以获取一个Future对象，通过调用get()方法阻塞获得任务结果，或者通过轮训isDone()来判断任务是否执行完成。阻塞式的方式与异步的初衷相违背，而轮询的方式又会浪费CPU资源，通过观察者模式则可以实现在完成计算时通知订阅者。JAVA8引入了一系列优秀的特性，包括lambda表达式，steam流式操作，同时也引入了CompletableFuture来提供更优雅的异步编程手段。&lt;/p&gt;
    
    </summary>
    
      <category term="异步编程" scheme="https://shinerio.cc/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://shinerio.cc/tags/java/"/>
    
      <category term="异步编程" scheme="https://shinerio.cc/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务一致性</title>
    <link href="https://shinerio.cc/2021/12/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://shinerio.cc/2021/12/03/系统设计/分布式事务一致性/</id>
    <published>2021-12-03T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>本文在将分布式事务之前，会先回顾一下事务的一些基本概念，分布式事务本身与数据库事务的概念是一致的，需要满足事务的ACID原则。单体架构下，我们可以依赖数据库提供的事务能力保证；分布式架构下我们则需要保证一个请求在多个微服务调用链中，所有服务的数据要么全部成功，要么全部回滚，保证多节点数据一致性。分布式事务的实现有很多种方式，主要包括两阶段提交（2PC）、三阶段提交（3PC）、补偿事务（TCC）以及Paxos算法。</p><a id="more"></a><h2 id="1-ACID原则"><a href="#1-ACID原则" class="headerlink" title="1. ACID原则"></a>1. ACID原则</h2><ul><li><strong>Atomicity(原子性)</strong>：事务是一个不可分割的整体，所有操作要么一起成功，要么一起失败；一个事务中如果有一个操作出错，那么事务应该被回滚到事务开始前的状态。</li><li><strong>Consistency(一致性)</strong>：在并发事务的场景下，单个事务执行前后，数据从一个状态到另一个状态的变化必须是一致的。比如多个账户之间发生多次相互转账，一个人扣了钱，那么一定有另一个人的钱增加了，所有账户的总额一定要保持不变。</li><li><strong>Isolation(隔离性)</strong>：多个并发事务之间相互隔离，不能互相干扰，不能出现脏读、不可重复读、幻读等问题；数据库常用的各种锁机制来保证这点。</li><li><strong>Durability(持久性)</strong>：事务完成后，对数据库的更改是永久保存的，不能回滚；要求数据库数据要落盘持久化。</li></ul><h2 id="2-CAP理论"><a href="#2-CAP理论" class="headerlink" title="2. CAP理论"></a>2. CAP理论</h2><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li><strong>Consistency(一致性)</strong>：一致性指的是”all nodes see the same data at the same time”，即所有节点在同一时间的数据完全一致。从客户端来看，一致性主要是指可以访问到更新过的数据；从服务端来看，一致性主要是保证数据的更新能够分布到整个系统中，保证结果一致。对于一致性可以分为强/弱/最终一致性三类，强一致性保证更新后的数据能够被后续读取到；弱一致能够容忍更新后部分或全部访问不到；最终一致性保证在经过一段时候后，被更新的数据总是能被正确地访问。</li><li><strong>Availability(可用性)</strong>：可用性指的是”Reads and writes always succeed”，即在部分节点故障后，整个服务仍一直处于可用状态，且响应时间保持在正常范围。</li><li><strong>Partition Tolerance分区容错性</strong>：分区容错性指的是”the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul><p>CA without P：如果不要求分区，保证CA场景，就违背了分布式系统设计的初衷，传统的关系型数据库就是这种设计的典型代表<br>CP without A: 如果不要求可用，那就保证所有节点之间的强一致性，就会导致同步时间无限延长。涉及到计费系统，银行系统，这时候就应该舍弃A，保证C。<br>AP without C：一旦分区中某个节点发生故障，为了高可用，只能舍弃这个节点的数据一致性。在分布式系统中，集群规模庞大，节点故障，网络异常再所难免，为了保证服务的可用性，只能放弃C，保证数据的最终一致性。如果服务宣称要支持几个9的可用性，那基本都是AP withou C模型。</p><h2 id="3-BASE理论"><a href="#3-BASE理论" class="headerlink" title="3. BASE理论"></a>3. BASE理论</h2><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。BASE理论是对CAP理论中C和A权衡的结果，应用可以不做到强一致性，但应该保证最终一致性。</p><ul><li><strong>基本可用</strong>：基本可用的意思是在分布式系统部分节点出现偶发故障的时候，可以牺牲掉部分可用性，如api时延延长但仍处于可用状态。分布式服务常通过服务限流、服务降级等手段进行保护。</li><li><strong>软状态</strong>：软状态是相对于硬状态来说，软状态允许存在中间态，即允许存在短时间的数据不一致，且这种中间状态不会影响整体系统的可用性。</li><li><strong>最终一致性</strong>：最终一致性强调系统中的数据在经过一段时间后，可以达到最终一致的状态。</li></ul><h2 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4. 分布式事务"></a>4. 分布式事务</h2><h3 id="4-1-2PC-两阶段提交"><a href="#4-1-2PC-两阶段提交" class="headerlink" title="4.1 2PC(两阶段提交)"></a>4.1 2PC(两阶段提交)</h3><p>两阶段提交又称2PC（two-phase commit protocol)，是一个强一致、中心化的原子提交协议，参与的角色包括一个<strong>协调节点(coordinator)</strong><br>和多个<strong>参与者节点(participant)</strong>。</p><p>所谓的两阶段包括如下两阶段：</p><ul><li>第一阶段：voting phase 投票阶段</li><li>第二阶段：commit phase 提交阶段</li></ul><h4 id="4-1-1-投票阶段"><a href="#4-1-1-投票阶段" class="headerlink" title="4.1.1 投票阶段"></a>4.1.1 投票阶段</h4><ul><li>事务coordinator给每个participant发送prepare(vote_request)消息，询问是否可以执行提交操作，等待事务participant响应</li><li>每个事务participant判断能否执行事务，如果能则执行本地执行事务，并记录redo和undo日志（为了故障后恢复使用），但不提交</li><li>事务participant告诉事务coordinator同意提交或拒绝提交</li></ul><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1638451333424.png" alt="enter description here"></p><blockquote><p>undo log，回滚日志，在事务执行过程中操作任何数据之前现将数据备份到undolog中，事务失败时刻根据undo log进行回滚，用来保证事务的一致性。redo log，重做日志，在事务执行过程中不断记录事务操作的变化。恢复提交后的物理数据也，用来保证事务的持久性。</p></blockquote><h4 id="4-1-2-提交阶段"><a href="#4-1-2-提交阶段" class="headerlink" title="4.1.2 提交阶段"></a>4.1.2 提交阶段</h4><p>如果coordinator收到了participant的失败消息或者超时，直接给每个participant发送回滚(Rollback)消息；否则，发送提交(Commit)消息；participant根据coordinator的指令执行提交或者回滚操作。</p><h5 id="4-1-2-1-成功case"><a href="#4-1-2-1-成功case" class="headerlink" title="4.1.2.1 成功case"></a>4.1.2.1 成功case</h5><ul><li>所有事务participant向事务coordinator发送vote commit</li><li>事务coordinator收到所有事务participant的vote commit，向所有事务participant发送可以提交通知</li><li>事务participant完成提交并向事务coordinator发送ack消息</li><li><p>coordinator收到所有participantack消息后，事务完成</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1638452553640.png" alt="enter description here"></p><h5 id="4-1-2-2-失败case"><a href="#4-1-2-2-失败case" class="headerlink" title="4.1.2.2 失败case"></a>4.1.2.2 失败case</h5><ul><li>部分事务participant向事务coordinator发送vote commit，部分事务participant向事务coordinator发送vote abort</li></ul></li><li>事务coordinator收到部分事务participantvote abort消息，则向所有事务participant发送回滚通知</li><li>事务participant完成回滚并向事务coordinator发送ack消息</li><li><p>coordinator收到所有participantack消息后，事务失败</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1638453118578.png" alt="enter description here"></p></li></ul><h5 id="4-1-2-3-异常case"><a href="#4-1-2-3-异常case" class="headerlink" title="4.1.2.3 异常case"></a>4.1.2.3 异常case</h5><p>两阶段是不可靠的，存在一下典型问题场景：</p><ul><li><strong>性能问题</strong>：两阶段最大的问题在于，事务执行的过程中，所有participant都处于阻塞状态，数据库连接也被一直占用着，只有当所有节点准备完成，事务coordinator通过global commit或global rollback的时候，资源才能释放。</li><li><strong>coordinator故障</strong>：如果在coordinator在二阶段发送global commit或global rollback之前挂掉了，或者coordinator和participant之间网络出现了异常，会导致participant始终处于事务无法完成的中间状态。</li><li><strong>数据不一致</strong>：如果在coordinator向participant发送global commit后部分participant出现故障，或局部网络出现异常，就会出现部分participant提交了事务，而部分participant没有提交事务，从而出现数据不一致的情况。极限情况下，在coordinator发送commit消息后，coordinator和participant同时宕机了，及时coordinator通过选举协议产生了新的coordinator，这条事务的状态也是不确定的，没有人知道事务最终是否被提交了。</li></ul><h5 id="4-1-2-4-XA事务"><a href="#4-1-2-4-XA事务" class="headerlink" title="4.1.2.4 XA事务"></a>4.1.2.4 XA事务</h5><p>一个全局事务可能写入数据到多个DB实例， InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务。XA事务允许不同数据库之间的分布式事务，例如一台MySQL数据库，一台ORACLE数据库，只要全局事务中每个点都支持XA事务即可。</p><h3 id="4-2-3PC-三阶段提交"><a href="#4-2-3PC-三阶段提交" class="headerlink" title="4.2 3PC(三阶段提交)"></a>4.2 3PC(三阶段提交)</h3><p>三阶段提交把2PC的投票阶段再次一分为二，这样三阶段提交就有canCommit、preCommit、DoCommit三个阶段。将投票阶段一份为二可以保证在预执行之前，所有的participant都具备可执行条件，从而减少资源浪费。回顾两阶段提交，如果coordinator发出prepare消息后，所有participant都将资源锁住，执行事务，进入阻塞状态，但coordinator收到响应后发现有一个participant不能参与，就发出global rollback消息，让其他所有participant进行消息回滚，浪费了大量的资源。</p><h4 id="4-2-1-CanCommit阶段"><a href="#4-2-1-CanCommit阶段" class="headerlink" title="4.2.1 CanCommit阶段"></a>4.2.1 CanCommit阶段</h4><p>3PC的CanCommit阶段和2PC的准备阶段类似，coordinator向participant发送Can-Commit请求，participant认为自身可以完成事务就返回“YES”，否则“NO”。实际应用中，participant可以对自身业务逻辑进行简单校验，判断时候有进行事务的能力。此阶段主要解决了二阶段中部分participant没有执行事务的能力而造成其他事务参与资源浪费的问题。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1638502307552.png" alt="enter description here"></p><h4 id="4-2-2-PreCommit阶段"><a href="#4-2-2-PreCommit阶段" class="headerlink" title="4.2.2 PreCommit阶段"></a>4.2.2 PreCommit阶段</h4><p>此阶段有两种可能情况：</p><ol><li>所有participant都响应YES<br>此情况进入PreCommit阶段进行事务预提交。此时分布式事务coordinator会向所有participant节点发送PreCommit请求，请求这收到后开始执行事务操作，并将Undo和Redo消息记录到事务日志中。participant执行完事务操作但不提交后，向coordinator反馈Ack代表我已经准备好提交了，等待coordinator指令。此阶段和二阶段中的投票阶段工作原理是一致的。</li><li>存在participant响应NO或等待超时后，coordinator没有接收到participant的响应<br>此情况进入Abort阶段。coordinator向所有participant发送Abort请求，participant收到来自coordinator的abort请求（或超时之后，仍未收到coordinator的请求，2PC中只有coordinator有超时机制，participant没有），执行事务中断。</li></ol><h4 id="4-2-3-DoCommit阶段"><a href="#4-2-3-DoCommit阶段" class="headerlink" title="4.2.3 DoCommit阶段"></a>4.2.3 DoCommit阶段</h4><p>如果PreCommit阶段，所有participant都反馈YES并ACK后，coordinator就会从PreCommit到Commit状态，向所有participant发送DoCommit请求，participant在收到提交请求后就会各自执行事务提交操作，并向coordinator反馈ACK消息，coordinator收到所有participant的ack消息后完成事务。同样，如果有部分participant未完成PreCommit反馈或反馈超时，那么coordinator就会向所有participant发送abort请求，中断事务。</p><blockquote><p>相对于2PC，3PC主要解决了单点故障问题，并减少阻塞。在DoCommit阶段，如果participant无法及时接收到来及协调者的doCommit或者abort请求，会在等待超时后，继续进行事务提交。这里其实有两个可能的选择，一是提交，而是回滚。这个是基于平均期望来考虑的，当进入到第三阶段，说明所有participant至少都收到了PreCommit请求，代表这收到所有participant的YES响应，代表大家都能执行事务了，这时候事务被成功执行的概率很大。这里很多同学会想，出现问题，第一时间难道不应该回退吗？其实不然，如果coordinatorfa发出global commit指令，而部分participant由于超时未收到执行了rollback，同样会出现数据不一致的情况，那还不如选择期望更高的超时commit策略。3PC仍然无法完全解决数据一致性的问题，在故障发生时，coordinator和participant的沟通出现问题，就会出现participant动作与coordinator指令不一致的情况，从而导致数据不一样。比如coordinator发送rollback指令，而部分participant没有收到指令，在等待超时后执行了commit指令。</p></blockquote><h2 id="5-补偿事务（TCC）"><a href="#5-补偿事务（TCC）" class="headerlink" title="5. 补偿事务（TCC）"></a>5. 补偿事务（TCC）</h2><p>TCC（Try-Confirm-Cancel）又称补偿事务，其核心思想是针对每个操作都要注册一个与其对应的确认（redo）和补偿（undo）操作。TCC要求组成事务的一系列步骤中，每个步骤都具备可回退能力，一个或多个步骤失败，则撤销该操作。undo操作必须能够撤销原始操作的影响，但补偿事务不能简单地将当前状态替换为系统在操作开始时所处于的状态，因为该方法可能会覆盖应用程序的其他并发实例所做的更改。TCC一个常见的方法是使用workflow的方式来实现最终一致的，需要补偿的操作。随着原始操作的进行，系统时刻记录这每个步骤的信息以及该步骤执行的工作如何撤销。如果操作在任何时候时候，可以通过工作流完成回滚，反转每个步骤的工作。回滚的动作可能会失败，因此回滚的动作必须保证幂等性，在系统故障恢复后能够正确执行补偿事务。</p><blockquote><p>TCC相比与2PC和3PC的优势在于，TCC不需要其他事务参与者支持分布式事务的能力，也不需要coordinator的角色，应用程序可以基于TCC的设计原子，自己保证事务的完整性和可回滚性。同时2PC和3PC只适用于数据库层面的事务，要求所有paticipant具有acid的能力，而TCC能够保证业务层面的事务。TCC的缺点在于对应用的侵入性非常强，所有的事务操作逻辑都需要try、confirm、cancel三个操作，对应用编程实现的难度较大，需要考虑网络异常，系统故障等不同失败原因下的回滚策略。同时为了满足最终一致性的要求，confirm和cancel还必须具备幂等能力。</p></blockquote><h2 id="6-消息队列MQ事务"><a href="#6-消息队列MQ事务" class="headerlink" title="6. 消息队列MQ事务"></a>6. 消息队列MQ事务</h2><p>事务消息适用于异步更新的场景，对数据的实时性要求不高的地方，主要目的是为了解决消息生产者和消息消费者的数据一致性问题。使用消息队列MQ的时候，我们可以采用write ahead和write done的方式来保证事务的一致性。开启事务之前，先发送write ahead消息，告知消息消费者事务开启，随后生产者执行事务，并发送write done消息，如果write done消息发送成功，则可能保证消息消费者能够正确拿到消息，如果write done消息发送失败，则需要消息消费者根据ahead消息维护一个定时器，在超时后通过生产者提供的接口进行资源的反差，确认生产者的事务是否执行成功，并执行相应的消费或放弃操作。这里需要保证ahead消息中包括能够确认资源唯一性的键，通常使用资源主键替代。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1638512362859.png" alt="enter description here"></p><h2 id="7-paxos算法"><a href="#7-paxos算法" class="headerlink" title="7. paxos算法"></a>7. paxos算法</h2><p>无论是2PC还是3PC算法，都无法真正意义上地解决分布式一致性的问题。Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。具体可见<a href="#参考链接">参考链接</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/35616810" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35616810</a></li><li><a href="https://cloud.tencent.com/developer/article/1477464" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1477464</a></li><li><a href="https://www.cnblogs.com/orange-CC/p/13291960.html" target="_blank" rel="noopener">https://www.cnblogs.com/orange-CC/p/13291960.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/31780743" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31780743</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文在将分布式事务之前，会先回顾一下事务的一些基本概念，分布式事务本身与数据库事务的概念是一致的，需要满足事务的ACID原则。单体架构下，我们可以依赖数据库提供的事务能力保证；分布式架构下我们则需要保证一个请求在多个微服务调用链中，所有服务的数据要么全部成功，要么全部回滚，保证多节点数据一致性。分布式事务的实现有很多种方式，主要包括两阶段提交（2PC）、三阶段提交（3PC）、补偿事务（TCC）以及Paxos算法。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://shinerio.cc/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://shinerio.cc/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="分布式" scheme="https://shinerio.cc/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>openssl &amp; keytool</title>
    <link href="https://shinerio.cc/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/openssl%20&amp;%20keytool/"/>
    <id>https://shinerio.cc/2021/10/24/计算机网络/openssl &amp; keytool/</id>
    <published>2021-10-24T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>openssl 是目前最流行的 SSL 密码库工具，其提供了一个通用、健壮、功能完备的工具套件，用以支持SSL/TLS 协议的实现。keytool可以用来管理秘钥和证书，并保存在keystore文件中。<br><a id="more"></a></p><h2 id="1-常见文件格式"><a href="#1-常见文件格式" class="headerlink" title="1. 常见文件格式"></a>1. 常见文件格式</h2><ul><li>.csr 证书签名请求。某些应用程序可以生成这些文件以提交给证书颁发机构。实际格式为PKCS10，它在RFC 2986中定义。它包括所请求证书的一些/全部密钥详细信息，例如主题，组织，状态，诸如此类，以及要签名的证书的公共密钥。这些由CA签名并返回证书。返回的证书是公用证书（包括公用密钥，但不包含专用密钥）</li><li>.pem 在RFC 1421至1424中定义，这是一种容器格式，可以只包含公共证书（例如Apache安装和CA证书文件/etc/ssl/certs），或者可以包括完整的证书链，包括公共密钥，私钥和根证书</li><li>.key 这是PEM格式的文件，仅包含特定证书的私钥。在Apache安装中，该位置通常位于中/etc/ssl/private。这些文件的权限非常重要，如果设置错误，某些程序将拒绝加载这些证书。</li><li>.pkcs12 .pfx .p12 最初由RSA在“ 公钥密码标准”（缩写为PKCS）中定义，“ 12”变体最初由Microsoft增强，后来提交为RFC 7292。这是包含公共和私有证书对的密码容器格式。与.pem文件不同，此容器是完全加密的。Openssl可以使用公钥和私钥将其转换为.pem文件：openssl pkcs12 -in file-to-convert.p12 -out converted-file.pem -nodes</li></ul><p>除此之外，还有几种其他几种格式：</p><ul><li>.der-一种以二进制形式编码ASN.1语法的方法，.pem文件只是Base64编码的.der文件。OpenSSL可以将它们转换为.pem（openssl x509 -inform der -in to-convert.der -out converted.pem）。Windows将这些视为证书文件。默认情况下，Windows会将证书导出为扩展名为.DER格式的文件。</li><li>.cert .cer .crt都是.pem（或很少是.der）格式的文件，具有不同的扩展名，Windows Explorer将其识别为证书，而.pem则不是。</li><li>.p7b .keystore 在RFC 2315中定义为PKCS 7，这是Windows用于证书交换的一种格式。Java本身了解这些内容，因此通常将其.keystore用作扩展。与.pem样式证书不同，此格式具有定义的方式来包括证书路径证书。</li><li>.crl-证书吊销列表。证书颁发机构产生这些证书是作为在到期之前取消对证书进行授权的一种方式。有时您可以从CA网站下载它们。</li></ul><h2 id="2-自签ssl证书"><a href="#2-自签ssl证书" class="headerlink" title="2. 自签ssl证书"></a>2. 自签ssl证书</h2><p>自签名SSL证书是由创建它的人而不是受信任的证书颁发机构签名的证书。自签名证书可以与受信任的CA签名SSL证书具有相同的加密级别。被任何浏览器识别为有效的自签名证书。如果您使用的是自签名证书，则网络浏览器将向访问者显示警告，提示该网站证书无法验证。<br>自签名证书主要用于测试目的或内部使用，不应该在暴露于Internet的生产系统中使用自签名证书。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:4096 \</span><br><span class="line">            -x509 \</span><br><span class="line">            -sha256 \</span><br><span class="line">            -days 3650 \</span><br><span class="line">            -nodes \</span><br><span class="line">            -out example.crt \</span><br><span class="line">            -keyout example.key \</span><br><span class="line">-subj "/C=CN/ST=BEIJING/L=BEIJING/O=SHINERIO/OU=SHINERIO/CN=www.shinerio.cc"</span><br></pre></td></tr></table></figure><ul><li>-newkey rsa:4096 创建新的证书请求和4096位RSA密钥。默认值为2048位。</li><li>-x509 创建X.509证书。</li><li>-sha256 使用265位SHA（安全哈希算法）。</li><li>-days 3650 认证证书的天数。 3650是10年。</li><li>-nodes 创建没有密码的密钥。</li><li>-out example.crt 指定新创建的证书的文件名。</li><li>-keyout example.key 指定新创建的私钥的文件名。</li><li>-subj 证书信息=<ul><li>C= 国家/地区名称。 ISO的两个字母缩写。</li><li>ST= 州或省名。</li><li>L= 地区名称。您所在的城市的名称。</li><li>O= 您组织的全名。</li><li>OU= 组织单位。</li><li>CN= 完全限定的域名。</li></ul></li></ul><blockquote><p>如上导出的example.crt即为证书(公钥)，.key为私钥公私钥都是明文存储的。</p></blockquote><h3 id="2-1-私钥加密"><a href="#2-1-私钥加密" class="headerlink" title="2.1 私钥加密"></a>2.1 私钥加密</h3><h4 id="2-1-1-创建加密的私钥"><a href="#2-1-1-创建加密的私钥" class="headerlink" title="2.1.1 创建加密的私钥"></a>2.1.1 创建加密的私钥</h4><p>openssl genrsa -des3 -out example.key 1024</p><ul><li>-des3:生成的密钥使用des3方式进行加密。</li><li>-out private-rsa.key:将生成的私钥保存至example.key文件。</li><li>1024为要生成的私钥的长度。</li></ul><h4 id="2-1-2-使用已有私钥创建ssl证书"><a href="#2-1-2-使用已有私钥创建ssl证书" class="headerlink" title="2.1.2 使用已有私钥创建ssl证书"></a>2.1.2 使用已有私钥创建ssl证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new \</span><br><span class="line">            -key example.key \</span><br><span class="line">            -x509 \</span><br><span class="line">            -sha256 \</span><br><span class="line">            -days 3650 \</span><br><span class="line">            -out example.crt \</span><br><span class="line">            -keyout example.key \</span><br><span class="line">-subj "/C=CN/ST=BEIJING/L=BEIJING/O=SHINERIO/OU=SHINERIO/CN=www.shinerio.cc"</span><br></pre></td></tr></table></figure><h5 id="2-1-3-直接创建有密码的ssl证书"><a href="#2-1-3-直接创建有密码的ssl证书" class="headerlink" title="2.1.3 直接创建有密码的ssl证书"></a>2.1.3 直接创建有密码的ssl证书</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:4096 \</span><br><span class="line">            -x509 \</span><br><span class="line">            -sha256 \</span><br><span class="line">            -days 3650 \</span><br><span class="line">            -out example.crt \</span><br><span class="line">            -keyout example.key \</span><br><span class="line">-subj "/C=CN/ST=BEIJING/L=BEIJING/O=SHINERIO/OU=SHINERIO/CN=www.shinerio.cc"</span><br></pre></td></tr></table></figure><h2 id="2-2-查看私钥明细"><a href="#2-2-查看私钥明细" class="headerlink" title="2.2 查看私钥明细"></a>2.2 查看私钥明细</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in example.key -noout -text</span><br></pre></td></tr></table></figure><h2 id="2-3-转换命令"><a href="#2-3-转换命令" class="headerlink" title="2.3 转换命令"></a>2.3 转换命令</h2><ul><li>加密私钥转非加密</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in example.key -passin pass:shinerio -out example_unencrypt.key</span><br></pre></td></tr></table></figure><ul><li><p>非加密私钥转加密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in example_unencrypt.key -aes256 -passout pass:shinerio -out example_encrypt.key</span><br></pre></td></tr></table></figure></li><li><p>修改密码</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in example.key -passin pass:shinerio -aes256 -passout pass:shinerio_new -out example.key</span><br></pre></td></tr></table></figure><h2 id="3-生成签名请求及CA-签名"><a href="#3-生成签名请求及CA-签名" class="headerlink" title="3. 生成签名请求及CA 签名"></a>3. 生成签名请求及CA 签名</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -passout pass:shinerio -out server.key 2048</span><br><span class="line">openssl req -new \</span><br><span class="line">                        -key server.key \</span><br><span class="line">-passin pass:shinerio -out server.csr \</span><br><span class="line">            -subj "/C=CN/ST=BEIJING/L=BEIJING/O=SHINERIO/OU=SHINERIO/CN=www.shinerio.cc"</span><br></pre></td></tr></table></figure><p> 生成的 csr签名请求文件可提交至 CA进行签发。使用 CA 证书及CA密钥对请求签发证书进行签发，生成 x509证书</p><p>openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -passin pass:shinerio -CAcreateserial -out server.crt</p><h3 id="3-1合成-pkcs-12-证书-含私钥"><a href="#3-1合成-pkcs-12-证书-含私钥" class="headerlink" title="3.1合成 pkcs#12 证书(含私钥)"></a>3.1合成 pkcs#12 证书(含私钥)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:shinerio -password pass:shinerio -out server.p12</span><br></pre></td></tr></table></figure><h3 id="3-2-将证书和私钥-CA-证书-合成pkcs-12-证书"><a href="#3-2-将证书和私钥-CA-证书-合成pkcs-12-证书" class="headerlink" title="3.2 将证书和私钥/CA 证书 合成pkcs#12 证书"></a>3.2 将证书和私钥/CA 证书 合成pkcs#12 证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:shinerio -chain -CAfile ca.crt -password pass:shinerio -out server-all.p12</span><br></pre></td></tr></table></figure><p>其中-chain指示同时添加证书链，-CAfile 指定了CA证书，导出的p12文件将包含多个证书。(其他选项：-name可用于指定server证书别名；-caname用于指定ca证书别名)</p><h3 id="3-3-pcks-12-提取PEM文件-含私钥"><a href="#3-3-pcks-12-提取PEM文件-含私钥" class="headerlink" title="3.3 pcks#12 提取PEM文件(含私钥)"></a>3.3 pcks#12 提取PEM文件(含私钥)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in server.p12 -password pass:shinerio -passout pass:shinerio -out server.pem</span><br></pre></td></tr></table></figure><p>其中-password 指定 p12文件的密码(导入导出)，-passout指输出私钥的加密密码(nodes为无加密)，导出的文件为pem格式，同时包含证书和私钥。</p><ul><li><p>仅提取私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in server.p12 -password pass:shinerio -passout pass:shinerio -nocerts -out key.pem</span><br></pre></td></tr></table></figure></li><li><p>仅提取证书(所有证书)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in server.p12 -password pass:shinerio -nokeys -out all_certs.pem</span><br></pre></td></tr></table></figure></li><li><p>仅提取ca证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in server-all.p12 -password pass:shinerio -nokeys -cacerts -out cacert.pem</span><br></pre></td></tr></table></figure></li><li><p>仅提取server证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in server-all.p12 -password pass:111111 -nokeys -clcerts -out srever.pem</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-JKS"><a href="#4-JKS" class="headerlink" title="4. JKS"></a>4. JKS</h2><p>JKS（Java Key Store）就是利用Java Keytool 工具生成的Keystore文件，JKS文件由公钥和密钥构成，其中的公钥就是我们所说的证书，即cer为后缀的文件，而私钥就是密钥，即以key为后缀的文件。</p><h3 id="4-1-生成jks文件"><a href="#4-1-生成jks文件" class="headerlink" title="4.1 生成jks文件"></a>4.1 生成jks文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -keyalg rsa -keysize 2048 -storetype JKS -alias cert -keypass shinerio -validity 3650 -storepass shinerio -keystore D:/example.jks -dname "CN=shinerio.cc, OU=shinerio, O=shinerio, L=BEIJING, ST=BEIJING, C=CN"</span><br></pre></td></tr></table></figure><p><strong>选项:</strong></p><ul><li>-alias <alias>                  要处理的条目的别名</alias></li><li>-keyalg <keyalg>                密钥算法名称</keyalg></li><li>-keysize <keysize>              密钥位大小</keysize></li><li>-sigalg <sigalg>                签名算法名称</sigalg></li><li>-destalias <destalias>          目标别名</destalias></li><li>-dname <dname>                  唯一判别名</dname></li><li>-startdate <startdate>          证书有效期开始日期/时间</startdate></li><li>-ext <value>                    X.509 扩展</value></li><li>-validity <valdays>             有效天数</valdays></li><li>-keypass <arg>                  密钥口令</arg></li><li>-keystore <keystore>            密钥库名称</keystore></li><li>-storepass <arg>                密钥库口令</arg></li><li>-storetype <storetype>          密钥库类型</storetype></li><li>-providername <providername>    提供方名称</providername></li><li>-providerclass <providerclass>  提供方类名</providerclass></li><li>-providerarg <arg>              提供方参数</arg></li><li>-providerpath <pathlist>        提供方类路径</pathlist></li><li>-v                              详细输出</li><li>-protected                      通过受保护的机制的口令</li><li>-storepasswd  修改keystore密码</li><li>-keypasswd   更改指定证书的密钥口令</li></ul><p>使用 “keytool -help” 获取所有可用命令</p><h3 id="4-2-列出keystore中的证书"><a href="#4-2-列出keystore中的证书" class="headerlink" title="4.2 列出keystore中的证书"></a>4.2 列出keystore中的证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore D:/example.jks -storepass shinerio</span><br></pre></td></tr></table></figure><h3 id="4-3-查看指定证书详情"><a href="#4-3-查看指定证书详情" class="headerlink" title="4.3 查看指定证书详情"></a>4.3 查看指定证书详情</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -alias cert -keystore D:/example.jks -storepass shinerio</span><br></pre></td></tr></table></figure><h3 id="4-4-删除指定证书"><a href="#4-4-删除指定证书" class="headerlink" title="4.4 删除指定证书"></a>4.4 删除指定证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -delete -keystore D:/example -alias cert -storepass shinerio</span><br></pre></td></tr></table></figure><h3 id="4-5-修改keystore密码"><a href="#4-5-修改keystore密码" class="headerlink" title="4.5 修改keystore密码"></a>4.5 修改keystore密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -storepasswd -keystore D:/example.jks -storepass shinerio</span><br></pre></td></tr></table></figure><h3 id="4-6-修改指定证书密码"><a href="#4-6-修改指定证书密码" class="headerlink" title="4.6 修改指定证书密码"></a>4.6 修改指定证书密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -keypasswd -alias cert -keystore D:/example.jks -storepass shinerio</span><br></pre></td></tr></table></figure><blockquote><p>如果 -storetype 为 PKCS12, 则不支持 -keypasswd 命令</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;openssl 是目前最流行的 SSL 密码库工具，其提供了一个通用、健壮、功能完备的工具套件，用以支持SSL/TLS 协议的实现。keytool可以用来管理秘钥和证书，并保存在keystore文件中。&lt;br&gt;
    
    </summary>
    
      <category term="网络安全" scheme="https://shinerio.cc/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="linux" scheme="https://shinerio.cc/tags/linux/"/>
    
      <category term="网络安全" scheme="https://shinerio.cc/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="加密" scheme="https://shinerio.cc/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之route</title>
    <link href="https://shinerio.cc/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/linux%E5%91%BD%E4%BB%A4%E4%B9%8Broute/"/>
    <id>https://shinerio.cc/2021/10/24/计算机网络/linux命令之route/</id>
    <published>2021-10-24T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>计算机或网络设置使用路由表用来计算数据包的下一跳。 route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p><a id="more"></a><h2 id="1-查看路由表"><a href="#1-查看路由表" class="headerlink" title="1. 查看路由表"></a>1. 查看路由表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -r </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">route -n</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635056397569.png" alt></p><blockquote><p>windows使用route print</p></blockquote><h2 id="2-字段解释"><a href="#2-字段解释" class="headerlink" title="2. 字段解释"></a>2. 字段解释</h2><div class="table-container"><table><thead><tr><th>列名</th><th>作用</th></tr></thead><tbody><tr><td>Destination</td><td>目的地址</td></tr><tr><td>Gateway</td><td>网关地址，如果未设置则为*</td></tr><tr><td>Genmask</td><td>目的地址子网掩码，0.0.0.0为default</td></tr><tr><td>Flags</td><td>标记</td></tr><tr><td>Metric</td><td>路由距离(一般是到下一跳的跳数)，是大型局域网和广域网设置所必需的(linux内核不使用)</td></tr><tr><td>Ref</td><td>路由项引用次数(linux内核不使用)</td></tr><tr><td>Use</td><td>路由表被查找的次数</td></tr><tr><td>Iface</td><td>数据包将被发往的网口</td></tr></tbody></table></div><p><strong>flags可选项</strong></p><ul><li>U  路由启动</li><li>H  目标是个主机</li><li>G  需要经过网关</li><li>R  恢复动态路由产生的表象</li><li>D  由路由的后台程序动态安装</li><li>M  由路由的后台程序修改</li><li>！ 拒绝路由</li></ul><h2 id="3-路由分类"><a href="#3-路由分类" class="headerlink" title="3. 路由分类"></a>3. 路由分类</h2><h3 id="3-1-主机路由"><a href="#3-1-主机路由" class="headerlink" title="3.1 主机路由"></a>3.1 主机路由</h3><p>到达单个ip或主机的路由，主机路由可以动态决定每个网络地址的路由，可以用来自动以控制或者调优特定类型的网络流量</p><h3 id="3-2-网络路由"><a href="#3-2-网络路由" class="headerlink" title="3.2 网络路由"></a>3.2 网络路由</h3><p>到达特定network ID的路由</p><h3 id="3-3-默认路由"><a href="#3-3-默认路由" class="headerlink" title="3.3 默认路由"></a>3.3 默认路由</h3><p>当目的地址在路由表中没有被匹配时，将匹配默认路由</p><h2 id="4-route命令详解"><a href="#4-route命令详解" class="headerlink" title="4. route命令详解"></a>4. route命令详解</h2><p>route命令的格式如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route [-Options] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]</span><br></pre></td></tr></table></figure></p><p><strong>Options</strong></p><ul><li>-c 显示更多信息</li><li>-n 不解析名字</li><li>-v 显示详细的处理信息</li><li>-F 显示发送信息</li><li>-C 显示路由缓存</li><li>-f 清除所有网关入口的路由表。 </li></ul><p><strong>Command</strong></p><ul><li>add  添加一条新路由</li><li>del 删除一条路由</li></ul><h3 id="4-1-增加一条主机路由"><a href="#4-1-增加一条主机路由" class="headerlink" title="4.1 增加一条主机路由"></a>4.1 增加一条主机路由</h3><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635058414021.png" alt="enter description here"></p><h3 id="4-2-增加一条网络路由"><a href="#4-2-增加一条网络路由" class="headerlink" title="4.2 增加一条网络路由"></a>4.2 增加一条网络路由</h3><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635058504391.png" alt="enter description here"></p><h3 id="4-3-添加或删除默认网关"><a href="#4-3-添加或删除默认网关" class="headerlink" title="4.3 添加或删除默认网关"></a>4.3 添加或删除默认网关</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route del default gw 64.64.236.1</span><br><span class="line">route add default gw 64.64.236.1</span><br></pre></td></tr></table></figure><h3 id="4-4-添加直连地址"><a href="#4-4-添加直连地址" class="headerlink" title="4.4 添加直连地址"></a>4.4 添加直连地址</h3><p>网关是0.0.0.0，表示目的网段不需要经过路由，是一个直连地址</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635058773611.png" alt="enter description here"></p><h3 id="4-4-屏蔽地址"><a href="#4-4-屏蔽地址" class="headerlink" title="4.4 屏蔽地址"></a>4.4 屏蔽地址</h3><p>屏蔽到10网段的数据包</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635058907250.png" alt="enter description here"></p><h3 id="4-5-删除路由"><a href="#4-5-删除路由" class="headerlink" title="4.5 删除路由"></a>4.5 删除路由</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route del -net 10.0.0.0 netmask 255.0.0.0 reject  # 删除屏蔽路由</span><br><span class="line">route del -net 64.64.236.100 netmask 255.255.255.255 # 删除主机路由</span><br><span class="line">route del -net 64.64.236.128 netmask 255.255.255.192 # 删除网络路由</span><br><span class="line"> route del -net 192.168.0.0 netmask 255.255.0.0 # 删除直连地址</span><br><span class="line"> route -n</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1635056397569.png" alt></p><h2 id="5-持久化路由"><a href="#5-持久化路由" class="headerlink" title="5. 持久化路由"></a>5. 持久化路由</h2><p>使用route添加的路由并不会永久生效，在主机重启后就会丢失。可以利用/etc/rc.local文件，linux会在开机之后自动source执行/etc/rc.local，达到永久保存路由的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机或网络设置使用路由表用来计算数据包的下一跳。 route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://shinerio.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="linux" scheme="https://shinerio.cc/tags/linux/"/>
    
      <category term="计算机网络" scheme="https://shinerio.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="network" scheme="https://shinerio.cc/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="https://shinerio.cc/2021/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/iptables/"/>
    <id>https://shinerio.cc/2021/10/17/计算机网络/iptables/</id>
    <published>2021-10-17T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>iptables 是 Linux 防火墙工作在用户空间的管理工具，是 netfilter/iptablesIP 数据包过滤系统是一部分，用来设置、维护和检查 Linux 内核的 IP 数据包过滤规则。</p><a id="more"></a><h2 id="1-四表五链"><a href="#1-四表五链" class="headerlink" title="1. 四表五链"></a>1. 四表五链</h2><p>数据包在经过每个的时候会按照每个链对应的表依次进行查询匹配执行的操作，如PREROUTING链对应的就是(raw-&gt;mangle-&gt;nat)，每个表按照优先级顺序进行连接，每个表中还可能有多个规则，最终形成一条处理链。iptables的表中存储的就是对应的规则和需要执行的操作。</p><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1634463829447.png" alt="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"></p><h3 id="1-1-四表"><a href="#1-1-四表" class="headerlink" title="1.1 四表"></a>1.1 四表</h3><ol><li>raw<br>主要用来决定是否对数据包进行状态跟踪，对应的内核模块为iptable_raw。raw表只使用在PREROUTING链和OUTPUT链上，因为优先级最高，从而可以对收到的数据包在系统进行ip_conntrack（连接跟踪）前进行处理。一旦用户使用了raw表，在某个链上，raw表处理完后，将跳过NAT表和ip_conntrack处理，即不再做地址转换和数据包的链接跟踪处理了。RAW表可以应用在那些不需要做nat的情况下，以提高性能。</li><li>mangle<br>主要用来修改数据包的服务类型，生存周期，为数据包设置标记，实现流量整形、策略路由等，对应内核模块miptable_mangle</li><li>nat<br> 主要用来进行网络地址转换，修改数据包的 IP 地址、端口号信息，对应内核模块iptable_nat。</li><li>filter<br>用来对数据包进行过滤，具体的规则要求决定如何处理一个数据包，对应内核模块iptable_filter</li></ol><blockquote><p>表的处理优先级：raw&gt;mangle&gt;nat&gt;filter</p></blockquote><h3 id="1-2-五链"><a href="#1-2-五链" class="headerlink" title="1.2  五链"></a>1.2  五链</h3><ol><li>PREROUTING<br>在对数据包做路由选择之前，将应用此链中的规则</li><li>INPUT<br>当收目的地址为本机的数据包时，将应用此链中的规则；</li><li>FORWARD<br>当收到目的地址非本机的数据包时，将应用此链中的规则。Forward转发需要开启Linux内核中的ip_forward功能。</li><li>OUTPUT<br>当本机向外发送数据包时，将应用此链中的规则</li><li>POSTROUTING<br>在对数据包做路由选择之后，将应用此链中的规则</li></ol><blockquote><p>cat /proc/sys/net/ipv4/ip_forward查看是否开启ip_forward功能。0表示没有启动，1表示已经启动</p></blockquote><h2 id="2-iptables使用"><a href="#2-iptables使用" class="headerlink" title="2. iptables使用"></a>2. iptables使用</h2><h3 id="2-1-命令"><a href="#2-1-命令" class="headerlink" title="2.1 命令"></a>2.1 命令</h3><p>iptables的基本语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t 表名] 管理选项 [链名] [匹配条件] [-j 控制类型]</span><br></pre></td></tr></table></figure><ul><li>表名<br>raw/mangle/nat/filter，默认为filter</li><li>管理选项<ul><li>-A:在指定链的末尾添加一条新的规则</li><li>-D:删除指定链中的某一条规则，可删除指定序号或具体内容</li><li>-I:在指定链中插入一条新规则，未指定序号时默认作为第一条规则</li><li>-R:修改、替换指定链中的某一条规则，可指定规则序号或具体内容</li><li>-L:列出指定链中所有的规则，未指定链名，则列出表中的所有链</li><li>-F:清空指定链中所有的规则，未指定链名，则清空表中的所有链</li><li>-P:设置指定链的默认策略</li><li>-n:使用数字形式显示输出结果</li><li>-v:查看规则列表时显示详细的信息</li><li>-h:查看命令帮助信息</li><li>—line-numbers:查看规则列表时，同时显示规则在链中的顺序号</li></ul></li><li>链名<br>RREROUTING/INPUT/FORWARD/OUTPUT/POSTROUTING</li><li>匹配条件<ul><li>-s 指定源地址或网段，逗号隔开</li><li>-d 指定目的地址或网段，逗号隔开</li><li>! 取反，如! -s 192.168.0.200，表示源地址不是192.168.0.200的都匹配。取反操作是-s和-d选项不能同时指定多个</li><li>-p协议。tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh或all</li><li>-i，指定流入数据包网卡，-i eth0，匹配从eth0流入的数据包，只能用于PREROUTING/INPUT/FORWARD</li><li>-o，指定流出数据包网卡，-i eth0，匹配从eth0流出的数据包，只能用于FORWARD/OUTPUT/POSTROUTING</li><li>—sport，指定源端口，支持范围。如—sport 10000:20000</li><li>—dport，指定目的端口，支持范围。如—port 10000:20000</li><li>—m multiport，支持指定多个端口。如 —m multiport —sports 22,10000:20000</li></ul></li><li>控制类型<ul><li>接收ACCEPT</li><li>拒绝REJECT</li><li>丢弃DROP</li><li>日志LOG</li></ul></li></ul><blockquote><p>REJECT和DROP的区别。<br>REJECT动作会返回一个拒绝(终止)数据包(TCP FIN或UDP-ICMP-PORT-UNREACHABLE)，明确的拒绝对方的连接动作。连接马上断开，Client会认为访问的主机不存在。<br>DROP动作只是简单的直接丢弃数据，并不反馈任何回应。需要Client等待超时，Client容易发现自己被防火墙所阻挡。</p></blockquote><p><strong>示例</strong></p><ol><li>丢且来自x.x.x.x的数据包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLOCK_THIS_IP="x.x.x.x"</span><br><span class="line">iptables -A INPUT -s "$BLOCK_THIS_IP" -j DROP</span><br></pre></td></tr></table></figure><ol><li>阻止来自IP地址x.x.x.x eth0 tcp的包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLOCK_THIS_IP="x.x.x.x"</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s "$BLOCK_THIS_IP" -j DROP</span><br></pre></td></tr></table></figure><ol><li>允许来自eth0的所有SSH的连接请求，并且目标端口为22的数据包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><ol><li>不允许外部主机ping内部主机</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j DROP</span><br><span class="line">iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP</span><br></pre></td></tr></table></figure><ol><li>允许内部主机ping外部主机</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="2-2-日志"><a href="#2-2-日志" class="headerlink" title="2.2 日志"></a>2.2 日志</h3><p>对于INPUT链中的所有操作都记录到日志中，添加日志前缀<strong><em> INPUT </em></strong> 并设定日志级别为debug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -j LOG --log-prefix "*** INPUT ***" --log-level debug</span><br></pre></td></tr></table></figure><h3 id="2-3-自定义链"><a href="#2-3-自定义链" class="headerlink" title="2.3 自定义链"></a>2.3 自定义链</h3><p>通过-N参数创建自定义链，将BLOCK链作为控制目标，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -N BLOCK</span><br><span class="line">iptables -A BLOCK -p tcp -s 10.1.1.92/32 --dport 80 -j DROP</span><br><span class="line">iptables -I INPUT 1 -p tcp --dport 80 -j BLOCK</span><br></pre></td></tr></table></figure><p>INPUT链中匹配规则1的包都会转入BLOCK链中，若到达了BLOCK链的结尾（即未被链中的规则匹配），则会回到INPUT链的下一条规则。如果在子链中匹配了，则就相当于在父链中匹配了，那么它不会再经过父链中的其他规则。</p><blockquote><p>iptables -X BLOCK，删除自定义链，iptable -E BLOCK BLOCK_NEW重命名</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iptables 是 Linux 防火墙工作在用户空间的管理工具，是 netfilter/iptablesIP 数据包过滤系统是一部分，用来设置、维护和检查 Linux 内核的 IP 数据包过滤规则。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://shinerio.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://shinerio.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="network" scheme="https://shinerio.cc/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump</title>
    <link href="https://shinerio.cc/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcpdump/"/>
    <id>https://shinerio.cc/2020/08/09/计算机网络/tcpdump/</id>
    <published>2020-08-09T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.759Z</updated>
    
    <content type="html"><![CDATA[<p>tcpdump是一个优秀的网络分析工具，提供了强大且简单的接口。</p><a id="more"></a><h2 id="1-options"><a href="#1-options" class="headerlink" title="1. options"></a>1. options</h2><ul><li><strong>-i any</strong> 监听所有的网卡接口，用来查看是否有网络流量</li><li><strong>-i eth0</strong> 只监听eth0网卡接口</li><li><strong>-D</strong> 显示可用的接口列表</li><li><strong>-n</strong> 不要解析主机名</li><li><strong>-nn</strong> 不要解析主机名或者端口名</li><li><strong>-q</strong> 显示更少的输出(更加quiet)</li><li><strong>-t</strong> 输出可读的时间戳</li><li><strong>-tttt</strong> 输出最大程度可读的时间戳</li><li><strong>-X</strong> 以hex和ASCII两种形式显示包的内容</li><li><strong>-XX</strong> 与<strong>-X</strong>类似，增加以太网header的显示</li><li><strong>-v, -vv, -vvv</strong> 显示更加多的包信息</li><li><strong>-c</strong> 只读取x个包，然后停止</li><li><strong>-s</strong> 指定每一个包捕获的长度，单位是byte，使用<code>-s0</code>可以捕获整个包的内容</li><li><strong>-S</strong> 输出绝对的序列号</li><li><strong>-e</strong> 获取以太网header</li><li><strong>-E</strong> 使用提供的秘钥解密IPSEC流量</li></ul><h2 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h2><h3 id="2-1-监听所有网卡接口"><a href="#2-1-监听所有网卡接口" class="headerlink" title="2.1 监听所有网卡接口"></a>2.1 监听所有网卡接口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i any</span><br></pre></td></tr></table></figure><h3 id="2-2-监听制定网卡接口"><a href="#2-2-监听制定网卡接口" class="headerlink" title="2.2 监听制定网卡接口"></a>2.2 监听制定网卡接口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0</span><br></pre></td></tr></table></figure><h3 id="2-3-显示可用接口列表"><a href="#2-3-显示可用接口列表" class="headerlink" title="2.3 显示可用接口列表"></a>2.3 显示可用接口列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -D</span><br></pre></td></tr></table></figure><h3 id="2-4-指定ip"><a href="#2-4-指定ip" class="headerlink" title="2.4 指定ip"></a>2.4 指定ip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 8.8.8.8</span><br></pre></td></tr></table></figure><p>08:12:42.050004 IP 64.64.238.73.16clouds.com &gt; dns.google: ICMP echo request, id 27320, seq 1, length 64<br>08:12:42.059723 IP dns.google &gt; 64.64.238.73.16clouds.com: ICMP echo reply, id 27320, seq 1, length 64<br>08:12:43.050762 IP 64.64.238.73.16clouds.com &gt; dns.google: ICMP echo request, id 27320, seq 2, length 64<br>08:12:43.051410 IP dns.google &gt; 64.64.238.73.16clouds.com: ICMP echo reply, id 27320, seq 2, length 64<br>08:12:44.058965 IP 64.64.238.73.16clouds.com &gt; dns.google: ICMP echo request, id 27320, seq 3, length 64<br>08:12:44.059281 IP dns.google &gt; 64.64.238.73.16clouds.com: ICMP echo reply, id 27320, seq 3, length 64</p><h3 id="2-5-显示绝对序列号"><a href="#2-5-显示绝对序列号" class="headerlink" title="2.5 显示绝对序列号"></a>2.5 显示绝对序列号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -S host google.com</span><br></pre></td></tr></table></figure><p>08:39:14.977056 IP 64.64.238.73.16clouds.com.56270 &gt; lax31s12-in-f14.1e100.net.https: Flags [P.], seq 1389390438:1389390527, ack 2289481827, win 292, options [nop,nop,TS val 2079502004 ecr 4062705777], length 89<br>08:39:14.977429 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [P.], seq 2289481827:2289481858, ack 1389390527, win 240, options [nop,nop,TS val 4062731918 ecr 2079502004], length 31<br>08:39:14.977457 IP 64.64.238.73.16clouds.com.56270 &gt; lax31s12-in-f14.1e100.net.https: Flags [P.], seq 1389390527:1389390822, ack 2289481858, win 292, options [nop,nop,TS val 2079502005 ecr 4062731918], length 295<br>08:39:14.982669 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [.], ack 1389390822, win 244, options [nop,nop,TS val 4062731923 ecr 2079502005], length 0<br>08:39:15.016514 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [P.], seq 2289481858:2289482742, ack 1389390822, win 244, options [nop,nop,TS val 4062731957 ecr 2079502005], length 884<br>08:39:15.016558 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [P.], seq 2289482742:2289484160, ack 1389390822, win 244, options [nop,nop,TS val 4062731957 ecr 2079502005], length 1418<br>08:39:15.016578 IP 64.64.238.73.16clouds.com.56270 &gt; lax31s12-in-f14.1e100.net.https: Flags [.], ack 2289484160, win 337, options [nop,nop,TS val 2079502044 ecr 4062731957], length 0<br>08:39:15.016593 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [P.], seq 2289484160:2289484819, ack 1389390822, win 244, options [nop,nop,TS val 4062731957 ecr 2079502005], length 659<br>08:39:15.016603 IP lax31s12-in-f14.1e100.net.https &gt; 64.64.238.73.16clouds.com.56270: Flags [P.], seq 2289484819:2289486237, ack 1389390822, win 244, options [nop,nop,TS val 4062731957 ecr 2079502005], length 1418<br>08:39:15.016608 IP 64.64.238.73.16clouds.com.56270 &gt; lax31s12-in-f14.1e100.net.https: Flags [.], ack 2289486237, win 382, options [nop,nop,TS val 2079502044 ecr 4062731957], length 0</p><ul><li>seq为tcp报文的序列号，按包内数据字节长度加上，如包内数据是21字节，而当前IP1发到IP2的包的seq是10的话，那下个IP1发到IP2的包的seq就是10+21=31</li><li>ack为已经收到的报文的序列号，告诉对方下次从seq=ack处继续发报文</li><li>win是剩余窗口大小，如win=0，表示窗口已满，告知对方暂停发包</li></ul><h3 id="2-6-不解析ip和端口号"><a href="#2-6-不解析ip和端口号" class="headerlink" title="2.6 不解析ip和端口号"></a>2.6 不解析ip和端口号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host 8.8.8.8</span><br></pre></td></tr></table></figure><p>08:46:48.586465 IP 64.64.238.73 &gt; 8.8.8.8: ICMP echo request, id 27537, seq 1, length 64<br>08:46:48.586921 IP 8.8.8.8 &gt; 64.64.238.73: ICMP echo reply, id 27537, seq 1, length 64<br>08:46:49.594835 IP 64.64.238.73 &gt; 8.8.8.8: ICMP echo request, id 27537, seq 2, length 64<br>08:46:49.596609 IP 8.8.8.8 &gt; 64.64.238.73: ICMP echo reply, id 27537, seq 2, length 64<br>08:46:50.594823 IP 64.64.238.73 &gt; 8.8.8.8: ICMP echo request, id 27537, seq 3, length 64<br>08:46:50.595311 IP 8.8.8.8 &gt; 64.64.238.73: ICMP echo reply, id 27537, seq 3, length 64</p><h3 id="2-7-指定协议"><a href="#2-7-指定协议" class="headerlink" title="2.7 指定协议"></a>2.7 指定协议</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump icmp</span><br></pre></td></tr></table></figure><h3 id="2-8-指定源或目的地址"><a href="#2-8-指定源或目的地址" class="headerlink" title="2.8 指定源或目的地址"></a>2.8 指定源或目的地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump src 64.64.238.73</span><br><span class="line">tcpdump dst 8.8.8.8</span><br></pre></td></tr></table></figure><h3 id="2-9-指定子网"><a href="#2-9-指定子网" class="headerlink" title="2.9 指定子网"></a>2.9 指定子网</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump net 192.168.0.0/16</span><br></pre></td></tr></table></figure><h3 id="2-10-指定端口范围"><a href="#2-10-指定端口范围" class="headerlink" title="2.10 指定端口范围"></a>2.10 指定端口范围</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump portrange 0-5000</span><br></pre></td></tr></table></figure><h3 id="2-11基于包的大小过滤流量"><a href="#2-11基于包的大小过滤流量" class="headerlink" title="2.11基于包的大小过滤流量"></a>2.11基于包的大小过滤流量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump less 32</span><br><span class="line">tcpdump greater 64</span><br><span class="line">tcpdump &lt;=128</span><br></pre></td></tr></table></figure><h3 id="2-12-读取指定数量的包"><a href="#2-12-读取指定数量的包" class="headerlink" title="2.12 读取指定数量的包"></a>2.12 读取指定数量的包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -c 10</span><br></pre></td></tr></table></figure><h3 id="3-导入-导出"><a href="#3-导入-导出" class="headerlink" title="3. 导入/导出"></a>3. 导入/导出</h3><p>可以使用-w导出成PCAP，使用wireshark等可视化工具打开，或使用-r导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -c 10 -w test.pcap</span><br><span class="line">tcpdump -r test.pcap</span><br></pre></td></tr></table></figure><h2 id="4-组合"><a href="#4-组合" class="headerlink" title="4. 组合"></a>4. 组合</h2><ul><li>AND: <strong>and</strong> or <strong>&amp;&amp;</strong></li><li>OR: <strong>or</strong> or <strong>||</strong></li><li>EXCEPT: <strong>not</strong> or !</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nnvvS src 10.5.2.3 and dst port 3389</span><br><span class="line">tcpdump -nvX src net 192.168.0.0/16 and dst net 10.0.0.0/8 or 172.16.0.0/16</span><br><span class="line">tcpdump dst 192.168.0.2 and src net and not icmp</span><br><span class="line">tcpdump <span class="string">'src 10.0.2.3 and (dst port 3389 or 22)'</span></span><br></pre></td></tr></table></figure><h2 id="5-指定的TCP标识"><a href="#5-指定的TCP标识" class="headerlink" title="5. 指定的TCP标识"></a>5. 指定的TCP标识</h2><h3 id="5-1-显示所有的URGENT-URG-包"><a href="#5-1-显示所有的URGENT-URG-包" class="headerlink" title="5.1 显示所有的URGENT (URG)包"></a>5.1 显示所有的URGENT (URG)包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 32!=0&apos;</span><br></pre></td></tr></table></figure><h3 id="5-2-显示所有的ACKNOWLEDGE-ACK-包"><a href="#5-2-显示所有的ACKNOWLEDGE-ACK-包" class="headerlink" title="5.2 显示所有的ACKNOWLEDGE (ACK)包"></a>5.2 显示所有的ACKNOWLEDGE (ACK)包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 16!=0&apos;</span><br></pre></td></tr></table></figure><h4 id="5-3-显示所有的PUSH-PSH-包"><a href="#5-3-显示所有的PUSH-PSH-包" class="headerlink" title="5.3 显示所有的PUSH(PSH)包"></a>5.3 显示所有的PUSH(PSH)包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 8!=0&apos;</span><br></pre></td></tr></table></figure><h3 id="5-4-显示所有的RESET-RST-包"><a href="#5-4-显示所有的RESET-RST-包" class="headerlink" title="5.4 显示所有的RESET(RST)包"></a>5.4 显示所有的RESET(RST)包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 4!=0&apos;</span><br></pre></td></tr></table></figure><h3 id="5-5-显示所有的SYNCHRONIZE-SYN-包"><a href="#5-5-显示所有的SYNCHRONIZE-SYN-包" class="headerlink" title="5.5 显示所有的SYNCHRONIZE (SYN) 包"></a>5.5 显示所有的SYNCHRONIZE (SYN) 包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 2!=0&apos;</span><br></pre></td></tr></table></figure><h3 id="5-6-显示所有的FINISH-FIN-包"><a href="#5-6-显示所有的FINISH-FIN-包" class="headerlink" title="5.6 显示所有的FINISH(FIN)包"></a>5.6 显示所有的FINISH(FIN)包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13] &amp; 1!=0&apos;</span><br></pre></td></tr></table></figure><h3 id="5-7-显示所有的SYNCHRONIZE-ACKNOWLEDGE-SYNACK-包"><a href="#5-7-显示所有的SYNCHRONIZE-ACKNOWLEDGE-SYNACK-包" class="headerlink" title="5.7 显示所有的SYNCHRONIZE/ACKNOWLEDGE (SYNACK)包"></a>5.7 显示所有的SYNCHRONIZE/ACKNOWLEDGE (SYNACK)包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump &apos;tcp[13]=18&apos;</span><br></pre></td></tr></table></figure><h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6. 参考链接"></a>6. 参考链接</h2><p><a href="https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md" target="_blank" rel="noopener">tcpdump简明教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tcpdump是一个优秀的网络分析工具，提供了强大且简单的接口。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://shinerio.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://shinerio.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="network" scheme="https://shinerio.cc/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码解析——压缩列表ziplist</title>
    <link href="https://shinerio.cc/2020/06/03/redis/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist/"/>
    <id>https://shinerio.cc/2020/06/03/redis/源码解析——压缩列表ziplist/</id>
    <published>2020-06-03T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p>在Redis中，list有两种存储方式：双端链表（LinkedList）和压缩双端链表（ziplist）。双端链表即普通数据结构中遇到的，在adlist.h和adlist.c中实现。压缩双端链表在ziplist.h和ziplist.c实现。</p><a id="more"></a><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>在redisObject一文中我们得知redis的hash底层存储可以使用ziplist和hashtable两种编码方式。当hash对象可以同时满足以下两个条件时，hash对象采样点ziplist编码。</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li><li>哈希对象保存的键值对数量小于512个</li></ul><p>ziplist包括zip header、zip entry和zip end三部分组成，其存储格式可以用下图表示。</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200603160420.png" alt></p><p>zip_bytes是zip list占用的空间，zip_tail是最后一个数据项的偏移地址，方便反向遍历链表。zip_length表示zip_entry的个数，zip_end为定值0xFF，占1字节。</p><p>zip_entry的结构如下：</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200603160744.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存 ziplist 节点信息的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// prevrawlen ：前置节点的长度</span></span><br><span class="line">    <span class="comment">// prevrawlensize ：编码 prevrawlen 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen;</span><br><span class="line">    <span class="comment">// len ：当前节点值的长度</span></span><br><span class="line">    <span class="comment">// lensize ：编码len所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len;</span><br><span class="line">    <span class="comment">// 当前节点 header 的大小</span></span><br><span class="line">    <span class="comment">// 等于 prevrawlensize + lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</span><br><span class="line">    <span class="comment">// 当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><div class="admonition warning"><p class="admonition-title">prevlen</p><p>ziplist在编码前置节点长度的时候，采用以下规则。1.如果前置节点的长度小于254字节，那么采用1个字节来保存这个长度值；2. 如果前置节点的长度大于254字节，则采用5个字节来保存这个长度值，其中，第一个字节被设置为0xFE(254)，用于表示该长度大于254字节，后面四个字节则用来存储前置节点的长度值。</p></div><p><strong>编码前置长度</strong></p><ul><li>如果前置节点的长度大于254字节，则采用5个字节来保存这个长度值，其中，第一个字节被设置为0xFE(254)，用于表示该长度大于254字节，后面四个字节则用来存储前置节点的长度值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". Return the</span></span><br><span class="line"><span class="comment"> * number of bytes needed to encode this length if "p" is NULL. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对前置节点的长度 len 进行编码，并将它写入到 p 中，</span></span><br><span class="line"><span class="comment"> * 然后返回编码 len 所需的字节数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 p 为 NULL ，那么不进行写入，仅返回编码 len 所需的字节数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅返回编码 len 所需的字节数量</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入并返回编码 len 所需的字节数量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 字节</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 字节</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加 5 字节长度标识</span></span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="comment">// 写入编码</span></span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            <span class="comment">// 如果有必要的话，进行大小端转换</span></span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 返回编码长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解码前置节点长度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Decode the number of bytes required to store the length of the previous</span></span><br><span class="line"><span class="comment"> * element, from the perspective of the entry pointed to by 'ptr'. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解码 ptr 指针，</span></span><br><span class="line"><span class="comment"> * 取出编码前置节点长度所需的字节数，并将它保存到 prevlensize 变量中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;      \</span></span><br><span class="line">    <span class="keyword">if</span> ((ptr)[<span class="number">0</span>] &lt; ZIP_BIGLEN) &#123;                           \</span><br><span class="line">        (prevlensize) = <span class="number">1</span>;                                 \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                               \</span><br><span class="line">        (prevlensize) = <span class="number">5</span>;                                 \</span><br><span class="line">    &#125;                                                      \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* Decode the length of the previous element, from the perspective of the entry</span></span><br><span class="line"><span class="comment"> * pointed to by 'ptr'. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解码 ptr 指针，</span></span><br><span class="line"><span class="comment"> * 取出编码前置节点长度所需的字节数，</span></span><br><span class="line"><span class="comment"> * 并将这个字节数保存到 prevlensize 中。</span></span><br><span class="line"><span class="comment"> * 然后根据 prevlensize ，从 ptr 中取出前置节点的长度值，</span></span><br><span class="line"><span class="comment"> * 并将这个长度值保存到 prevlen 变量中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do &#123; \</span></span><br><span class="line">    <span class="comment">/* 先计算被编码长度值的字节数 */</span>                           \</span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);             \</span><br><span class="line">    <span class="comment">/* 再根据编码字节数来取出长度值 */</span>                         \</span><br><span class="line">    <span class="keyword">if</span> ((prevlensize) == <span class="number">1</span>) &#123;                             \</span><br><span class="line">        (prevlen) = (ptr)[<span class="number">0</span>];                             \</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((prevlensize) == <span class="number">5</span>) &#123;                      \</span><br><span class="line">        assert(<span class="keyword">sizeof</span>((prevlensize)) == <span class="number">4</span>);               \</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(prevlen), ((<span class="keyword">char</span>*)(ptr)) + <span class="number">1</span>, <span class="number">4</span>);        \</span><br><span class="line">        memrev32ifbe(&amp;prevlen);                           \</span><br><span class="line">    &#125;                                                     \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在编码解码当前节点的长度，ziplist提供了zipEncodeLength和ZIP_DECODE_LENGTH这两个配套函数来完成。</p><h2 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h2><h3 id="2-1-创建空ziplist"><a href="#2-1-创建空ziplist" class="headerlink" title="2.1 创建空ziplist"></a>2.1 创建空ziplist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小</span></span><br><span class="line">    <span class="comment">//#define ZIPLIST_HEADER_SIZE (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line">    <span class="comment">// 1字节链表末端 ZIP_END 的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 为表头和表末端分配空间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">// 初始化表属性</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置表末端</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-插入节点"><a href="#2-2-插入节点" class="headerlink" title="2.2 插入节点"></a>2.2 插入节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将长度为 slen 的字符串 s 推入到 zl 中。</span></span><br><span class="line"><span class="comment"> *  where 参数的值决定了推入的方向：</span></span><br><span class="line"><span class="comment"> * - 值为 ZIPLIST_HEAD 时，将新值推入到表头。</span></span><br><span class="line"><span class="comment"> * - 否则，将新值推入到表末端。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数的返回值为添加新值后的 ziplist 。</span></span><br><span class="line"><span class="comment"> * T = O(N^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 where 参数的值，决定将值推入到表头还是表尾</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">// ZIPLIST_ENTRY_HEAD和ZIPLIST_ENTRY_END通过宏定义计算分别指向第一个节点的其实位置和zip_end的起始位置</span></span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回添加新值后的 ziplist</span></span><br><span class="line">    <span class="comment">// T = O(N^2)</span></span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据指针 p 所指定的位置，将长度为 slen 的字符串 s 插入到 zl 中。</span></span><br><span class="line"><span class="comment"> * 函数的返回值为完成插入操作之后的 ziplist</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="comment">// 记录当前 ziplist 的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value that is easy to see if for some reason we use it uninitialized. */</span></span><br><span class="line">    zlentry entry, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">// 如果 p[0] 不指向列表末端，说明列表非空，并且 p 正指向列表的其中一个节点</span></span><br><span class="line">        <span class="comment">// 那么取出 p 所指向节点的信息，并将它保存到 entry 结构中</span></span><br><span class="line">        <span class="comment">// 然后用 prevlen 变量记录前置节点的长度</span></span><br><span class="line">        <span class="comment">// （当插入新节点之后 p 所指向的节点就成了新节点的前置节点）</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        prevlen = entry.prevrawlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 p 指向表尾末端，那么程序需要检查列表是否为：</span></span><br><span class="line">        <span class="comment">// 1)如果 ptail 也指向 ZIP_END ，那么列表为空；</span></span><br><span class="line">        <span class="comment">// 2)如果列表不为空，那么 ptail 将指向列表的最后一个节点。</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 表尾节点为新节点的前置节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出表尾节点的长度</span></span><br><span class="line">            <span class="comment">// T = O(1)</span></span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">// 尝试看能否将输入字符串转换为整数，如果成功的话：</span></span><br><span class="line">    <span class="comment">// 1)value 将保存转换后的整数值</span></span><br><span class="line">    <span class="comment">// 2)encoding 则保存适用于 value 的编码方式</span></span><br><span class="line">    <span class="comment">// 无论使用什么编码， reqlen 都保存节点值的长度</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is untouched, however zipEncodeLength will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    <span class="comment">// 计算编码前置节点的长度所需的大小</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">// 计算编码当前节点值所需的大小</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry's length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="comment">// 只要新节点不是被添加到列表末端，</span></span><br><span class="line">    <span class="comment">// 那么程序就需要检查看 p 所指向的节点（的 header）能否编码新节点的长度。</span></span><br><span class="line">    <span class="comment">// nextdiff 保存了新旧编码之间的字节大小差，如果这个值大于 0 </span></span><br><span class="line">    <span class="comment">// 那么说明需要对 p 所指向的节点（的 header ）进行扩展</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    <span class="comment">// 因为重分配空间可能会改变 zl 的地址</span></span><br><span class="line">    <span class="comment">// 所以在分配之前，需要记录 zl 到 p 的偏移量，然后在分配之后依靠偏移量还原 p </span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    <span class="comment">// curlen 是 ziplist 原来的长度</span></span><br><span class="line">    <span class="comment">// reqlen 是整个新节点的长度</span></span><br><span class="line">    <span class="comment">// nextdiff 是新节点的后继节点扩展 header 的长度（要么 0 字节，要么 4 个字节）</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">// 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        <span class="comment">// 移动现有元素，为新元素的插入空间腾出位置</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry's raw length in the next entry. */</span></span><br><span class="line">        <span class="comment">// 将新节点的长度编码至后置节点</span></span><br><span class="line">        <span class="comment">// p+reqlen 定位到后置节点</span></span><br><span class="line">        <span class="comment">// reqlen 是新节点的长度</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">// 更新到达表尾的偏移量，将新节点的长度也算上</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">        <span class="comment">// 如果新节点的后面有多于一个节点</span></span><br><span class="line">        <span class="comment">// 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</span></span><br><span class="line">        <span class="comment">// 这样才能让表尾偏移量正确对齐表尾节点</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        tail = zipEntry(p+reqlen);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        <span class="comment">// 新元素是新的表尾节点</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="comment">// 当 nextdiff != 0 时，新节点的后继节点的（header 部分）长度已经被改变，</span></span><br><span class="line">    <span class="comment">// 所以需要级联地更新后续的节点</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        <span class="comment">// T  = O(N^2)</span></span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">// 一切搞定，将前置节点的长度写入新节点的 header</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    <span class="comment">// 将节点值的长度写入新节点的 header</span></span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="comment">// 写入节点值</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新列表的节点数量计数器</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>压缩双链表以连续内存空间表示双链表，压缩双链表节省前驱和后驱指针的空间（共8B），这在小的list上，压缩效率是非常明显的，因为在一个普通的双链表中，前驱后驱指针在64位机器上需要分别占用8B</p></li><li><p>使用ziplist比hashtable更省内存，ziplist的连续内存可以利用cpu的缓存特性（hashtable是非线性的），某些情况下查找效率更高。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Redis中，list有两种存储方式：双端链表（LinkedList）和压缩双端链表（ziplist）。双端链表即普通数据结构中遇到的，在adlist.h和adlist.c中实现。压缩双端链表在ziplist.h和ziplist.c实现。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://shinerio.cc/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shinerio.cc/tags/C-C/"/>
    
      <category term="Redis" scheme="https://shinerio.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码解析——字典dict</title>
    <link href="https://shinerio.cc/2020/05/24/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8dict/"/>
    <id>https://shinerio.cc/2020/05/24/redis/Redis源码解析——字典dict/</id>
    <published>2020-05-24T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p>Redis中有多个数据库，数据库采用的数据结构是哈希表，用以存储键值对。默认所有的客户端都使用第一个数据库，一个数据库对应一个哈希表。如果客户端有需要，可以使用select命令来选择不同的数据库。Redis在初始化服务器的时候就会初始化所有的数据集。Redis的字典采用哈希表作为底层结构，主要实现代码在dict.c和dict.h文件中。</p><a id="more"></a><h2 id="1-dict数据结构"><a href="#1-dict数据结构" class="headerlink" title="1. dict数据结构"></a>1. dict数据结构</h2><h3 id="1-1-哈希表节点（dictEntry）"><a href="#1-1-哈希表节点（dictEntry）" class="headerlink" title="1.1 哈希表节点（dictEntry）"></a>1.1 哈希表节点（dictEntry）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成哈希表”开链法“中的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="1-2-哈希表"><a href="#1-2-哈希表" class="headerlink" title="1.2 哈希表"></a>1.2 哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表，每个字典使用两个哈希表，能在不中断服务的情况下扩展哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引，表示下一次rehash索引位置</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典类型特定函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>由此我们可以推断出Redis Dict的结构如下图所示：</p><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200525143216.png" alt></p><h2 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h2><h3 id="2-1-Rehash算法"><a href="#2-1-Rehash算法" class="headerlink" title="2.1 Rehash算法"></a>2.1 Rehash算法</h3><p>Dict采用开链法来处理哈希冲突，随着数据存放量的增加，必然会造成冲突链表越来越长，最终会导致字典查找效率显著下降。这种情况下，就需要对字典进行扩容。另外，当字典中键值对过少时，就需要对字典进行收缩来节省空间，这些扩容和收缩的过程就采用rehash来实现。Rehash算法使用rehashidx来控制rehash进度，此方法是线程不安全的，不能并发调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 执行 N 步渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 1 表示仍有键需要从 0 号哈希表移动到 1 号哈希表，</span></span><br><span class="line"><span class="comment"> * 返回 0 则表示所有键都已经迁移完毕。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，每步 rehash 都是以一个哈希表索引（桶）作为单位的，</span></span><br><span class="line"><span class="comment"> * 一个桶里可能会有多个节点，</span></span><br><span class="line"><span class="comment"> * 被 rehash 的桶里的所有节点都会被移动到新哈希表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 进行 N 步迁移</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放 0 号哈希表</span></span><br><span class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            <span class="comment">// 将原来的 1 号哈希表设置为新的 0 号哈希表</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 重置旧的 1 号哈希表</span></span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 关闭 rehash 标识</span></span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 返回 0 ，向调用者表示 rehash 已经完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span>)d-&gt;rehashidx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引，这里不会发生越界问题，因为d-&gt;ht[0].used == 0一定能找到下一个不为NULL的</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向该索引的链表表头节点</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存下个节点的指针</span></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 采用头插法，插入节点到新哈希表</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新计数器</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续处理下个节点</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 更新 rehash 索引</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回1，表示rehash还未结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis中的rehash操作不是一次完成的，而是渐进式完成的，每次只移动若干个bucket到新表。Redis提供了如下两种渐进式的操作来做rehash。</p><h4 id="2-1-1-按索引值"><a href="#2-1-1-按索引值" class="headerlink" title="2.1.1 按索引值"></a>2.1.1 按索引值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dict不存在安全迭代器的情况下，对字典进行单步rehash（在迭代过程中修改字典是不被允许的，容易引发安全问题）</p><h4 id="2-1-2-按时间间隔"><a href="#2-1-2-按时间间隔" class="headerlink" title="2.1.2 按时间间隔"></a>2.1.2 按时间间隔</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的时间戳（一毫秒为单位）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在给定毫秒数内，以 100 步为单位，对字典进行 rehash </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;  <span class="comment">// 每次执行100步</span></span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>; <span class="comment">// 如果时间超过ms就退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Dict创建"><a href="#2-2-Dict创建" class="headerlink" title="2.2 Dict创建"></a>2.2 Dict创建</h3><p>dict创建时并没有实际为hash表分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重置（或初始化）给定哈希表的各项属性值</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的字典</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化两个哈希表的各项属性值</span></span><br><span class="line">    <span class="comment">// 但暂时还不分配内存给哈希表数组</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类型特定函数</span></span><br><span class="line">    d-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置私有数据</span></span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置哈希表 rehash 状态</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字典的安全迭代器数量</span></span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Dict扩容"><a href="#2-3-Dict扩容" class="headerlink" title="2.3 Dict扩容"></a>2.3 Dict扩容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的哈希表，并根据字典的情况，选择以下其中一个动作来进行：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) 如果字典的 0 号哈希表为空，那么将新哈希表设置为 0 号哈希表</span></span><br><span class="line"><span class="comment"> * 2) 如果字典的 0 号哈希表非空，那么将新哈希表设置为 1 号哈希表，</span></span><br><span class="line"><span class="comment"> *    并打开字典的 rehash 标识，使得程序可以开始对字典进行 rehash</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * size 参数不够大，或者 rehash 已经在进行时，返回 DICT_ERR 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功创建 0 号哈希表，或者 1 号哈希表时，返回 DICT_OK 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新哈希表</span></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 size 参数，计算哈希表的大小</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></span><br><span class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    n.table = zcalloc( *<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="comment">// 如果 0 号哈希表为空，那么这是一次初始化：</span></span><br><span class="line">    <span class="comment">// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">// 如果 0 号哈希表非空，那么这是一次 rehash ：</span></span><br><span class="line">    <span class="comment">// 程序将新哈希表设置为 1 号哈希表，</span></span><br><span class="line">    <span class="comment">// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-查找key可以插入的索引位置"><a href="#2-4-查找key可以插入的索引位置" class="headerlink" title="2.4 查找key可以插入的索引位置"></a>2.4 查找key可以插入的索引位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * a hash entry for the given 'key'.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回可以将 key 插入到哈希表的索引位置</span></span><br><span class="line"><span class="comment"> * 如果 key 已经存在于哈希表，那么返回 -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，如果字典正在进行 rehash ，那么总是返回 1 号哈希表的索引。</span></span><br><span class="line"><span class="comment"> * 因为在字典进行 rehash 时，新节点总是插入到 1 号哈希表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="comment">// 单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    <span class="comment">// 计算 key 的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算索引值</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        <span class="comment">// 查找 key 是否存在</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到这里时，说明 0 号哈希表中所有节点都不包含 key</span></span><br><span class="line">        <span class="comment">// 如果这时 rehahs 正在进行，那么继续对 1 号哈希表进行 rehash</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">// 渐进式 rehash 已经在进行了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="comment">// 如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小(4)的0号哈希表</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">// 一下两个条件之一为真时，对字典进行扩展</span></span><br><span class="line">    <span class="comment">// 1）字典已使用节点数和字典大小之间的比率接近 1：1</span></span><br><span class="line">    <span class="comment">//    并且 dict_can_resize 为真</span></span><br><span class="line">    <span class="comment">// 2）已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新哈希表的大小至少是目前已使用节点数的两倍</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-添加键值对"><a href="#2-5-添加键值对" class="headerlink" title="2.5 添加键值对"></a>2.5 添加键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将给定键值对添加到字典中</span></span><br><span class="line"><span class="comment"> * 只有给定键 key 不存在于字典时，添加操作才会成功</span></span><br><span class="line"><span class="comment"> * 添加成功返回 DICT_OK ，失败返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> * 最坏 T = O(N) ，平摊 O(1) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 尝试添加键到字典，并返回包含了这个键的新哈希节点</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键已存在，添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，设置节点的值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成功</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level add. This function adds the entry but instead of setting</span></span><br><span class="line"><span class="comment"> * a value returns the dictEntry structure to the user, that will make</span></span><br><span class="line"><span class="comment"> * sure to fill the value field as he wishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is also directly exposed to user API to be called</span></span><br><span class="line"><span class="comment"> * mainly in order to store non-pointers inside the hash value, example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * entry = dictAddRaw(dict,mykey);</span></span><br><span class="line"><span class="comment"> * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If key already exists NULL is returned.</span></span><br><span class="line"><span class="comment"> * If key was added, the hash entry is returned to be manipulated by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将键插入到字典中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果键已经在字典存在，那么返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果键不存在，那么程序创建新的哈希节点，</span></span><br><span class="line"><span class="comment"> * 将节点和键关联，并插入到字典，然后返回节点本身。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">// 计算键在哈希表中的索引值</span></span><br><span class="line">    <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry */</span></span><br><span class="line">    <span class="comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span></span><br><span class="line">    <span class="comment">// 否则，将新键添加到 0 号哈希表</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为新节点分配空间</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    <span class="comment">// 更新哈希表已使用节点数量</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">// 设置新节点的键</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-替换键对应的值"><a href="#2-6-替换键对应的值" class="headerlink" title="2.6 替换键对应的值"></a>2.6 替换键对应的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试直接将键值对添加到字典, 如果键 key 不存在的话，添加会成功</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 键key已经存在，那么找出包含这个 key 的节点</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">// 先保存原有的值的指针</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    <span class="comment">// 然后设置新的值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="comment">// 然后释放旧值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-查找键值对"><a href="#2-7-查找键值对" class="headerlink" title="2.7 查找键值对"></a>2.7 查找键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    <span class="comment">// 字典为空，返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">// 如果正在进行rehash，则执行rehash操作</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// 在两个表中查找对应的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 根据掩码来计算索引值</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 得到该索引值下的存放的键值对链表</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">// 如果找到该key直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            <span class="comment">// 找下一个</span></span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有进行rehash，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-删除键值对"><a href="#2-8-删除键值对" class="headerlink" title="2.8 删除键值对"></a>2.8 删除键值对</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从字典中删除包含给定键的节点</span></span><br><span class="line"><span class="comment"> * 并且调用键值的释放函数来删除键值</span></span><br><span class="line"><span class="comment"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从字典中删除包含给定键的节点</span></span><br><span class="line"><span class="comment"> * 但不调用键值的释放函数来删除键值，键值可能在其他地方用到</span></span><br><span class="line"><span class="comment"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找并删除包含给定键的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数 nofree 决定是否调用键和值的释放函数</span></span><br><span class="line"><span class="comment"> * 0 表示调用，1 表示不调用</span></span><br><span class="line"><span class="comment"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典（的哈希表）为空</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行单步 rehash ，T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算索引值 </span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 指向该索引上的链表</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 遍历链表上的所有节点</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">// 超找目标节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="comment">// 从链表中删除</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 释放调用键和值的释放函数？</span></span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放节点本身</span></span><br><span class="line">                zfree(he);</span><br><span class="line">                <span class="comment">// 更新已使用节点数量</span></span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="comment">// 返回已找到信号</span></span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0号哈希表中找不到给定键</span></span><br><span class="line">        <span class="comment">//那么根据字典是否正在进行rehash ，决定要不要查找1号哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-Dict迭代"><a href="#2-9-Dict迭代" class="headerlink" title="2.9 Dict迭代"></a>2.9 Dict迭代</h3><p>在 RDB 和 AOF 持久化操作中，都需要迭代哈希表。哈希表的遍历本身难度不大，但因为每个数据库都有两个哈希表，所以遍历的时候也需要注意遍历两个哈希表：第一个哈希表遍历完毕的时候，如果发现rehash尚未结束，则需要继续遍历第二个哈希表。</p><h4 id="2-9-1-迭代器定义"><a href="#2-9-1-迭代器定义" class="headerlink" title="2.9.1 迭代器定义"></a>2.9.1 迭代器定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 safe 属性的值为 1 ，那么在迭代进行的过程中，</span></span><br><span class="line"><span class="comment"> * 程序仍然可以执行 dictAdd 、 dictFind 和其他函数，对字典进行修改。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 safe 不为 1 ，那么程序只会调用 dictNext 对字典进行迭代，</span></span><br><span class="line"><span class="comment"> * 而不对字典进行修改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></span><br><span class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></span><br><span class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></span><br><span class="line">    <span class="keyword">int</span> table, index, safe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></span><br><span class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></span><br><span class="line">    <span class="comment">//因为在安全迭代器运作时， entry 所指向的节点可能会被修改，所以需要一个额外的指针来保存下一节点的位置，从而防止指针丢失</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">/* unsafe iterator fingerprint for misuse detection */</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><h4 id="2-9-2-创建迭代器"><a href="#2-9-2-创建迭代器" class="headerlink" title="2.9.2 创建迭代器"></a>2.9.2 创建迭代器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建并返回给定字典的不安全迭代器</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建并返回给定节点的安全迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置安全迭代器标识</span></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回迭代器指向的当前节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字典迭代完毕时，返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入这个循环有两种可能：</span></span><br><span class="line">        <span class="comment">// 1) 这是迭代器第一次运行</span></span><br><span class="line">        <span class="comment">// 2) 当前索引链表中的节点已经迭代完（NULL 为链表的表尾）</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指向被迭代的哈希表</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初次迭代时执行</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是安全迭代器，那么更新安全迭代器计数器</span></span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="comment">// 如果是不安全迭代器，那么计算指纹</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新索引</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果迭代器的当前索引大于当前被迭代的哈希表的大小</span></span><br><span class="line">            <span class="comment">// 那么说明这个哈希表已经迭代完毕</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">signed</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">// 如果正在 rehash 的话，那么说明 1 号哈希表也正在使用中</span></span><br><span class="line">                <span class="comment">// 那么继续对 1 号哈希表进行迭代</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果没有 rehash ，那么说明迭代已经完成</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果进行到这里，说明这个哈希表并未迭代完</span></span><br><span class="line">            <span class="comment">// 更新节点指针，指向下个索引链表的表头节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到这里，说明程序正在迭代某个链表</span></span><br><span class="line">            <span class="comment">// 将节点指针指向链表的下个节点</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点不为空，那么也记录下该节点的下个节点</span></span><br><span class="line">        <span class="comment">// 因为安全迭代器有可能会将迭代器返回的当前节点删除</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>Dict的查找效率是T(1)，但对键值对进行增加、修改时可能会存在扩容，此时的效率为T(N)，因此Redis注重高读性能，低写性能，适合于读多写少场景。</li><li>Redis的每个Dict保存了两张Hash表，可以在不中断服务的情况下扩展hash表</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis中有多个数据库，数据库采用的数据结构是哈希表，用以存储键值对。默认所有的客户端都使用第一个数据库，一个数据库对应一个哈希表。如果客户端有需要，可以使用select命令来选择不同的数据库。Redis在初始化服务器的时候就会初始化所有的数据集。Redis的字典采用哈希表作为底层结构，主要实现代码在dict.c和dict.h文件中。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://shinerio.cc/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shinerio.cc/tags/C-C/"/>
    
      <category term="Redis" scheme="https://shinerio.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码解析——动态字符串sds</title>
    <link href="https://shinerio.cc/2020/05/22/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/"/>
    <id>https://shinerio.cc/2020/05/22/redis/Redis源码解析——动态字符串sds/</id>
    <published>2020-05-22T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p>Redis没有使用C语言的字符串结构，而是自己设计了一个简单的动态字符串结构sds(simple dynamic string)。Redis中关于sds的实现主要在sds.c和sds.h中</p><a id="more"></a><h2 id="1-sds数据结构定义"><a href="#1-sds数据结构定义" class="headerlink" title="1. sds数据结构定义"></a>1. sds数据结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，用于指向 sdshdr 的 buf 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200522165735.png" alt></p><p>buf[]为长度为0的数据，不占用内存，sizeof(struct sdshdr)返回8。使用char buf[]而不是char *buf，可以避免二次分配内存，同时buf[]不占用空间，也能节省内存。</p><h2 id="2-sds创建函数"><a href="#2-sds创建函数" class="headerlink" title="2. sds创建函数"></a>2. sds创建函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="comment">// calloc()会对分配的空间做初始化工作（初始化为0），而malloc()不会</span></span><br><span class="line">    <span class="keyword">if</span> (init)</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度，sds长度没有计算'\0'</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *) sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-sds释放函数"><a href="#3-sds释放函数" class="headerlink" title="3. sds释放函数"></a>3. sds释放函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将sds指针前移sizeof(struct sdshdr)，得到真正分配内存地址</span></span><br><span class="line">    zfree(s - <span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-sds扩容函数"><a href="#4-sds扩容函数" class="headerlink" title="4. sds扩容函数"></a>4. sds扩容函数</h2><p> 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \0 准备的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取s目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="comment">//预分配内存最大为1MB</span></span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + newlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-sds回收函数"><a href="#5-sds回收函数" class="headerlink" title="5. sds回收函数"></a>5. sds回收函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行内存重分配，让 buf 的长度仅仅足够保存字符串内容</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + sh-&gt;len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空余空间为 0</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-sds拼接函数"><a href="#6-sds拼接函数" class="headerlink" title="6. sds拼接函数"></a>6. sds拼接函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="comment">// 原有字符串长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">// 扩展 sds 空间</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="comment">//由于预分配内存机制的存在，这里可能并没有进行实际内存分配</span></span><br><span class="line">    s = sdsMakeRoomFor(s, len);</span><br><span class="line">    <span class="comment">// 内存不足，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s + curlen, t, len);</span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = curlen + len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span> - len;</span><br><span class="line">    <span class="comment">// 添加新结尾符号</span></span><br><span class="line">    s[curlen + len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 返回新 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-sds与C中字符串区别"><a href="#7-sds与C中字符串区别" class="headerlink" title="7. sds与C中字符串区别"></a>7. sds与C中字符串区别</h2><ul><li>C语言使用长度N+1的字符数组表示长度为N的字符串，使用’\0’作为字符串的结尾</li><li>C字符串不记录字符串长度，strlen操作复杂度为O(N)，而sds取长度操作为O(1)</li><li>C语言字符串使用不当容易造成缓冲区溢出，而sds通过free变量控制。</li><li>sds扩容是不是按照字符串所占用字节大小严格扩容的，而是会额外分配一些暂时使用不到的空间。通过这种策略可以一定程度上减少字符串增长所需的内存重分配次数。</li><li>C语言字符串以’\o’结尾，字符串中不能含有空字符，sds通过len来判断字符串结尾，可以用来存一些具有特殊格式要求的二进制数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis没有使用C语言的字符串结构，而是自己设计了一个简单的动态字符串结构sds(simple dynamic string)。Redis中关于sds的实现主要在sds.c和sds.h中&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://shinerio.cc/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shinerio.cc/tags/C-C/"/>
    
      <category term="Redis" scheme="https://shinerio.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码解析——redisObject</title>
    <link href="https://shinerio.cc/2020/05/18/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94redisObject/"/>
    <id>https://shinerio.cc/2020/05/18/redis/Redis源码解析——redisObject/</id>
    <published>2020-05-18T00:00:00.000Z</published>
    <updated>2023-01-24T15:34:38.755Z</updated>
    
    <content type="html"><![CDATA[<p>redis是一个key-value存储系统，其中key类型一般为字符串，而value类型则为redis对象。Redis对象可以绑定各种类型的数据，如string、hash、list、set和zset。redisObejct在redis.h中定义。</p><a id="more"></a><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用了位域，unsigned等价于unsigned int，type、encoding和lru共占用4字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型，string/hash/list/set/zset</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间，当内存紧张，淘汰数据时使用</span></span><br><span class="line">    <span class="comment">// lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">//#define REDIS_LRU_BITS 24</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="1-1-type"><a href="#1-1-type" class="headerlink" title="1.1 type"></a>1.1 type</h3><p>redisObject共有以下5种类型，type占4bit（理论支持2^4=16种）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure><h3 id="1-2-encoding"><a href="#1-2-encoding" class="headerlink" title="1.2 encoding"></a>1.2 encoding</h3><p>redisObject共有以下9种编码类型，占用4bit，如“12345”既可以用字符串编码，也可能被存储为一个整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be internally represented in multiple ways. The 'encoding' field of the object is set to one of this fields for this object. */</span></span><br><span class="line"><span class="comment">// 对象编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>编码类型</th><th>底层实现</th></tr></thead><tbody><tr><td>OBJ_ENCODING_RAW</td><td>简单动态字符串sds</td></tr><tr><td>OBJ_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>OBJ_ENCODING_HT</td><td>字典dict</td></tr><tr><td>OBJ_ENCODING_LINKEDLIST</td><td>双端队列sdlist</td></tr><tr><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表ziplist</td></tr><tr><td>OBJ_ENCODING_INTSET</td><td>整数集合intset</td></tr><tr><td>OBJ_ENCODING_SKIPLIST</td><td>跳跃表skiplist和字典dict</td></tr><tr><td>OBJ_ENCODING_EMBSTR</td><td>EMBSTR编码的简单动态字符串sds</td></tr><tr><td>OBJ_ENCODING_QUICKLIST</td><td>由双端链表和压缩列表构成的快速列表</td></tr></tbody></table></div><p>redis的每一种对象类型可以对应不同的编码方式，极大地提高了redis的灵活性和效率。Redis可以根据不同场景来选择合适的编码方式。</p><div class="table-container"><table><thead><tr><th>对象类型</th><th>编码方式</th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>OBJ_ENCODING_RAW ,OBJ_ENCODING_INT ,OBJ_ENCODING_EMBSTR</td></tr><tr><td>OBJ_LIST</td><td>OBJ_ENCODING_LINKEDLIST ,OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_QUICKLIST</td></tr><tr><td>OBJ_SET</td><td>OBJ_ENCODING_INTSET ,OBJ_ENCODING_HT</td></tr><tr><td>OBJ_ZSET</td><td>OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_SKIPLIST</td></tr><tr><td>OBJ_HASH</td><td>OBJ_ENCODING_ZIPLIST ,OBJ_ENCODING_HT</td></tr></tbody></table></div><h3 id="1-3-lru"><a href="#1-3-lru" class="headerlink" title="1.3 lru"></a>1.3 lru</h3><p>lru用来表示该对象最后一次被访问的时间，其占用24个bit位。Redis对数据集占用内存大小有实时计算，当超出限额时，会淘汰超时的数据。</p><h3 id="1-4-refcount"><a href="#1-4-refcount" class="headerlink" title="1.4 refcount"></a>1.4 refcount</h3><p>引用计数，一个 Redis 对象可能被多个指针引用。C语言不具备自动内存回收机制，所以Redis对每一个对象设定了引用计数refcount字段，程序通过该字段的信息，在适当的时候自动释放内存进行内存回收。此功能与C++的智能指针相似。当需要增加或者减少引用的时候，必须调用相应的函数，相应实现在object.c中。</p><ul><li>当创建一个对象时，其引用计数初始化为1；</li><li>当这个对象被一个新程序使用时，其引用计数加1；</li><li>当这个对象不再被一个程序使用时，其引用计数减1；</li><li>当引用计数为0时，释放该对象，回收内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为对象的引用计数增一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为对象的引用计数减一</span></span><br><span class="line"><span class="comment"> * 当对象的引用计数降为 0 时，释放对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    <span class="comment">// 减少计数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="admonition note"><p>因为redis是单进程单线程工作的，所以增加/减少引用的操作不必要保证原子性。</p></div><h3 id="1-5-ptr"><a href="#1-5-ptr" class="headerlink" title="1.5 ptr"></a>1.5 ptr</h3><p>空类型指针，意味着可以指向任何类型的数据，用来存储真正的数据。</p><h2 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="2. 主要方法"></a>2. 主要方法</h2><p>操作redisObject的主要方法在object.c中，主要包括以下函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 创建对象，设定其参数</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建简单动态字符串编码的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">// 创建EMBSTR编码的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>; <span class="comment">// 根据传入的longlong整型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value, <span class="keyword">int</span> humanfriendly)</span></span>; <span class="comment">// 根据传入的long double类型值，创建一个字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建快速链表编码的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整型集合编码的集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建zset对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建压缩列表编码的zset对象</span></span><br></pre></td></tr></table></figure><p>以下我们以字符串为例，展开介绍。</p><h3 id="2-1-创建字符串"><a href="#2-1-创建字符串" class="headerlink" title="2.1 创建字符串"></a>2.1 创建字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//短字符使用特殊的EMBSTR编码</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="comment">// 长字符采用RAW编码</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象</span></span><br><span class="line"><span class="comment">// 对象的指针指向一个 sds 结构</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象</span></span><br><span class="line"><span class="comment">// 这个字符串对象中的 sds 会和字符串对象的 redisObject 结构一起分配</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//指向sdshdr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    <span class="comment">// 指向sdshdr中buf，实际存储数据地址</span></span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新 robj 对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type,。 <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="admonition warning"><p class="admonition-title">RawString和EmbeddedString区别</p><p>RawString中robj和sdshdr是单独分配内存的，而EmbeddedString是一起分配内存的。EmbeddedString内存的申请和释放都只需要一次，连续的内存空间可以更好地利用缓存优势，缺点是Redis未提供修改EmbeddedString的方法。</p></div><h3 id="2-2-字符串回收"><a href="#2-2-字符串回收" class="headerlink" title="2.2 字符串回收"></a>2.2 字符串回收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放字符串对象，这里只是释放了redisObject中ptr数据字段，整个redisObejct空间的释放在上文提到的decrRefCount方法中，当redisObject的引用计数为0时，会调用此方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis使用RedisObject来统一表示各种数据类型，包括String/Set/Zset/List/Hash</li><li>redis通过引用计数法表示对象生存状态，单进程单线程的工作原理使得引用计数的变化不需要保证原子性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis是一个key-value存储系统，其中key类型一般为字符串，而value类型则为redis对象。Redis对象可以绑定各种类型的数据，如string、hash、list、set和zset。redisObejct在redis.h中定义。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://shinerio.cc/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://shinerio.cc/tags/C-C/"/>
    
  </entry>
  
</feed>
