C++ 中定义变量时，即使不进行初始化，内存空间通常也会被分配，不过不同类型的变量在分配内存空间的时机和默认初始值方面存在差异。
# 1. 局部变量（自动存储期）
局部变量一般定义在函数内部或者代码块内部，具有自动存储期。当程序执行到定义局部变量的语句时，会立即为其分配内存空间，但不会自动初始化，该内存空间会保留之前存储的 “垃圾值”。
```c++
#include <iostream>

void exampleFunction() {
    int localVar;  // 定义局部变量，分配内存但未初始化
    std::cout << "localVar 的值: " << localVar << std::endl; 
}

int main() {
    exampleFunction();
    return 0;
}
```
在上述代码中，`localVar` 在 `int localVar;` 语句执行时分配内存，由于未初始化，其值是不确定的。
# 2. 静态变量（静态存储期）
静态变量使用 `static` 关键字定义，既可以在函数内部，也可以在全局作用域。静态变量在程序启动时就会分配内存空间，如果未显式初始化，会被自动初始化为其类型的默认值（数值类型为 0，指针类型为 `nullptr` 等）
```c++
#include <iostream>

void staticExample() {
    static int staticVar;  // 定义静态变量，分配内存并初始化为 0
    std::cout << "staticVar 的值: " << staticVar << std::endl; 
}

int main() {
    staticExample();
    return 0;
}
```
这里的 `staticVar` 在程序启动时分配内存，因为未显式初始化，所以默认初始化为 0。

# 3. 全局变量（静态存储期）
全局变量定义在所有函数外部，同样具有静态存储期。全局变量在程序启动时分配内存，若未显式初始化，也会被自动初始化为默认值。
```c++
#include <iostream>

int globalVar;  // 定义全局变量，分配内存并初始化为 0
int main() {
    std::cout << "globalVar 的值: " << globalVar << std::endl; 
    return 0;
}
```
`globalVar` 在程序启动时分配内存，默认初始化为 0。
# 4. 动态分配的变量（自由存储期）
使用 `new` 运算符动态分配的变量具有自由存储期。当执行 `new` 表达式时，会在堆上分配内存空间。如果使用 `new` 时没有进行初始化，对于内置类型不会进行初始化，对于类类型会调用默认构造函数。
```c++
#include <iostream>

int main() {
    int* dynamicVar = new int;  // 动态分配内存，未初始化
    std::cout << "*dynamicVar 的值: " << *dynamicVar << std::endl; 
    delete dynamicVar;  // 释放内存
    return 0;
}
```
在上述代码中，`new int` 执行时在堆上为 `dynamicVar` 分配内存，由于未初始化，其指向的内存中的值是不确定的。