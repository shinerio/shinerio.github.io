<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TLS - Shinerio's Blog</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./assets/css/style.css">
</head>
<body class="article-page" id="theme-body">
    <div class="page-wrapper">
        <header class="page-header">
            <div class="container">
                <nav class="page-nav">
                    <div class="nav-links">
                        <a href="index.html" class="nav-link ">Home</a>
                        <a href="articles.html" class="nav-link ">Articles</a>
                        <a href="search.html" class="nav-link ">Search</a>
                    </div>
                    <div class="theme-toggle-container">
                        <button id="theme-toggle" aria-label="Toggle dark mode" class="theme-toggle-btn">
                            <span class="sun-icon">☀️</span>
                            <span class="moon-icon">🌙</span>
                        </button>
                    </div>
                </nav>
            </div>
        </header>
        <main class="page-main">
            <div class="container">
                <article>
    <header>
        <h1>TLS</h1>
        <time datetime="2026-01-03T13:04:29.223Z">2026年1月3日</time>
        <div class="tags">
            
        </div>
    </header>
    <section class="content">
        {<h1>1. TLS是什么</h1>
<p>Transport Layer Security (TLS) 是一种被广泛采用的安全协议，旨在增强互联网通信的私密性和数据安全性。TLS的主要使用场景是对Web应用和服务器之间的通信（例如，Web 浏览器加载网站）进行加密。TLS 还可以用于加密其他通信，如电子邮件、消息传递和 <a href="https://www.cloudflare.com/learning/video/what-is-voip/">IP 语音 (VoIP)</a> 等。在本文中，我们将重点介绍 TLS 在 <a href="https://www.cloudflare.com/learning/security/what-is-web-application-security/">Web 应用安全</a>中发挥的作用。</p>
<p>TLS 由互联网工程任务组（Internet Engineering Task Force, IETF）提出，协议的第一个版本于1999年发布。最新版本是 <a href="https://www.cloudflare.com/learning/ssl/why-use-tls-1.3/">TLS 1.3</a>，发布于 2018 年。</p>
<h1>2. TLS与SSL</h1>
<p>Netscape开发了名为安全套接字层（Secure Socket Layer，<a href="https://www.cloudflare.com/learning/ssl/what-is-ssl/">SSL</a>）的上一代加密协议，TLS由此演变而来。TLS 1.0 版实际上最初作为SSL 3.1版开发，但在发布前更改了名称，以表明它不再与 Netscape 关联。由于这个历史原因，TLS 和 SSL 这两个术语有时会互换使用。</p>
<blockquote>
<p>[!note]<br>SSL最终版本为SSL 3.0，从1996开始已经不更新了。SSL3.0存在很多已知安全风险，我们在应用不应该再使用了。同时，大多数浏览器也不再支持SSL3.0</p>
</blockquote>
<h1>3. TLS发展</h1>
<p>TLS的最新版本是2018年发布的TLS1.3</p>
<ul>
<li><strong>更安全</strong>：TLS1.3放弃了对较旧、安全性较低的加密功能的支持</li>
<li><strong>更快</strong>：加快了 <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/">TLS 握手</a> ，TLS1.3中的TLS握手只需要一次往返（或来回通信）而不是两次，从而将过程缩短了几毫秒。如果客户端之前连接过网站，那么下次TLS握手的往返次数为零。这使HTTPS连接更快，减少<a href="https://www.cloudflare.com/learning/performance/glossary/what-is-latency/">延迟</a>并改善整体用户体验<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250401221027.png" alt="image.png"></li>
</ul>
<h1>4. TLS基本概念</h1>
<p>TLS协议主要包括了三个部分：加密、认证和完整性保护</p>
<ul>
<li><strong>Encryption:</strong> 隐藏从第三方传输的数据。</li>
<li><strong>Authentication:</strong> 确保参与信息交换的各方的身份都是真实的。</li>
<li><strong>Integrity:</strong> 验证数据未被伪造或篡改。</li>
</ul>
<h2>4.1. TLS证书</h2>
<p>网站或应用要使用TLS，必须在其服务器上安装TLS证书（旧称SSL证书）。TLS 证书由证书<strong>权威机构</strong>颁发给拥有域的个人或企业。该证书包含有关<strong>域所有者</strong>的重要信息以及服务器的<strong>公钥</strong>，两者对验证服务器身份都很重要。</p>
<h2>4.2. CipherSuites</h2>
<p>在TLS（传输层安全协议）中，加密套件（Cipher Suite）是一组用于在客户端和服务器之间建立安全通信的<strong>加密算法和协议的组合</strong>。它定义了在TLS握手过程中使用的具体加密机制，以确保数据的保密性、完整性和身份验证。</p>
<h4>4.2.1.1. 组成部分</h4>
<ul>
<li><strong>密钥交换算法</strong>：负责在客户端和服务器之间安全地交换会话密钥。常见的密钥交换算法有RSA、Diffie - Hellman（DH）、椭圆曲线 Diffie - Hellman（ECDH）等。例如，RSA算法可以用于服务器向客户端发送其公钥，客户端使用该公钥加密一个预主密钥并发送给服务器，双方再基于这个预主密钥生成会话密钥。</li>
<li><strong>身份验证算法</strong>：用于验证通信双方的身份。通常依赖于数字证书和公钥基础设施（PKI）。常见的身份验证算法与密钥交换算法相关，如使用RSA算法进行服务器身份验证，客户端可以通过验证服务器证书中的公钥来确认服务器的身份。</li>
<li><strong>对称加密算法</strong>：用于在建立会话密钥后对实际传输的数据进行加密和解密。常见的对称加密算法有AES（高级加密标准）、3DES 等。以AES为例，它具有较高的加密强度和效率，能够快速地对大量数据进行加密和解密操作。</li>
<li><strong>消息认证码（MAC）算法</strong>：用于确保数据的完整性和真实性。在数据传输过程中，发送方会根据数据和会话密钥生成一个MAC值，并将其与数据一起发送。接收方在接收到数据后，使用相同的算法和会话密钥重新计算MAC值，并与接收到的MAC值进行比较。常见的MAC算法有 HMAC-SHA1、HMAC-SHA256 等。</li>
</ul>
<h4>4.2.1.2. 命名规则</h4>
<p>加密套件通常采用一种标准化的命名方式，即<code>TLS_密钥交换算法_身份认证算法_WITH_对称加密算法_消息摘要算法</code>。<br>一个典型的加密套件名称可能是 <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>，其含义如下：</p>
<ul>
<li><code>TLS</code>：表示该加密套件基于TLS协议。</li>
<li><code>ECDHE</code>：代表密钥交换算法为椭圆曲线 Diffie - Hellman（ECDH）的临时密钥交换模式（Ephemeral），提供前向保密性。</li>
<li><code>RSA</code>：表示身份验证算法使用RSA。</li>
<li><code>AES_128_GCM</code>：指对称加密算法为AES，密钥长度为128位，使用GCM（Galois/Counter Mode）模式，该模式结合了加密和认证功能。</li>
<li><code>SHA256</code>：表示消息认证码（MAC）算法使用SHA-256哈希函数。<br>比如<code>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</code></li>
<li>密钥交换算法是<code>DHE</code></li>
<li>身份认证算法是<code>RSA</code></li>
<li>对称加密算法是AES_256_CBC</li>
<li>消息摘要算法是SHA256<br>由于RSA又可以用于加密也可以用于身份认证，因此密钥交换算法使用RSA时，只写一个RSA，比如<code>TLS_RSA_WITH_AES_256_CBC_SHA256</code></li>
</ul>
<h4>4.2.1.3. 套件的选择</h4>
<p>在TLS握手过程中，客户端会向服务器发送一个<strong>支持的加密套件列表</strong>，服务器会从这个列表中<strong>选择一个双方都支持的加密套件</strong>，并在握手过程中通知客户端。选择加密套件时，通常会考虑以下因素：</p>
<ul>
<li><strong>安全性</strong>：优先选择使用高强度加密算法和提供前向保密性的加密套件。</li>
<li><strong>性能</strong>：不同的加密算法在性能上可能存在差异，需要根据实际应用场景进行权衡。</li>
<li><strong>兼容性</strong>：确保客户端和服务器都支持所选的加密套件。</li>
</ul>
<h1>5. TLS的通信过程</h1>
<p>完整TLS握手需要经过2-RTT<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202505142208829.png" alt="image.png"></p>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250402222553.png" alt="image.png"></p>
<h1>6. TLS协议解析</h1>
<p>TLS协议是一个分层协议，第一层为TLS记录层协议(Record Layer Protocol)，该协议用于封装各种高级协议。目前封装了4种协议：握手协议（Handshake Protocol）、改变密码标准协议（Change Cipher Spec Protocol）、应用程序数据协议（Application Data Protocol）和警报协议（Alert Protocol）。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250402221259.png" alt="image.png"></p>
<p>抓包示例<br>!<a href="https-examplepcapng.html" class="internal-link">https_example.pcapng</a></p>
<blockquote>
<p>[!note]<br><code>Change Cipher Spec Protocol</code>在TLS1.3被去除。</p>
</blockquote>
<h3>6.1.1. Record Layer Protocol</h3>
<p>记录层(Record Layer Protocol)包含协议类型、版本号、长度、以及封装的高层协议内容。记录层头部为固定5字节大小。<br><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200522091117417-275634995.png" alt="20200522091116.png"></p>
<blockquote>
<p>[!note]<br>在TLS协议规定了，如接收到了未定义的协议协议类型，需要发送一个<code>unexpected_message</code>警报。</p>
</blockquote>
<h3>6.1.2. HandShake Protocol</h3>
<p>握手用于确认认证双方身份并协商加密算法<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250402221528.png" alt="image.png"><br><a href="https://datatracker.ietf.org/doc/html/rfc5246">TLSv1.2</a>握手过程如下：</p>
<pre><code>  Client                                                       Server
 
  ClientHello                  --------&gt;
                                                          ServerHello
                                                          Certificate*
                                                    ServerKeyExchange*
                                                  CertificateRequest*
                                &lt;--------              ServerHelloDone
  Certificate*
  ClientKeyExchange
  CertificateVerify*
  [ChangeCipherSpec]
  Finished                     --------&gt;
                                                    [ChangeCipherSpec]
                                &lt;--------                     Finished
  Application Data             &lt;-------&gt;             Application Data
</code></pre>
<p><code>*</code>表示可选步骤或与实际握手情况相关。比如重建已有连接，服务端无需执行Certificate，再比如使用RSA公钥加密时，无需ServerKeyExchange。  </p>
<blockquote>
<p>[!note]<br>完整的握手流程有时候也被称为2-RTT流程，即完整的握手流程需要客户端和服务端交互2次才能完成握手。</p>
</blockquote>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250402222553.png" alt="image.png"></p>
<ul>
<li>当客户端连接到支持TLS协议的服务端要求创建安全连接并列出了受支持的算法套件（包括加密算法、散列算法等），握手开始。</li>
<li>服务端从客户端的算法套件列表中指定自己支持的一个算法套件，并通知客户端</li>
<li>服务端发回其数字证书，此证书通常包含服务端的名称、受信任的证书颁发机构（CA）和服务端的公钥。</li>
<li>客户端确认其颁发的证书的有效性。</li>
<li>为了生成会话密钥用于安全连接，客户端和服务端分别基于椭圆曲线算法生成一对公私钥，并将公钥发送给对方。</li>
<li><a href="加密算法321-ecdh协商简要过程客户端和服务端分别基于自己的私钥和对端的公钥生成对称加密密钥.html" class="internal-link">加密算法<span class="tag">#3</span>.2.1. ECDH协商简要过程|客户端和服务端分别基于自己的私钥和对端的公钥生成对称加密密钥</a></li>
</ul>
<p>握手协议的结构如下，其中协议头的ContentType固定为<code>22</code>，接下来是TLS版本号，TLS1.2为<code>0303</code>，最后是用2字节表示长度。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022308372.png" alt="image.png"><br>HandshakeType握手协议类型包含以下：</p>
<ul>
<li>hello_request：0</li>
<li>client_hello：1</li>
<li>server_hello：2</li>
<li>certificate：3</li>
<li>server_key_exchange ：12</li>
<li>certificate_request：13</li>
<li>server_hello_done：14</li>
<li>certificate_verify：15</li>
<li>client_key_exchange：16</li>
<li>finished：20<blockquote>
<p>[!note]<br>Hello Message是具体的握手协议类型内容，不同协议内容有所不同。</p>
</blockquote>
</li>
</ul>
<h4>6.1.2.1. client hello</h4>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022316519.png" alt="image.png"></p>
<p>当客户端首次与服务端建立连接或需要重新协商加密握手会话时，需要将<code>Client Hello</code>作为第一条消息发送给服务端。<br><code>Client Hello</code>消息包含了许多重要信息，包括客户端版本号、客户端随机数、会话ID、密钥套件、压缩方式、扩展字段等。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022311071.png" alt="image.png"></p>
<ul>
<li>客户端版本号：客户端支持的最新TLS版本号，服务端会根据该协议号进行协议协商。</li>
<li>32位随机数：客户端生成的32位随机数。前4位是Unix时间戳，该时间戳为1970年1月1日0点以来的秒数。不过TLS并没有强制要求校验该时间戳，因此允许定义为其他值。后面28位为一个随机数。<blockquote>
<p>[!note]<br>通过前4字节填写时间方式，有效的避免了周期性的出现一样的随机数。使得&quot;随机&quot;更加&quot;随机&quot;。  在TLS握手时，客户端和服务端需要协商数据传输时的加密密钥。为了保证加密密钥的安全性。密钥需要通过客户端和服务端一起生成。客户端和服务端都提供一个32位的随机数，通过该随机数使用基于HMAC的PRF算法生成客户端和服务端的密钥。</p>
</blockquote>
</li>
<li>会话ID：用于表示客户端和服务端之间的会话。实际的会话ID是由服务端定义的，因此即使是新的连接，服务端返回的会话ID可能也会和客户端不一致，由于会话ID是明文传输的，因此不能存放机密信息。<ul>
<li>若会话ID是新的，则客户端和服务端需要建立完整的TLS握手连接流程。</li>
<li>若会话ID是较早连接的会话ID，则服务端可以选择无需执行完整的握手协议。</li>
</ul>
</li>
<li>算法套件：客户端将支持的加密算法组合排列后发送给服务端，从而和服务端协商加密算法。服务端根据支持算法在ServerHello返回一个最合适的算法组合。  </li>
<li>压缩方式：用于和服务端协商数据传输的压缩方式。由于TLS压缩存在安全漏洞，因此在TLS1.3中已经将TLS压缩功能去除，TLS1.2算法也建议不启用压缩功能。</li>
<li>扩展字段：可以在不改变底层协议的情况下，添加附加功能。客户端使用扩展请求其他功能，服务端若不提供这些功能，客户端可能会中止握手。对于扩展字段的详细定义可以看<a href="https://tools.ietf.org/html/rfc4366">Transport Layer Security (TLS) Extensions</a><blockquote>
<p>[!warning]<br>客户端发送完 <code>ClientHello</code> 消息后，将等待 <code>ServerHello</code> 消息。 服务端返回的任何握手消息（<code>HelloRequest</code> 除外）将被视为致命错误。</p>
</blockquote>
</li>
</ul>
<h4>6.1.2.2. server HEELO</h4>
<p>当服务端接收到<code>ClientHello</code>，则开始TLS握手流程， 服务端需要根据客户端提供的加密套件，协商一个合适的算法簇，其中包括对称加密算法、身份验证算法、非对称加密算法以及消息摘要算法。若服务端不能找到一个合适的算法簇匹配项，则会响应握手失败的预警消息。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022321226.png" alt="image.png"></p>
<ul>
<li>版本号：服务端根据客户端发送的版本号返回一个服务端支持的最高版本号。若客户端不支持服务端选择的版本号，则客户端必须发送<code>protocol_version</code>警报消息并关闭连接。<blockquote>
<p>[!note]</p>
<ul>
<li>若服务端接收到的版本号小于当前支持的最高版本，且服务端希望与旧客户端协商，则返回不大于客户端版本的服务端最高版本。</li>
<li>若服务端仅支持大于client_version的版本，则必须发送<code>protocol_version</code>警报消息并关闭连接。  </li>
<li>若服务端收到的版本号大于服务端支持的最高版本的版本，则必须返回服务端所支持的最高版本。</li>
</ul>
</blockquote>
</li>
<li>32位随机数：服务端生成的32位随机数，生成方式和客户端一样。服务端生成随机数的可以有效的防范中间人攻击，主要是通过防止重新握手后的<a href="https://security.stackexchange.com/questions/218491/why-using-the-premaster-secret-directly-would-be-vulnerable-to-replay-attack">重放攻击</a>。</li>
<li>会话ID：用于表示客户端和服务端之间的会话。若客户端提供了会话ID，则可以校验是否与历史会话匹配。<ul>
<li>若不匹配，则服务端可以选择直接使用客户端的会话ID或根据自定义规则生成一个新的会话ID，客户端需要保存服务端返回的会话ID当作本次会话的ID。</li>
<li>若匹配，则可以直接执行1-RTT握手流程，返回ServerHello后直接返回<code>ChangeCipherSpec</code>和<code>Finished</code>消息。</li>
</ul>
</li>
<li>算法套件：服务端根据客户端提供的算法套件列表和自己当前支持算法进行匹配，选择一个最合适的算法组合，若没有匹配项，则使用默认<code>TLS_RSA_WITH_AES_128_CBC_SHA</code>。<blockquote>
<p>[!note]<br>TLS1.2协议要求客户端和服务端都必须实现密码套件<code>TLS_RSA_WITH_AES_128_CBC_SHA</code></p>
</blockquote>
</li>
<li>压缩方式：用于和服务端协商数据传输的压缩方式。由于TLS压缩存在安全漏洞，因此在TLS1.3中已经将TLS压缩功能去除，TLS1.2算法也建议不启用压缩功能。</li>
<li>扩展字段：服务端需要支持接收具有扩展和没有扩展的ClientHello。服务端响应的扩展类型必须是<code>ClientHello</code>出现过才行，否则客户端必须响应<code>unsupported_extension</code>严重警告并中断握手。<blockquote>
<p>[!note]<br><a href="https://tools.ietf.org/html/rfc7568">RFC 7568</a>要求客户端和服务端握手时不能发送<code>{3,0}</code>版本，任何收到带有协议Hello消息的一方版本设置为<code>{3,0}</code>必须响应<code>protocol_version</code>警报消息并关闭连接。</p>
</blockquote>
</li>
</ul>
<p>通过<code>ClientHello</code>和<code>ServerHello</code>，客户端和服务端就协商好算法套件和用于生成密钥的随机数。</p>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022317581.png" alt="image.png"><br>密钥交换算法：ECDHE<br>身份认证算法：RSA<br>对称加密算法：AES_128_GCM<br>重要算法：SHA256</p>
<h4>6.1.2.3. certificate</h4>
<p>假设客户端和服务端使用默认的<code>TLS_RSA_WITH_AES_128_CBC_SHA</code>算法，在<code>ServerHello</code>完成后，服务端必须将本地的RSA证书传给客户端，以便客户端和服务端之间可以进行非对称加密保证对称加密密钥的安全性。<br>RSA的证书有2个作用：</p>
<ul>
<li>客户端可以对服务端的证书进行合法性进行校验。</li>
<li>对<code>Client Key Exchange</code>生成的pre-master key进行公钥加密，保证只有服务端可以解密，确保对称加密密钥的安全性。<br><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200526135246621-696721414.png" alt="20200526135243.png"><br>发送给客户端的是一系列证书，服务端的证书必须排列在第一位，排在后面的证书可以认证前面的证书。  当客户端收到了服务端的<code>ServerHello</code>时，若客户端也有证书需要服务端验证，则通过该握手请求将客户端的证书发送给服务端，若客户端没有证书，则无需发送证书请求到服务端。<blockquote>
<p>证书必须为<a href="https://baike.baidu.com/item/X.509/2817050?fr=aladdin">X.509v3格式</a>。</p>
</blockquote>
</li>
</ul>
<h4>6.1.2.4. Server Key Exchange</h4>
<p>使用RSA公钥加密，必须要保证服务端私钥的安全。若私钥泄漏，则使用公钥加密的对称密钥就不再安全。同时RSA是基于大数因式分解。密钥位数必须足够大才能避免密钥被暴力破解。</p>
<blockquote>
<p>[!warning]<br>1999年，RSA-155 (512 bits) 被成功分解。<br>2009年12月12日，RSA-768 (768 bits)也被成功分解。<br>在2013年的棱镜门事件中，某个CA机构迫于美国政府压力向其提交了CA的私钥，这就是十分危险的。</p>
</blockquote>
<p>相比之下，使用DH算法通过双方在不共享密钥的情况下双方就可以协商出共享密钥，避免了密钥的直接传输。DH算法是基于离散对数，计算相对较慢。而基于椭圆曲线密码（ECC）的DH算法计算速度更快，而且用更小的Key就能达到RSA加密的安全级别。ECC密钥长度为224~225位几乎和RSA2048位具有相同的强度。</p>
<blockquote>
<p>ECDH:基于ECC的DH算法。</p>
</blockquote>
<p>另外在DH算法下引入动态随机数，可以避免密钥直接传输。同时即使密钥泄漏，也无法解密其他消息，因为双方生成的动态随机数无法得知。</p>
<blockquote>
<p>在密码学中该特性被称为<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E4%BF%9D%E5%AF%86">前向保密</a><br>DHE: 通过引入动态随机数，具有前向保密的DH算法。<br>ECDHE：通过引入动态随机数，具有前保密的ECDH算法。</p>
</blockquote>
<h4>6.1.2.5. Certificate Request</h4>
<p>当需要TLS双向认证的时候，若服务端需要验证客户端的证书，则向客户端发送<code>Certificate Request</code>请求获取客户端指定类型的证书。</p>
<ul>
<li>服务端会指定客户端的证书类型。</li>
<li>客户端会确定是否有合适的证书。</li>
</ul>
<h4>6.1.2.6. Server Hello Done</h4>
<p>当服务端处理Hello请求结束时，发送<code>Server Hello Done</code>消息，然后等待接收客户端握手消息。客户端收到服务端该消息，有必要时需要对服务端的证书进行有效性校验。</p>
<p><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200526161424308-2087692628.png" alt="20200526161422.png"></p>
<h4>6.1.2.7. Client Certificate</h4>
<p>当客户端收到了服务端的<code>CertificateRequest</code>请求时，需要发送<code>Client Certificate</code>消息，若客户端无法提供证书，则仍要发送此消息，消息内容可以不包含证书。</p>
<p><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200526135246621-696721414.png" alt="20200526135243.png"></p>
<h4>6.1.2.8. Client Key Exchange</h4>
<p>客户端接收到ServerHelloDone消息后，计算密钥，通过发送<code>Client Key Exchange</code>消息给服务端。客户端和服务端通过<code>Key Exchange</code>消息交换密钥，使得双方的主密钥协商达成一致。</p>
<p><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200526175212460-1534904649.png" alt="20200526175211.png"></p>
<p>以RSA的密钥协商为例。在<code>ClientHello</code>和<code>ServerHello</code>分别在客户端和服务端创建了一个32位的随机数。客户端接收到<code>Server Hello Done</code>消息时，生成最后一个48位的预主密钥。通过服务端提供的证书进行公钥加密，以保证只有服务端的私钥才能解密。</p>
<blockquote>
<p>其中预主密钥的前2位要求使用<code>Client Hello</code>传输的TLS版本号（存在一些TLS客户端传递的时协商后的TLS版本号，对该版本号检查时可能会造成握手失败）。</p>
</blockquote>
<p>需要注意的是，若RSA证书的填空格式不正确，则可能会存在一个漏洞导致客户端发送的PreMasterSecret被中间人解密造成数据加密的对账密钥泄漏。可以看下<a href="https://eprint.iacr.org/2003/052">Attacking RSA-based Sessions in SSL/TLS</a></p>
<h4>6.1.2.9. Certificate Verify</h4>
<p>若服务端要求客户端发送证书，且客户端发送了非0长度的证书，此时客户端想要证明自己拥有该证书，则需要使用客户端私钥签名一段数据发送给服务端继续验证。该数据为客户端收发的所有握手数据的hash值（不包括本次消息）。</p>
<p><img src="https://img2020.cnblogs.com/blog/580757/202006/580757-20200619203949761-1258998351.png" alt="20200619203948.png"></p>
<h4>6.1.2.10. Finished</h4>
<p>当发送完<code>Change Cipher Spec</code>消息后必须立即发送该消息。当该消息用于验证密钥交换和身份验证过程是否成功。</p>
<p><img src="https://img2020.cnblogs.com/blog/580757/202005/580757-20200526175340642-1806058204.png" alt="20200526175339.png"></p>
<p><code>Finished</code>消息是第一个使用协商的算法簇进行加密和防篡改保护的消息。一旦双方都通过了该消息验证，就完成了TLS握手。<br>VerifyData为客户端收发的所有握手数据的hash值（不包括本次消息）。与<code>Certificate Verify</code>的hash值可能会不一样。如果发送过<code>Certificate Verify</code>消息，服务端的握手消息会包含<code>Certificate Verify</code>握手的数据。</p>
<blockquote>
<p>需要注意的是，握手数据不包括协议头的握手协议明文数据（服务端返回<code>Finished</code>的验证握手数据是包含接收到客户端的<code>Finished</code>的明文hash值）。</p>
</blockquote>
<blockquote>
<p><code>Finished</code>消息数据加密和<code>Appilication Data</code>一致，具体数据加密在<code>Application Data</code>段进行说明。</p>
</blockquote>
<h3>6.1.3. Change Cipher Protocol</h3>
<p>在此之前，双方通信基本是明文或处于密钥协商未完成状态，该消息发送后，后续消息切换为用选定的对称加密算法对后续数据加密后再传输，确保数据的机密性和完整性 。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022255474.png" alt="image.png"></p>
<h3>6.1.4. Alert Protocol</h3>
<p>警报消息传达消息的严重性（警告或致命）和警报的说明。具有致命级别的警报消息会导致立即终止连接。  若在改变密码标准协议前接收到警报消息，是明文传输的，无需解密。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022336824.png" alt="image.png"><br>与其他消息一样，警报消息按当前连接状态指定进行加密和压缩。在接收到改变密码标准协议后接收到警报协议，则需要进行解密。解密后即为警报协议明文格式。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022336612.png" alt="image.png"></p>
<h3>6.1.5. Application Data Protocol</h3>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022256036.png" alt="image.png"><br>当客户端和服务端<code>Finished</code>发送完毕并验证通过后，握手就结束了。后续所有数据都会使用握手协商的对称密钥进行数据加密。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202504022336114.png" alt="image.png"><br>TLS协议实现了数据加密和MAC计算。一般来说有3种加密模式，分别为：</p>
<ol>
<li>Mac-then-Encrypt：在明文上计算MAC，将其附加到数据，然后加密明和+MAC的完整数据。</li>
<li>加密和MAC：在明文上计算MAC，加密明文，然后将MAC附加到密文的末尾</li>
<li>Encrypt-then-Mac：加密明文，然后在密文上计算MAC，并将其附加到密文。<br>TLS协议使用的是<code>Mac-then-Encrypt</code>。首先将加密的序号、ContentType、数据长度、数据进计算HMAC-SHA256摘要。然后将摘要拼接到数据后，通过PKCS7格式对摘要+MAC数据进行填充对其和加密块大小一致。最后对<code>明文+MAC+对其填充块</code>进行加密。</li>
</ol>
<p>需要注意的是应用程序数据消息有最大长度限制<code>2^14 + 2048</code>，当超过长度后，数据需要分段传输。每一段都当作单独的数据段进行单独MAC地址并加密。</p>
<h1>7. TLS1.3</h1>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/tls1_3.png" alt="image.png"><br>TLS 1.3 的握手不再支持静态的 RSA 密钥交换，这意味着必须使用带有前向安全的Diffie-Hellman进行全面握手。客户端发送Client Hello时，附带了DH算法的公共参数和公钥，服务器返回Server Hello时，附带了DH算法生成的服务器公钥，即一次传输就完成了密钥交换。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>TLS 1.2</strong></th>
<th><strong>TLS 1.3</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>密码套件数量</strong></td>
<td>数十种（包含不安全选项）</td>
<td>仅 5 种官方套件（均为安全选项）</td>
</tr>
<tr>
<td><strong>密钥交换</strong></td>
<td>支持 RSA、DHE、ECDHE 等多种方式</td>
<td>仅支持 ECDHE（强制前向安全性）</td>
</tr>
<tr>
<td><strong>对称加密</strong></td>
<td>支持 CBC、GCM 等模式</td>
<td>仅支持 AEAD 模式（如 GCM、Poly1305）</td>
</tr>
<tr>
<td><strong>协商 RTT</strong></td>
<td>至少 1 个 RTT（复杂场景需 2 个 RTT）</td>
<td>仅需 1 个 RTT</td>
</tr>
<tr>
<td><strong>降级攻击防护</strong></td>
<td>需要 <code>fallback SCSV</code></td>
<td>无需（移除不安全套件）</td>
</tr>
</tbody></table>
<h2>7.1. 0-RTT</h2>
<p>TLS 1.3 的 0-RTT（零往返时间）特性允许客户端在首次与服务器建立连接后，后续连接时直接发送应用数据，无需等待TLS握手完成，从而消除了传统握手所需的至少 1 个 RTT 延迟。这一特性通过<strong>会话恢复</strong>和预共享密钥（PSK）机制实现。</p>
<h3>7.1.1. 基本原理</h3>
<p>0-RTT 的核心在于客户端和服务器之间<strong>预先共享密钥材料</strong>，使得客户端可以在新连接的第一个消息中就发送加密的应用数据。这依赖于两个关键技术：</p>
<ul>
<li><strong>PSK（预共享密钥）</strong>：服务器在首次握手时生成并存储一个会话密钥，客户端也保存该密钥的副本。</li>
<li><strong>Early Data（早期数据）</strong>：客户端使用PSK加密应用数据，并在新连接的初始消息中直接发送。</li>
</ul>
<h3>7.1.2. 建立过程</h3>
<p><strong>首次握手（建立 PSK）</strong><br>当客户端与服务器首次建立 TLS 1.3 连接时（使用 1-RTT 握手），服务器会生成一个<strong>会话票证（Session Ticket）</strong>，其中包含：</p>
<ul>
<li><strong>PSK（预共享密钥）</strong>：用于后续会话的加密密钥。</li>
<li><strong>Ticket 有效期</strong>：通常较短（如几小时），以平衡安全性和可用性。</li>
<li><strong>Ticket 标识</strong>：用于服务器识别该会话票证。<br>服务器将此会话票证加密后发送给客户端，客户端将其存储在本地（如浏览器缓存）。<br><strong>后续握手（使用 0-RTT）</strong><br>当客户端再次连接同一服务器时，流程如下：</li>
</ul>
<ol>
<li><strong>客户端发送 ClientHello</strong>：<ul>
<li>包含之前存储的会话票证（PSK 标识）。</li>
<li>标记 <code>early_data</code> 扩展，表示将发送 0-RTT 数据。</li>
<li>直接携带使用PSK加密的<strong>应用数据</strong>（如 HTTP 请求）。</li>
</ul>
</li>
<li><strong>服务器验证PSK</strong>：<ul>
<li>检查会话票证的有效性和未过期。</li>
<li>使用对应的 PSK 解密 0-RTT 数据。</li>
</ul>
</li>
<li><strong>服务器响应</strong>：<ul>
<li>发送ServerHello消息，完成标准的TLS 1.3握手（1-RTT）。</li>
<li>在此期间，服务器可以处理并响应0-RTT数据。</li>
</ul>
</li>
</ol>
<pre><code>ClientHello {
    ...
    extensions: [
        ...
        pre_shared_key: {
            identities: [
                {
                    obfuscated_ticket_age: &lt;age&gt;,
                    ticket: &lt;会话票证数据&gt;,  # 包含 PSK 标识
                    ...
                }
            ],
            binders: &lt;PSK 绑定值&gt;,  # 证明客户端拥有对应 PSK
        },
        early_data: &lt;是否发送 0-RTT 数据&gt;,  # 与 PSK 关联
        ...
    ]
}

ServerHello {
    ...
    extensions: [
        ...
        pre_shared_key: {
            selected_identity: &lt;客户端提供的票证索引&gt;,  # 服务器选择的 PSK
        },
        early_data: &lt;是否接受 0-RTT 数据&gt;,  # 与 PSK 关联
        ...
    ]
}
</code></pre>
<h3>7.1.3. 优缺点</h3>
<h4>7.1.3.1. 优点</h4>
<ul>
<li><strong>极致性能</strong>：完全消除握手延迟，适用于对延迟敏感的应用（如实时通信、金融交易）。</li>
<li><strong>简化流程</strong>：无需等待密钥交换和认证，直接发送数据。</li>
</ul>
<h4>7.1.3.2. 缺点</h4>
<ul>
<li><strong>重放攻击风险</strong>：由于0-RTT数据使用静态PSK加密，攻击者可能截获并重复发送相同的数据。例如，重复提交支付请求。</li>
<li><strong>有限的前向安全性</strong>：PSK基于之前的会话，若该会话密钥泄露，0-RTT数据可能被破解。</li>
<li><strong>服务器限制</strong>：服务器可能选择不接受 0-RTT 数据（如处理幂等性操作时）。</li>
</ul>
<h3>7.1.4. 安全防护机制</h3>
<p>为降低风险，TLS1.3对 0-RTT 施加了以下限制：</p>
<ul>
<li><strong>幂等性要求</strong>：建议0-RTT数据仅用于幂等操作（如读取请求），避免执行重复提交会产生副作用的操作（如支付）。</li>
<li><strong>PSK 有效期</strong>：会话票证的有效期较短，减少被滥用的时间窗口。</li>
<li><strong>Early Data 指示</strong>：服务器可以通过 <code>EarlyDataIndication</code> 扩展明确告知客户端哪些数据是通过 0-RTT 接收的，便于应用层处理。</li>
</ul>
<h3>7.1.5. PSk</h3>
<p>PSK 通过先前的TLS会话（如首次 1-RTT 握手）生成并分发，客户端和服务器各自存储一份副本，用于后续会话恢复。</p>
<pre><code>客户端 → 服务器：ClientHello
服务器 → 客户端：ServerHello, EncryptedExtensions, Certificate*, CertificateVerify*, Finished
客户端 → 服务器：Finished
服务器 → 客户端：NewSessionTicket  // 会话票证在此处发送
</code></pre>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/obsidian/202505142224574.png" alt=""><br>会话票证（<code>ticket</code> 字段）是一个加密的二进制数据，通常包含：</p>
<ul>
<li><strong>PSK（预共享密钥）</strong>：用于后续会话恢复。</li>
<li><strong>票证 ID</strong>：服务器用于识别该票证的唯一标识。</li>
<li><strong>绑定数据</strong>：确保票证只能用于特定的服务器配置。</li>
<li><strong>加密参数</strong>：如密钥派生函数和加密算法。</li>
</ul>
<h1>8. MTLS</h1>
<p>mtls(mutual tls)通过双向认证，可以保证连接的两端都有对应的私钥，以此来验证两端的身份合法性。mtls通常被用于zero trust安全框架，以验证组织内的用户、设备和服务器。<a href="mtls实现.html" class="internal-link">mtls实现</a>中提供了java版本的客户端和服务端实现。<br><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory20250606220928.png" alt="image.png"><br>在mTLS中，客户端和服务器都有一个证书，并且双方都使用它们的公钥/私钥对进行身份验证。与常规TLS相比，mTLS中需要<strong>服务端验证客户端证书</strong>。</p>
<blockquote>
<p>[!note]<br>使用身份证书相对于appcode来说，更为安全，避免了appcode在网络中传输、泄露的风险。</p>
</blockquote>
<ul>
<li><strong>中间人攻击</strong>：中间人攻击者把自己放在客户端和服务器之间，拦截或修改两者之间的通信。当使用mTLS时，在途攻击者不能对客户端或服务器进行身份验证，使这种攻击几乎不可能进行。</li>
<li><strong>欺骗攻击</strong>：攻击者可以试图在用户面前“伪装”（模仿）Web 服务器，或在 Web 服务器面前伪装用户。当双方都必须用 TLS 证书进行身份验证时，欺骗攻击就会困难得多。</li>
<li>暴力攻击：暴力攻击执行，是指攻击者使用快速试错法来猜测用户的密码。mTLS确保一个密码不足以获得对组织网络的访问权。</li>
<li><strong>网络钓鱼攻击</strong>：</li>
<li>目的通常是为了窃取用户的凭据，然后利用这些凭据入侵网络或应用。即使用户上当受骗，攻击者仍然需要TLS证书和相应的私钥才能使用这些凭据。</li>
<li>恶意 API 请求：当用于API安全时，mTLS可确保API请求只来自合法的、经过身份验证的用户。这可以阻止攻击者发送恶意的API请求来利用漏洞或破坏API的预期运作方式。<blockquote>
<p>[!note] 与token、session/cookie等关系<br>mtls可以更安全地实现身份认证，但无法提供token、session/cookie等提供的权限控制能力。比如token中可以通过携带服务端签名的角色、权限等信息。</p>
</blockquote>
</li>
</ul>
<h1>9. SNI（Server Name Indication）</h1>
<p>Web服务器或负载均衡器承载多个域名，仅IP地址不足以指示用户尝试访问哪个域。这可能会导致服务器显示错误的SSL 证书，从而阻止或终止 HTTPS 连接。</p>
<blockquote>
<p>[!note]<br>当多个网站托管在一台服务器上并共享一个IP地址，并且每个网站都有自己的SSL证书，在客户端设备尝试安全地连接到其中一个网站时，服务器可能不知道显示哪个 SSL 证书。这是因为SSL/TLS 握手发生在客户端设备通过HTTP 连接到某个网站<strong>之前</strong>(http host header)。</p>
</blockquote>
<p>SNI是TLS协议的扩展，以确保客户端设备能够看到他们尝试访问的网站的正确SSL证书。该扩展使得可以在TLS握手期间指定网站的主机名或域名 ，而不是在握手之后打开HTTP连接时指定。</p>
<p>简而言之，即使网站<code>https://www.example.com</code>托管在与<code>https://www.something.com</code>、<code>https://www.another-website.com</code>和<code>https://www.example.io</code>相同的地方（相同的IP地址），SNI也能让用户的设备与<code>https://www.example.com</code>建立安全的连接。</p>
<p>SNI在2003年被添加为TLS/SSL的扩展；它最初不是协议的一部分。几乎所有的浏览器、操作系统和Web服务器都支持它，除了一些仍在使用的最旧的浏览器和操作系统。</p>
<h1>10. ref</h1>
<p><a href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a><br><a href="https://segmentfault.com/a/1190000021559557">https://segmentfault.com/a/1190000021559557</a><br><a href="https://www.cnblogs.com/Jack-Blog/p/13170728.html">TLS1.2协议设计原理</a><br><a href="https://developer.aliyun.com/article/1245100">https://developer.aliyun.com/article/1245100</a></p>
}
    </section>
</article>
            </div>
        </main>
        <footer class="page-footer">
            <div class="container">
                <p>&copy; 2026 Shinerio's Blog. All rights reserved.</p>
            </div>
        </footer>
    </div>

    <script>
        // Theme switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('theme-toggle');
            const body = document.getElementById('theme-body');

            // Check for saved theme preference or respect OS preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

            // Set initial theme
            if (savedTheme === 'dark' || (!savedTheme && prefersDarkScheme.matches)) {
                body.setAttribute('data-theme', 'dark');
            } else {
                body.removeAttribute('data-theme'); // light theme
            }

            // Toggle theme function
            function toggleTheme() {
                if (body.getAttribute('data-theme') === 'dark') {
                    body.removeAttribute('data-theme');
                    localStorage.setItem('theme', 'light');
                } else {
                    body.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                }
            }

            // Add event listener to theme toggle button
            themeToggle.addEventListener('click', toggleTheme);

            // Listen for OS theme changes
            prefersDarkScheme.addEventListener('change', function(e) {
                if (!localStorage.getItem('theme')) {
                    if (e.matches) {
                        body.setAttribute('data-theme', 'dark');
                    } else {
                        body.removeAttribute('data-theme');
                    }
                }
            });

            // Search functionality
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const searchResults = document.getElementById('search-results');
            const searchSuggestions = document.getElementById('search-suggestions');
            const searchTypeRadios = document.querySelectorAll('input[name="search-type"]');

            if (searchInput && searchButton) {
                let searchData = null;

                // Load search data
                async function loadSearchData() {
                    try {
                        const response = await fetch('./assets/js/search-data.json');
                        if (response.ok) {
                            searchData = await response.json();
                        } else {
                            console.error('Failed to load search data:', response.status);
                        }
                    } catch (error) {
                        console.error('Error loading search data:', error);
                    }
                }

                // Initialize search data
                loadSearchData();

                // Debounce function to limit search calls
                function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }

                // Get selected search type
                function getSelectedSearchType() {
                    const selectedRadio = document.querySelector('input[name="search-type"]:checked');
                    return selectedRadio ? selectedRadio.value : 'all';
                }

                // Perform search
                function performSearch(query) {
                    if (!searchData || !query.trim()) {
                        searchResults.innerHTML = '';
                        searchSuggestions.innerHTML = '';
                        return;
                    }

                    const queryTerms = query.toLowerCase().split(/\s+/).filter(term => term.length > 0);
                    const searchType = getSelectedSearchType();

                    if (queryTerms.length === 0) {
                        searchResults.innerHTML = '';
                        return;
                    }

                    const results = [];

                    // Search through articles
                    searchData.articles.forEach(article => {
                        let score = 0;
                        let snippet = '';

                        // Get content based on search type
                        const lowerTitle = article.title.toLowerCase();
                        const lowerContent = article.content.toLowerCase();
                        const lowerTags = article.tags.join(' ').toLowerCase();

                        queryTerms.forEach(term => {
                            switch(searchType) {
                                case 'title':
                                    // Only title matches count
                                    if (lowerTitle.includes(term)) {
                                        score += 10;
                                    }
                                    break;
                                case 'content':
                                    // Only content matches count (fixed to exclude title matches)
                                    if (lowerContent.includes(term)) {
                                        score += 1;
                                    }
                                    break;
                                case 'all':
                                default:
                                    // Both title and content matches count
                                    if (lowerTitle.includes(term)) {
                                        score += 10;
                                    }
                                    if (lowerContent.includes(term)) {
                                        score += 1;
                                    }
                                    // Tag matches get medium-high score
                                    if (lowerTags.includes(term)) {
                                        score += 5;
                                    }
                                    break;
                            }
                        });

                        if (score > 0) {
                            // Generate snippet based on search type
                            let content = '';

                            if (searchType === 'title') {
                                // For title-only search, show title content
                                content = article.title.substring(0, 200);
                            } else if (searchType === 'content') {
                                // For content-only search, show content excerpt
                                content = article.content.substring(0, 200);
                            } else {
                                // For all search, show content with title as context
                                content = article.content.substring(0, 200);
                            }

                            // Find first occurrence of query term in content for snippet
                            queryTerms.forEach(term => {
                                let searchIn = content.toLowerCase();
                                if (searchType === 'title') {
                                    searchIn = lowerTitle;
                                } else if (searchType === 'content') {
                                    searchIn = lowerContent;
                                }

                                const index = searchIn.indexOf(term);
                                if (index !== -1) {
                                    // Expand snippet around the match
                                    let start, end;
                                    if (searchType === 'title') {
                                        start = Math.max(0, index - 15);
                                        end = Math.min(content.length, index + term.length + 35);
                                    } else {
                                        start = Math.max(0, index - 30);
                                        end = Math.min(content.length, index + term.length + 70);
                                    }

                                    content = (start > 0 ? '...' : '') +
                                              content.substring(start, end) +
                                              (end < (searchType === 'title' ? article.title.length : article.content.length) ? '...' : '');

                                    // Highlight the term in the snippet
                                    const searchContent = searchType === 'title' ? article.title : article.content;
                                    const adjustedIndex = searchType === 'title' ?
                                        Math.min(index, article.title.length - 1) :
                                        Math.min(index, article.content.length - 1);

                                    content = content.replace(
                                        new RegExp(`(${escapeRegExp(term)})`, 'gi'),
                                        '<mark>$1</mark>'
                                    );
                                }
                            });

                            results.push({
                                article: article,
                                score: score,
                                snippet: content
                            });
                        }
                    });

                    // Sort results by score
                    results.sort((a, b) => b.score - a.score);

                    // Display results
                    displaySearchResults(results);
                }

                // Display search results
                function displaySearchResults(results) {
                    if (results.length === 0) {
                        searchResults.innerHTML = '<p class="no-results">未找到匹配的文章</p>';
                        return;
                    }

                    const resultsHTML = results.map(result => `
                        <div class="search-result-item">
                            <h3 class="search-result-title">
                                <a href="./${result.article.slug}.html">${highlightQueryTerms(result.article.title, document.querySelector('#search-input').value)}</a>
                            </h3>
                            <div class="search-result-meta">
                                ${result.article.tags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                            </div>
                            <p class="search-result-excerpt">${result.snippet}</p>
                        </div>
                    `).join('');

                    searchResults.innerHTML = resultsHTML;
                }

                // Highlight query terms in text
                function highlightQueryTerms(text, query) {
                    if (!query.trim()) return text;

                    const queryTerms = query.split(/\s+/).filter(term => term.length > 0);
                    let highlightedText = text;

                    queryTerms.forEach(term => {
                        const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
                        highlightedText = highlightedText.replace(regex, '<mark>$1</mark>');
                    });

                    return highlightedText;
                }

                // Escape special regex characters
                function escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                // Event listener for search button
                searchButton.addEventListener('click', function() {
                    const query = searchInput.value;
                    performSearch(query);
                });

                // Event listener for Enter key
                searchInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        const query = searchInput.value;
                        performSearch(query);
                    }
                });

                // Add debounced input handler for live search (optional)
                const debouncedSearch = debounce(function() {
                    const query = searchInput.value;
                    performSearch(query);
                }, 300);

                searchInput.addEventListener('input', debouncedSearch);

                // Add event listeners for search type radios
                searchTypeRadios.forEach(radio => {
                    radio.addEventListener('change', function() {
                        const query = searchInput.value;
                        if (query.trim()) {
                            performSearch(query);
                        }
                    });
                });
            }
        });
    </script>
</body>
</html>