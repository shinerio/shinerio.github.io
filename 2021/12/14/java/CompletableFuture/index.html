<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="CompletableFuture"><meta name="keywords" content="java, 异步编程, shinerio's blog"><link rel="alternate" href="/atom.xml" title="shinerio's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://shinerio.cc/2021/12/14/java/CompletableFuture/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>CompletableFuture - shinerio's blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">shinerio's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories">
        <li class="mobile-menu-item">分类
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">shinerio's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            分类
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">CompletableFuture
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-12-14
        </span><span class="post-category">
            <a href="/categories/异步编程/">异步编程</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类声明"><span class="toc-text">类声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开启异步方法"><span class="toc-text">开启异步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主动完成计算"><span class="toc-text">主动完成计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算完成时处理"><span class="toc-text">计算完成时处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转换"><span class="toc-text">转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消费"><span class="toc-text">消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合"><span class="toc-text">组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Either"><span class="toc-text">Either</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#allOf和anyOf"><span class="toc-text">allOf和anyOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>JAVA 5中引入了Future特性，可以获取异步执行结果。Future多用于使用线程池执行任务后获取任务结果，当我们submit一个callable的任务时可以获取一个Future对象，通过调用get()方法阻塞获得任务结果，或者通过轮训isDone()来判断任务是否执行完成。阻塞式的方式与异步的初衷相违背，而轮询的方式又会浪费CPU资源，通过观察者模式则可以实现在完成计算时通知订阅者。JAVA8引入了一系列优秀的特性，包括lambda表达式，steam流式操作，同时也引入了CompletableFuture来提供更优雅的异步编程手段。</p>
<a id="more"></a>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> CompletableFuture除了实现了Future接口之外，还实现了CompletionStage接口。CompletionStage提供了一系列丰富的接口和函数式编程的能力，可以添加一些回调函数用于任务完成时触发，通过这个异步任务流的方式可以构建出一个非阻塞的系统。</p>
<h2 id="开启异步方法"><a href="#开启异步方法" class="headerlink" title="开启异步方法"></a>开启异步方法</h2><p>completedFuture是一个静态辅助方法，用来返回一个已经计算好的CompletableFuture。此外，CompletableFuture提供了四个方法来开启一个异步方法，其中CompletableFuture.supplyAsync()支持返回值，而CompletableFuture.runAsync()不支持返回值。如果不指定Executor，则使用ForkJoinPool.commonPool()，ForkJoinPool的commonPool是一个静态方法，提供公共的线程池共业务使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">CompletableFuture&lt;String&gt; result = CompletableFuture.completedFuture(<span class="string">"Run Over!"</span>);</span><br><span class="line">      CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"test run async, ForkJoin.commonPool!"</span>));</span><br><span class="line">      CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"test run async, customize thread pool!"</span>), executor);</span><br><span class="line">      CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supply async, ForJoin.CommonPool!"</span>);</span><br><span class="line">      CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">"supply async, customize thread pool!"</span>, executor);</span><br></pre></td></tr></table></figure>
<h2 id="主动完成计算"><a href="#主动完成计算" class="headerlink" title="主动完成计算"></a>主动完成计算</h2><p>CompletableFuture类实现了CompletionStage和Future接口，所以可以像Future以前一样通过阻塞或者轮询的方式获得结果，但是这种方式不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞式等待任务执行完成，获得执行结果或异常，抛出的异常为checked exception</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T 	<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 等待超时时间后，抛出TimeoutException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T 	<span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//立即获得结果，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的valueIfAbsent值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T 	<span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 阻塞式等待任务执行完成，获得执行结果或异常，抛出的异常为unchecked exception（CompletionException）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T 	<span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>checked exception异常通常指RunTimeException及其子类，RuntimeException在默认情况下会得到自动处理。所以通常用不着捕获RuntimeException，但在自己的封装里，也许仍然要选择抛出一部分RuntimeException。RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException的任何子类都无需在throws子句中进行声明。例如NullPointerException。除了RuntimeException以外的异常，都属于checkedException，它们都在java.lang库内部定义。Java编译器要求程序必须捕获或声明抛出这种异常。例如InterruptedException。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.getNow(<span class="string">"get Now"</span>));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>get Now</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(future.get(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">	System.out.println(<span class="string">"Timeout"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Timeout</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If not already completed, sets the value returned by get() and related methods to the given value.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//f not already completed, causes invocations of get() and related methods to throw the given exception.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Forcibly sets or resets the value subsequently returned by method get() and related methods, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Forcibly causes subsequent invocations of method get() and related methods to throw the given exception, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtrudeException</span><span class="params">(Throwable ex)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>obtrudeValue、obtrudeException可以在计算完成的时候重新设置结果值，但是使用的时候要非常谨慎，因为complete已经触发了后续流程，有可能导致得不到期望的结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.complete(<span class="string">"run over now!"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>run over now!</p>
</blockquote>
<figure class="highlight java"><figcaption><span>CompletableFuture<string> future </string></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">future.obtrudeValue(<span class="string">"reset run over"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>reset run over</p>
</blockquote>
<h2 id="计算完成时处理"><a href="#计算完成时处理" class="headerlink" title="计算完成时处理"></a>计算完成时处理</h2><p>当completableFuture计算结果完成，或者抛出异常的时候，可以通过如下方法指定特定的Action。action参数的类型为<code>(BiConsumer&lt;? super T,? super Throwable&gt;</code>，代表可以处理正常的计算结果，也可以处理异常情况。when开头的方法当action执行完成后，会返回原始的CompletableFuture计算结果或异常，而exceptionally则返回一个新的CompletableFuture对象。exceptionally用来处理当原始CompletableFuture抛出异常的时候，触发计算，否则以原始CompletableFuture作为返回结果。方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; 	<span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure>
<p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由BiFunction参数计算而得。因此这组方法兼有whenComplete和转换的两个功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; 	<span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; System.out.println(v));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>run over</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; System.out.println(e)).exceptionally(Throwable::toString);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero<br>java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</p>
</blockquote>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>通过回调机制，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉CompletableFuture当计算完成的时候请执行某个function。而且我们还可以将这些操作串联起来，或者将CompletableFuture组合起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; 	<span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>这一组函数的作用在于当原始CompletableFuture计算完成后，可以将结果传递给回调函数fn，将fn的结果作为新的CompletableFuture结果计算。将<code>CompletableFuture&lt;T&gt;</code>转换成<code>CompletableFuture&lt;U&gt;</code>。这里的转换不是阻塞式的，而是等去前一个stage完成后，回调执行的。这些方法和handle方法的区别在于，这些方案只会计算正常值，有异常就会抛出，而handle方法可以处理异常，避免异常继续抛出。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenApply(ret -&gt; ret + <span class="string">"\nrun over"</span>).whenComplete((v, e) -&gt; System.out.println(v));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>run over<br>run over</p>
</blockquote>
<h2 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h2><p>上面的方法是当计算完成的时候，会生成新的计算结果(thenApply, handle)，或者返回同样的计算结果whenComplete，CompletableFuture还提供了一种处理结果的方法，只对结果执行Action，而不返回新的计算值，因此计算值为Void。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenAccept(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>run over</p>
</blockquote>
<p>thenAcceptBoth以及相关方法提供了类似的功能，当原始completableFuture和传入的other completableFuture都正常完成计算的时候，就会执行提供的action。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; 	<span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenAcceptBoth(other, (v1, v2) -&gt; System.out.println(v1 + <span class="string">"\n"</span> + v2));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>run over<br>other run over</p>
</blockquote>
<p>thenRun是当原始completableFuture计算完成是，就会执行另一个runnable；runAfterBoth是当两个CompletionStage都正常完成计算的时候，执行一个Runnable。这个Runnable并不使用计算的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRun</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,  Runnable action)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run over"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"exception"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenRun(() -&gt; System.out.println(<span class="string">"no input, do nothing"</span>));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>no input, do nothing</p>
</blockquote>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>compose系列方法接收一个Function作为参数，这个Function的输入是当前CompletableFuture的计算值，返回结果是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; 	<span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>compose和apply的区别在于，compose中提供的Function返回是CompletionStage，而apply中的Function返回的是一个普通对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">"run over"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="string">"other run over"</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; compose = future.thenCompose((v) -&gt; other);</span><br><span class="line">CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt; apply = future.thenApply(v -&gt; other);</span><br></pre></td></tr></table></figure>
<p>combine方法用来组合两个stage，将两个stage的输出作为后续异步流的输入，combine和acceptBoth方法的区别在于，acceptBoth没有返回值，combine有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; 	<span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; 	<span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; 	<span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; other = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line">future.thenCombine(other, (v1, v2) -&gt; v1 * v2).whenComplete((v, e) -&gt; System.out.println(v));</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>200</p>
</blockquote>
<h2 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h2><p>thenAcceptBoth和runAfterBoth是当两个CompletableFuture都计算完成，either实现是当任意一个CompletableFuture计算完成的时候就会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T,U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span> + random.nextInt(<span class="number">3</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;&#125;);</span><br><span class="line">CompletableFuture&lt;Integer&gt; other = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span> + random.nextInt(<span class="number">3</span>) );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;&#125;);</span><br><span class="line">future.acceptEither(other, System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码有时候输出10，有时候输出20</p>
<h2 id="allOf和anyOf"><a href="#allOf和anyOf" class="headerlink" title="allOf和anyOf"></a>allOf和anyOf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt;  <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>
<p>allOf方法是当所有的CompletableFuture都执行完后执行计算。anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。anyOf的返回值是其中一个CompletableFuture的计算结果，而applyToEither返回值的计算结果要结果Function处理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">https://colobu.com/2016/02/29/Java-CompletableFuture/</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://shinerio.cc">shinerio</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://shinerio.cc/2021/12/14/java/CompletableFuture/">https://shinerio.cc/2021/12/14/java/CompletableFuture/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/">java</a>
            <a href="/tags/异步编程/">异步编程</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/12/18/java/Reactor编程（一）/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Reactor编程（一）</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2021/12/03/系统设计/分布式事务一致性/">
        <span class="next-text nav-default">分布式事务一致性</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:jstxzhangrui@163.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/shinerio" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">shinerio</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://shinerio.cc/2021/12/14/java/CompletableFuture/';
        this.page.identifier = '2021/12/14/java/CompletableFuture/';
        this.page.title = 'CompletableFuture';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//shinerio.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
