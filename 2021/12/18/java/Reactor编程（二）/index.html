<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Reactor编程（二）"><meta name="keywords" content="java, 异步编程, reactor, shinerio's blog"><link rel="alternate" href="/atom.xml" title="shinerio's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://shinerio.cc/2021/12/18/java/Reactor编程（二）/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>Reactor编程（二） - shinerio's blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">shinerio's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories">
        <li class="mobile-menu-item">分类
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">shinerio's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            分类
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Reactor编程（二）
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-12-18
        </span><span class="post-category">
            <a href="/categories/异步编程/">异步编程</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CompleteFuture"><span class="toc-text">1. CompleteFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Reactor"><span class="toc-text">2. Reactor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-组合型和可读性"><span class="toc-text">2.1 组合型和可读性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-流失处理"><span class="toc-text">2.2 流失处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-operator"><span class="toc-text">2.3 operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-惰性计算"><span class="toc-text">2.4 惰性计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-背压（Backpressure）"><span class="toc-text">2.5 背压（Backpressure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-hot-vs-cold"><span class="toc-text">2.6 hot vs cold</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-reactor-core"><span class="toc-text">2.7 reactor-core</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-Flux-0-N-项的异步序列"><span class="toc-text">2.7.1 Flux, 0-N 项的异步序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-Mono-0-1异步结果"><span class="toc-text">2.7.2 Mono, 0-1异步结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-工厂方法"><span class="toc-text">2.7.3 工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-subscribe"><span class="toc-text">2.7.4 subscribe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-5-Disposable"><span class="toc-text">2.7.5 Disposable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-6-自定义序列器"><span class="toc-text">2.7.6 自定义序列器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-6-1-同步生成"><span class="toc-text">2.7.6.1 同步生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-6-2-异步多线程生成"><span class="toc-text">2.7.6.2 异步多线程生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-6-3-异步单线程生成"><span class="toc-text">2.7.6.3 异步单线程生成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-7-filter和map"><span class="toc-text">2.7.7 filter和map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-8-handle"><span class="toc-text">2.7.8 handle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-9-Threading-and-Schedulers"><span class="toc-text">2.7.9 Threading and Schedulers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-10-publishOn和subscribeOn"><span class="toc-text">2.7.10 publishOn和subscribeOn</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-10-1-publishOn"><span class="toc-text">2.7.10.1 publishOn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-10-2-subscribeOn"><span class="toc-text">2.7.10.2 subscribeOn</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Reactor重构"><span class="toc-text">3. Reactor重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-参考链接"><span class="toc-text">4. 参考链接</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>Java 提供了两种异步编程模型：</p>
<ul>
<li><strong>回调</strong>：异步方法没有返回值，但需要一个额外的 callback参数（一个 lambda 或匿名类），当结果可用时会被调用。</li>
<li><strong>Futures</strong>：异步方法立即返回一个Future<t>。异步过程计算一个T值，但Future对象包装了对它的访问。该值不会立即可用，并且可以轮询该对象直到该值可用。例如，一个ExecutorService正在运行的Callable<t>任务使用Future对象。</t></t></li>
</ul>
<p>两种方式各有优劣，回调代码很难组合在一起，很快导致代码难以阅读和维护。Future比回调稍微好点，通过CompleteFuture，我们将多个Future对象编排 在一起。但Future也有一些缺点，它不支持惰性计算，没有背压能力，缺乏对多个值和高级错误处理的支持。</p>
<a id="more"></a>
<h2 id="1-CompleteFuture"><a href="#1-CompleteFuture" class="headerlink" title="1. CompleteFuture"></a>1. CompleteFuture</h2><p>在学习Reactor之前，我们先尝试使用CompleteFuture实现一段功能，稍后我们会使用Reactor就行重构，以此来体现Reactor代码编程的优美。 </p>
<p>我们根据用户订单获取到一个bookId的list，然后需要找出每个bookId对应的书名和作者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">		put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">		put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">		put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">CompletableFuture&lt;List&lt;Integer&gt;&gt; ids = CompletableFuture.supplyAsync(() -&gt; Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">ids.thenComposeAsync(idList -&gt; &#123;</span><br><span class="line">	List&lt;CompletableFuture&lt;String&gt;&gt; nameAuthorPair = idList.stream().map(</span><br><span class="line">			id -&gt; &#123;</span><br><span class="line">				CompletableFuture&lt;String&gt; name = CompletableFuture.supplyAsync(() -&gt; books.get(id).getName());</span><br><span class="line">				CompletableFuture&lt;String&gt; author = CompletableFuture.supplyAsync(() -&gt; books.get(id).getAuthor());</span><br><span class="line">				<span class="keyword">return</span> name.thenCombineAsync(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">			&#125;</span><br><span class="line">	).collect(Collectors.toList());</span><br><span class="line">	<span class="keyword">return</span> CompletableFuture.allOf(</span><br><span class="line">			nameAuthorPair.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]))</span><br><span class="line">			.thenApply(v -&gt; nameAuthorPair.stream().map(CompletableFuture::join).collect(Collectors.toList()));</span><br><span class="line">&#125;).whenComplete((v, e) -&gt; v.forEach(System.out::println));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for compute</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-Reactor"><a href="#2-Reactor" class="headerlink" title="2. Reactor"></a>2. Reactor</h2><p>反应式库，例如 Reactor，旨在解决 JVM 上“经典”异步方法的这些缺点，同时还关注一些其他方面：</p>
<ul>
<li>可组合性和可读性</li>
<li>使用一系列丰富的运算符来流式处理数据</li>
<li>惰性计算，在subscribe之前，不会进行任何计算</li>
<li>背压能力，消费者向生产者发出生产速率过高的信号的能力</li>
<li>与并发无关的，具有高价值的高阶抽象</li>
</ul>
<h3 id="2-1-组合型和可读性"><a href="#2-1-组合型和可读性" class="headerlink" title="2.1 组合型和可读性"></a>2.1 组合型和可读性</h3><p>“可组合性”是指编排多个异步任务的能力，我们使用先前任务的结果作为后续任务的输入。或者，我们可以以 fork-join 方式运行多个任务。此外，我们可以在更高级别的系统中将异步任务重用为离散组件。</p>
<p>编排任务的能力与代码的可读性和可维护性紧密相关。随着异步进程层数和复杂性的增加，编写和读取代码变得越来越困难。正如我们所见，回调模型很简单，但它的主要缺点之一是，对于复杂的流程，您需要从回调中执行回调，回调本身嵌套在另一个回调中，依此类推。这种混乱被称为“回调地狱”。您可以猜到（或从经验中知道），这样的代码很难回溯和推理。</p>
<p>Reactor 提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且所有内容通常都保持在同一级别（最小化嵌套）。</p>
<h3 id="2-2-流失处理"><a href="#2-2-流失处理" class="headerlink" title="2.2 流失处理"></a>2.2 流失处理</h3><p>您可以将反应式应用程序处理的数据想象成一个商品在一个流水线上处理。Reactor即是传送带又是工作站。原材料从一个来源（原始Publisher）倾倒并最终成为准备推向消费者（或Subscriber）的成品。</p>
<p>原材料可以经过各种转换和其他中间步骤，或者成为将中间件聚合在一起的更大装配线的一部分。如果某一点出现故障或堵塞（可能装箱产品花费的时间过长），受影响的工作站可以向上游发出信号以限制原材料的流动。</p>
<h3 id="2-3-operator"><a href="#2-3-operator" class="headerlink" title="2.3 operator"></a>2.3 operator</h3><p>在Reactor中，operator可以类比为流水线上的工作站。每个operator代表了Publisher的一种行为，用来将上一步的Publisher输出包装到一个新实例中。整个链条因此被链接起来，使得数据从第一个Publisher开始并沿着链条向下移动，由每个节点转换。最终，最后一个Subscriber完成了该过程。并且在 Subscriber订阅Publisher之前什么也不会发生。</p>
<p>Reactor等响应式库最有价值的一点就是它们提供的丰富的operate能力，涵盖从简单的转换和过滤到复杂的编排和错误处理等多方面。</p>
<h3 id="2-4-惰性计算"><a href="#2-4-惰性计算" class="headerlink" title="2.4 惰性计算"></a>2.4 惰性计算</h3><p>在 Reactor 中，当您编写Publisher链时，默认情况下数据不会开始注入其中。因此，可以基于此创建异步流程的抽象描述（这有助于可重用性和组合）。</p>
<p>通过订阅行为，将绑定Publisher到Subscriber，这会触发整个链中的数据流。内部实现原理是，通过一个subscriber的一个request信号触发，并逐级传播到上游，以至于最终的源publisher</p>
<h3 id="2-5-背压（Backpressure）"><a href="#2-5-背压（Backpressure）" class="headerlink" title="2.5 背压（Backpressure）"></a>2.5 背压（Backpressure）</h3><p>像上游传播的信号也可以用来实现背压，我们可以类比在生产流水线中，某个生产节点处理比上游的节点慢时，可以向上游反馈信号。</p>
<p>Reactive Streams规范定义的真正机制与类比非常接近。订阅者可以在无界模式下工作，让源以最快的速度推送所有数据，也可以通过request机制向源发送信号，表示他最多可以处理n个元素。整个流中，中间的operator还可以改变这个request，比如可以通过buffer将元素以10个一组进行分组。一些中间的节点还可以有自己的缓存机制，如果下游从上游拉元素，如果有缓存，则可以直接push，否则会向上游请求。</p>
<h3 id="2-6-hot-vs-cold"><a href="#2-6-hot-vs-cold" class="headerlink" title="2.6 hot vs cold"></a>2.6 hot vs cold</h3><p>Rx系列响应式库区主要分为两类响应序列：hot和cold。这种区别主要与响应流如何对订阅者做出响应有关：</p>
<ul>
<li><strong>cold</strong>：一个冷序列对每个Subscriber提供从头开始的完整的元数据。例如，如果源包装了一个HTTP调用，那么每一个订阅都是一个新的HTTP请求。</li>
<li><strong>hot</strong>：一个热序列不对每个subscriber提供完整的数据。相反，迟到的订阅者会收到订阅后发出的消息。但是可能存在一些热响应流可以全部或部分缓存或重放消息历史。从一般的角度来看，当没有订阅者正在监听时，热序列甚至可以推出消息（这是“订阅前什么都不会发生”规则的一个例外）。</li>
</ul>
<h3 id="2-7-reactor-core"><a href="#2-7-reactor-core" class="headerlink" title="2.7 reactor-core"></a>2.7 reactor-core</h3><p>Reactor工程的主要artifact是<code>reactor-core</code>，一个Java 8下面，专注于响应式流lib。可以通过如下方式引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Reactor引入了可组合的反应类型，其实现Publisher接口，同时也提供了丰富的operator：Flux和Mono。一个Flux对象表示一个包含0..N个对象的序列，而一个Mono对象表示一个单值或空 (0..1) 结果。</p>
<p>这两种有类型本身携带了一些语义信息，可以对其自身代表的数据容量有个大致预估。比如一个HTTP请求只产生一个响应，所以做一个Flux操作没有多大意义。因此，将此类 HTTP 调用的结果表示为Mono<httpresponse>比将其表示为Flux<httpresponse>更有意义，因为它仅提供与零项或一项的上下文相关的operator。</httpresponse></httpresponse></p>
<p>有时候，流式处理过程中operator也会有切换。例如，count运算符存在于中Flux，但它返回一个 Mono<long>。</long></p>
<h4 id="2-7-1-Flux-0-N-项的异步序列"><a href="#2-7-1-Flux-0-N-项的异步序列" class="headerlink" title="2.7.1 Flux, 0-N 项的异步序列"></a>2.7.1 Flux, 0-N 项的异步序列</h4><p>下图是Flux的一个典型工作流：</p>
<p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639834040985.png" alt="enter description here"></p>
<p>Flux<t>是一个标准Publisher<t>，表示 0 到 N 个异步消息序列，可以由完成信号或错误信号终止。如图所示，有三种信号可以分别触发下游订阅者的onNext，onComplete和onError方法。</t></t></p>
<p>重要的是所有事件，包括终止事件，都是可选的。没有onNext事件，但是有onComplete事件代表一个空的有限序列。但是移除onComplete，代表一个无限的空序列（不是特别有用，除了围绕取消的测试）。同样，无限序列也不一定是空的。例如，Flux.interval(Duration) 产生一个时钟触发的规律的无限序列Flux<long></long></p>
<h4 id="2-7-2-Mono-0-1异步结果"><a href="#2-7-2-Mono-0-1异步结果" class="headerlink" title="2.7.2 Mono, 0-1异步结果"></a>2.7.2 Mono, 0-1异步结果</h4><p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639834718028.png" alt="enter description here"></p>
<p>Mono<t>是一种特殊的Publisher<t>，它通过onNext信号产生最多一个事件，随着一个onComplete信号（成功Mono，有或没有值）而终止，或者只发出一个onError信号（失败Mono）。</t></t></p>
<p>大多数Mono实现预计会在调用onNext成功后立即调用onComplete。Mono.never()是一个异常值：它不发出任何信号，这在技术上并没有被禁止，尽管其在测试之外并不是非常有用。另一方面，onNext和onError的组合是明确禁止的。</p>
<p>Mono仅提供Flux可用的operator的子集，并且一些operator会转换结果为Flux。比如, Mono#concatWith(Publisher)返回一个Flux，而Mono#then(Mono) 返回另一个Mono。</p>
<p>我们可以使用Mono来表示只有完成概念的无值异步进程（类似于 a Runnable），可以使用一个空的 Mono<void>实现。</void></p>
<h4 id="2-7-3-工厂方法"><a href="#2-7-3-工厂方法" class="headerlink" title="2.7.3 工厂方法"></a>2.7.3 工厂方法</h4><p>最简单的创建Flux或Mono的是使用一系列工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; empty = Mono.empty();</span><br><span class="line">Mono&lt;String&gt; name = Mono.just(<span class="string">"jack"</span>);</span><br><span class="line">Mono&lt;String&gt; monoResult = Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; <span class="string">"result"</span>));</span><br><span class="line">Mono&lt;Void&gt; monoFromRunnable = Mono.fromRunnable(() -&gt; System.out.println(<span class="string">"do nothing"</span>));</span><br><span class="line">Mono&lt;String&gt; monoFromOtherMono = Mono.from(monoResult);</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; nums = Flux.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">Flux&lt;String&gt; colors = Flux.just(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>);</span><br><span class="line">Flux&lt;String&gt; colorFromArray = Flux.fromArray(<span class="keyword">new</span> String[]&#123;<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>&#125;);</span><br><span class="line">Flux&lt;String&gt; colorFromList = Flux.fromIterable(Arrays.asList(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>));</span><br><span class="line">Flux&lt;String&gt; colorFromStream = Flux.fromStream(Stream.of(<span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"yellow"</span>));</span><br><span class="line">Flux&lt;String&gt; colorFromOtherFlux = Flux.from(colors);</span><br></pre></td></tr></table></figure>
<h4 id="2-7-4-subscribe"><a href="#2-7-4-subscribe" class="headerlink" title="2.7.4 subscribe"></a>2.7.4 subscribe</h4><p>Flux和Mono使用java8的lambda表达式来提供订阅的能力，这些方法使用不同形式组合的回调函数作为参数。这些方法的返回值都是Disposable类型，可以用来取消订阅以及停止source的数据产生和清理已经创建的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅并触发流</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理流中的每一个数据</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理六中每一个数据，同时也有处理异常的能力</span></span><br><span class="line"><span class="function">Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer)</span></span>; </span><br><span class="line"><span class="comment">// 订阅并处理六中每一个数据，也有处理异常的能力，也可以在流完成的时候运行一些代码</span></span><br><span class="line"><span class="function">Disposable  <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,  Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,  Runnable completeConsumer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">		.map(i -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &lt;= <span class="number">3</span>) <span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Got to 4"</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">ints.subscribe(System.out::println,</span><br><span class="line">		error -&gt; System.err.println(<span class="string">"Error: "</span> + error));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>2<br>3<br>Error: java.lang.RuntimeException: Got to 4</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(System.out::println, error -&gt; System.err.println(<span class="string">"Error: "</span> + error),</span><br><span class="line">		() -&gt; System.out.println(<span class="string">"Done"</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>2<br>3<br>4<br>Done</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">					subscription.request(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// you can control backpressure here</span></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">					System.out.println(value);</span><br><span class="line">					subscription.request(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>2<br>3<br>4<br>Done</p>
</blockquote>
<h4 id="2-7-5-Disposable"><a href="#2-7-5-Disposable" class="headerlink" title="2.7.5 Disposable"></a>2.7.5 Disposable</h4><p>通过调用Disposable的 dispose()方法我们可以取消订阅。对于Flux或者Mono，取消信号意味者源应该停止生产数据，但是这种行为并不保证立即生效。有些源数据可能数据产生的非常快，以至于在收到取消信号之前已经完成数据生产。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">Disposable disposable = ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">				subscription.request(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// you can control backpressure here</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">				System.out.println(value);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				subscription.request(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">disposable.dispose();</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>2<br>3<br>4<br>Done</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Long&gt; ints = Flux.interval(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">Disposable disposable = ints.subscribeWith(<span class="keyword">new</span> BaseSubscriber&lt;Long&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">				subscription.request(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// you can control backpressure here</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">				System.out.println(value);</span><br><span class="line">				subscription.request(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookOnComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Done"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">disposable.dispose();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>0<br>1</p>
</blockquote>
<h4 id="2-7-6-自定义序列器"><a href="#2-7-6-自定义序列器" class="headerlink" title="2.7.6 自定义序列器"></a>2.7.6 自定义序列器</h4><h5 id="2-7-6-1-同步生成"><a href="#2-7-6-1-同步生成" class="headerlink" title="2.7.6.1 同步生成"></a>2.7.6.1 同步生成</h5><p>在有些情况下，序列的生成可能是有状态的，需要用到某些状态对象。此时可以使用<code>generate(Callable&lt;S&gt; stateSupplier, BiFunction&lt;S,SynchronousSink&lt;T&gt;,S&gt; generator)</code>，其中 stateSupplier 用来提供初始的状态对象。在进行序列生成时，状态对象会作为 generator 使用的第一个参数传入，可以在对应的逻辑中对该状态对象进行修改以供下一次生成时使用。</p>
<p><img src="https://raw.githubusercontent.com/shinerio/shinerio.github.io/blog-images/小书匠/1639899001379.png" alt="enter description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">		<span class="comment">// 初始状态</span></span><br><span class="line">		() -&gt; <span class="number">0</span>,</span><br><span class="line">		<span class="comment">// 生产序列元素，返回下一个状态</span></span><br><span class="line">		(state, sink) -&gt; &#123;</span><br><span class="line">			sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span> * state);</span><br><span class="line">			<span class="keyword">if</span> (state == <span class="number">10</span>) sink.complete();</span><br><span class="line">			<span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>3 x 0 = 0<br>3 x 1 = 3<br>3 x 2 = 6<br>3 x 3 = 9<br>3 x 4 = 12<br>3 x 5 = 15<br>3 x 6 = 18<br>3 x 7 = 21<br>3 x 8 = 24<br>3 x 9 = 27<br>3 x 10 = 30</p>
</blockquote>
<h5 id="2-7-6-2-异步多线程生成"><a href="#2-7-6-2-异步多线程生成" class="headerlink" title="2.7.6.2 异步多线程生成"></a>2.7.6.2 异步多线程生成</h5><p>create()方法与 generate()方法的不同之处在于所使用的是FluxSink对象。FluxSink声明了next, error和complete方法。支持同步和异步的消息产生，并且可以在一次调用中产生多个元素。create另一特性就是很容易把其他的接口与响应式桥接起来。注意，它是异步多线程并不意味着create可以并行化你写的代码或者异步执行，create方法里面的Lambda表达式代码还是单线程阻塞的。如果你在创建序列的地方阻塞了代码，那么可能造成订阅者即使请求了数据，也得不到，因为序列被阻塞了，没法生成新的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span></span>;</span><br><span class="line">	<span class="function">MyEventListener&lt;T&gt; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	MyEventProcessor&lt;String&gt; myEventProcessor = <span class="keyword">new</span> MyEventProcessor&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> MyEventListener&lt;String&gt; myEventListener;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.myEventListener = stringTestListener;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> MyEventListener&lt;String&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.myEventListener;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">		myEventProcessor.register(</span><br><span class="line">				<span class="keyword">new</span> MyEventListener&lt;&gt;() &#123;</span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">						<span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">							sink.next(s);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						sink.complete();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	bridge.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">			list.add(i+<span class="string">"-run1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		myEventProcessor.get().onDataChunk(list);</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">			list.add(i+<span class="string">"-run2"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		myEventProcessor.get().onDataChunk(list);</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">			list.add(i+<span class="string">"-run3"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		myEventProcessor.get().onDataChunk(list);</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	myEventProcessor.get().processComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-run1</span><br><span class="line"><span class="number">0</span>-run2</span><br><span class="line"><span class="number">0</span>-run3</span><br><span class="line"><span class="number">1</span>-run2</span><br><span class="line"><span class="number">1</span>-run3</span><br><span class="line"><span class="number">2</span>-run2</span><br><span class="line"><span class="number">2</span>-run3</span><br><span class="line"><span class="number">3</span>-run2</span><br><span class="line"><span class="number">3</span>-run3</span><br><span class="line"><span class="number">4</span>-run2</span><br><span class="line"><span class="number">4</span>-run3</span><br><span class="line"><span class="number">5</span>-run2</span><br><span class="line"><span class="number">5</span>-run3</span><br><span class="line"><span class="number">6</span>-run2</span><br><span class="line"><span class="number">6</span>-run3</span><br><span class="line"><span class="number">7</span>-run2</span><br><span class="line"><span class="number">7</span>-run3</span><br><span class="line"><span class="number">8</span>-run2</span><br><span class="line"><span class="number">8</span>-run3</span><br><span class="line"><span class="number">9</span>-run2</span><br><span class="line"><span class="number">9</span>-run3</span><br><span class="line"><span class="number">1</span>-run1</span><br><span class="line"><span class="number">2</span>-run1</span><br><span class="line"><span class="number">3</span>-run1</span><br><span class="line"><span class="number">4</span>-run1</span><br><span class="line"><span class="number">5</span>-run1</span><br><span class="line"><span class="number">6</span>-run1</span><br><span class="line"><span class="number">7</span>-run1</span><br><span class="line"><span class="number">8</span>-run1</span><br><span class="line"><span class="number">9</span>-run1</span><br></pre></td></tr></table></figure></p>
<p>上述代码通过多个线程持有MyEventListener对象，并发地执行onDataTrunk方法，通过sink.next()产生消息。</p>
<h5 id="2-7-6-3-异步单线程生成"><a href="#2-7-6-3-异步单线程生成" class="headerlink" title="2.7.6.3 异步单线程生成"></a>2.7.6.3 异步单线程生成</h5><p>reate允许多线程环境下调用.next()方法，只管生成元素，元素的顺序不可控。但是push只允许一个线程生产元素，所以是有序的，至于异步指的是在新的线程中也可以，而不必非得在当前线程。顺带一提，push和create都支持onCancel()和onDispose()操作。一般来说，onCancel只响应于cancel操作，而onDispose响应于error，cancel，complete等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span></span>;</span><br><span class="line">	<span class="function">MyEventListener&lt;T&gt; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	MyEventProcessor&lt;String&gt; myEventProcessor = <span class="keyword">new</span> MyEventProcessor&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> MyEventListener&lt;String&gt; myEventListener;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(MyEventListener&lt;String&gt; stringTestListener)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.myEventListener = stringTestListener;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> MyEventListener&lt;String&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.myEventListener;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Flux&lt;String&gt; bridge = Flux.push(sink -&gt; &#123;</span><br><span class="line">		myEventProcessor.register(</span><br><span class="line">				<span class="keyword">new</span> MyEventListener&lt;&gt;() &#123;</span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">						<span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">							sink.next(s);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						sink.complete();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	bridge.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">			list.add(i+<span class="string">"-run1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		myEventProcessor.get().onDataChunk(list);</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">	myEventProcessor.get().processComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>0-run1<br>1-run1<br>2-run1<br>3-run1<br>4-run1<br>5-run1<br>6-run1<br>7-run1<br>8-run1<br>9-run1</p>
</blockquote>
<h4 id="2-7-7-filter和map"><a href="#2-7-7-filter和map" class="headerlink" title="2.7.7 filter和map"></a>2.7.7 filter和map</h4><p>filter和map方法是实例方法，一般链接在一个已经存在的源上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10</span>).filter(i -&gt; i &gt; <span class="number">3</span>).map(i -&gt; <span class="string">"value is "</span> + i).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>value is 4<br>value is 5<br>value is 6<br>value is 7<br>value is 8<br>value is 9</p>
</blockquote>
<h4 id="2-7-8-handle"><a href="#2-7-8-handle" class="headerlink" title="2.7.8 handle"></a>2.7.8 handle</h4><p>handle方法是一个实例方法，一般链接在一个已经存在的源上。handle和generate类似，只能同步地诸葛处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>, <span class="number">10</span>).handle((v, sink) -&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (v &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		sink.next(<span class="string">"value is "</span> + v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>value is 4<br>value is 5<br>value is 6<br>value is 7<br>value is 8<br>value is 9</p>
</blockquote>
<h4 id="2-7-9-Threading-and-Schedulers"><a href="#2-7-9-Threading-and-Schedulers" class="headerlink" title="2.7.9 Threading and Schedulers"></a>2.7.9 Threading and Schedulers</h4><p>一般来说，响应式框架并不一定是并发的(create那个是生产者并发，它本身不是并发的)，依赖开发者自己通过一些lib库来实现并发。Flux或Mono并不意味着其运行在一个新的线程，大多数运算都在其上一个线程执行的线程里执行。除非特别指定，最顶层（源）运算运行在subscribe()被调用的线程里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	Flux.range(<span class="number">0</span>, <span class="number">10</span>).filter(v -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">	&#125;).map(v -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">	&#125;).subscribe(v -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		System.out.println(v);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">test.join();</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 4<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 5<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 6<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 7<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 8<br>filter thread is Test-thread<br>map thread is Test-thread<br>subscribe thread is Test-thread<br>value is 9</p>
</blockquote>
<p>在Reactor里，Scheduler决定了操作在哪个线程被怎么执行，它的作用类似于ExecutorService。不过功能稍微多点。如果你想实现一些并发操作，那么可以考虑使用Schedulers提供的静态方法。</p>
<ul>
<li><code>Schedulers.immediate()</code>：在当前线程运行</li>
<li><code>Schedulers.single()</code>：可重用的单线程。所有调用Schedulers.single()的方法都使用同样一个线程。如果每次想要不一样的线程，可以使用<code>Schedulers.newSingle()</code></li>
<li><code>Schedulers.elastic()</code>：一个弹性无界线程池。有时候太多的线程对于计算机计算来说反而是中负担。</li>
<li><code>Schedulers.bounededElastic()</code>：有界可复用的线程池。可以在需要的时候创建工作线程池，并复用空闲的池。同时，某些池如果空闲时间超过一个限定的数值就会被抛弃。同时，它还有一个容量限制，一般10倍于CPU核心数，这是它后备线程池的最大容量。当线程不够用时，允许最多提交10万条任务，进入等待队列，等到有可用时再调度，如果是延时调度，那么延时开始时间是在有线程可用时才开始计算。由此可见Schedulers.boundedElastic()对于阻塞的I/O操作是一个不错的选择，因为它可以让每一个操作都有自己的线程。但是记得，太多的线程会让系统备受压力。</li>
<li><code>Schedulers.parallel()</code>：固定大小的线程池，会创建数量等于CPU核心数的线程来实现这一功能。</li>
<li><code>Schedulers.fromExecutorService(ExecutorService)</code>：除了使用已经存在的schedulers，还可以基于executorService产生自定义的Scheduler。</li>
</ul>
<p>当然，我们也可以通过调用newXXX之类的方法来创建自己的Scheduler。比如<code>Schedulers.newParallel(&quot;My scheduler Name&quot;)</code>来创建一个新的并行调度器。boudedElastic被用来处理无法避免阻塞的代码，而single和parallel不被允许，在single和parallel线程中调用阻塞 API（block(), blockFirst(), blockLast()（以及迭代toIterable() 或toStream()）会导致抛出IllegalStateException异常。自定义Schedulers也可以通过创建实现了NonBlocking接口的线程来禁止阻塞调用。</p>
<p>一些运算其实默认使用了一些Scheduler。比如，<code>Flux.interval(Duration.ofMillis(300))</code>创建了一个每300ms触发一次的Flux<long>，默认使用了Schedulers.parallel()。</long></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.interval(Duration.ofMillis(<span class="number">300</span>)).take(<span class="number">1</span>).subscribe(v -&gt; System.out.println(<span class="string">"Thread is "</span> + Thread.currentThread().getName()));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Thread is parallel-1</p>
</blockquote>
<h4 id="2-7-10-publishOn和subscribeOn"><a href="#2-7-10-publishOn和subscribeOn" class="headerlink" title="2.7.10 publishOn和subscribeOn"></a>2.7.10 publishOn和subscribeOn</h4><p>Reactor提供了两种切换执行上下文的方法，<code>publishOn</code>和<code>subscribeOn</code>。这两个方法接收一个scheduler，用于让后续流操作的执行上下文切换到此scheduler。<code>publishOn</code>在流式链中被调用，而<code>subscribeOn</code>则不是这么用的。</p>
<h5 id="2-7-10-1-publishOn"><a href="#2-7-10-1-publishOn" class="headerlink" title="2.7.10.1 publishOn"></a>2.7.10.1 publishOn</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 工作在Teat-Thread线程</span></span><br><span class="line">		System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">	&#125;).publishOn(Schedulers.single()).map(v -&gt; &#123;    <span class="comment">// 切换后续执行线程到single线程</span></span><br><span class="line">		System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">	&#125;).subscribe(v -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		System.out.println(v);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>filter thread is Test-thread<br>map thread is single-1<br>subscribe thread is single-1<br>value is 4</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 运行在Test-Thread线程</span></span><br><span class="line">		System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">	&#125;).publishOn(Schedulers.single()).map(v -&gt; &#123;  <span class="comment">// 后续线程运行在single线程</span></span><br><span class="line">		System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">	&#125;).publishOn(Schedulers.newSingle(<span class="string">"My Single Thread"</span>)).subscribe(v -&gt; &#123;   <span class="comment">// 后续线程运行在My Single Thread线程</span></span><br><span class="line">		System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		System.out.println(v);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>filter thread is Test-thread<br>map thread is single-2<br>subscribe thread is My Single Thread-1<br>value is 4</p>
</blockquote>
<h5 id="2-7-10-2-subscribeOn"><a href="#2-7-10-2-subscribeOn" class="headerlink" title="2.7.10.2 subscribeOn"></a>2.7.10.2 subscribeOn</h5><p>subscribeOn工作在subscription过程，也就是整个流式链创建的地方。因此，不管你把subscribeOn放在链中的哪个位置，它总是影响数据源的上下文，并且不影响后续使用publishOn来执行上下文切换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	Flux.range(<span class="number">4</span>, <span class="number">1</span>).filter(v -&gt; &#123;   <span class="comment">// 继承自源序列的线程</span></span><br><span class="line">		System.out.println(<span class="string">"filter thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">	&#125;).subscribeOn(Schedulers.parallel()) <span class="comment">// 源序列产生于parallel线程</span></span><br><span class="line">			.publishOn(Schedulers.single()).map(v -&gt; &#123;  <span class="comment">// 切换到single线程</span></span><br><span class="line">		System.out.println(<span class="string">"map thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"value is "</span> + v;</span><br><span class="line">	&#125;).publishOn(Schedulers.parallel()).subscribe(v -&gt; &#123;   <span class="comment">// 切换到parallel线程</span></span><br><span class="line">		System.out.println(<span class="string">"subscribe thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">		System.out.println(v);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">test.setName(<span class="string">"Test-thread"</span>);</span><br><span class="line">test.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>filter thread is parallel-2<br>map thread is single-1<br>subscribe thread is parallel-1<br>value is 4</p>
</blockquote>
<h2 id="3-Reactor重构"><a href="#3-Reactor重构" class="headerlink" title="3. Reactor重构"></a>3. Reactor重构</h2><p>还记得开头我们用completeFuture写的例子吗？现在是时候重构他了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">		put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">		put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">		put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">		.publishOn(Schedulers.boundedElastic()).map(id -&gt; &#123;</span><br><span class="line">	Mono&lt;String&gt; name = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getName());</span><br><span class="line">	Mono&lt;String&gt; author = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getAuthor());</span><br><span class="line">	<span class="keyword">return</span> name.zipWith(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">&#125;)</span><br><span class="line">		.publishOn(Schedulers.boundedElastic()).subscribe(zip -&gt; zip.subscribe(System.out::println));</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>map返回的是一个Flux<string>对象，如果对于流中的每一个数据，我们处理map的期望的结果是从String-&gt;String，这点我们可以使用flatMap实现</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		put(<span class="number">1</span>, <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"test1"</span>, <span class="string">"Jack"</span>));</span><br><span class="line">		put(<span class="number">2</span>, <span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"test2"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">		put(<span class="number">3</span>, <span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"test3"</span>, <span class="string">"mary"</span>));</span><br><span class="line">		put(<span class="number">4</span>, <span class="keyword">new</span> Book(<span class="number">4</span>, <span class="string">"test4"</span>, <span class="string">"Blue"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">		.publishOn(Schedulers.boundedElastic()).flatMap(id -&gt; &#123;</span><br><span class="line">	Mono&lt;String&gt; name = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getName());</span><br><span class="line">	Mono&lt;String&gt; author = Mono.just(id).publishOn(Schedulers.boundedElastic()).map(i -&gt; books.get(i).getAuthor());</span><br><span class="line">	<span class="keyword">return</span> name.zipWith(author, (n, a) -&gt; <span class="string">"Name is "</span> + n + <span class="string">",author is "</span> + a);</span><br><span class="line">&#125;)</span><br><span class="line">		.publishOn(Schedulers.boundedElastic()).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Name is test1,author is Jack<br>Name is test2,author is Tom<br>Name is test4,author is Blue<br>Name is test3,author is mary</p>
</blockquote>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h2><ol>
<li><a href="https://projectreactor.io/docs/core/release/reference/#error.handling" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#error.handling</a></li>
<li><a href="https://skyao.io/learning-reactor/docs/concept/flux/create.html" target="_blank" rel="noopener">https://skyao.io/learning-reactor/docs/concept/flux/create.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/283903217" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/283903217</a></li>
</ol>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://shinerio.cc">shinerio</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://shinerio.cc/2021/12/18/java/Reactor编程（二）/">https://shinerio.cc/2021/12/18/java/Reactor编程（二）/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/">java</a>
            <a href="/tags/异步编程/">异步编程</a>
            <a href="/tags/reactor/">reactor</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/12/19/java/Reactor编程（三）/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Reactor编程（三）</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2021/12/18/java/Reactor编程（一）/">
        <span class="next-text nav-default">Reactor编程（一）</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:jstxzhangrui@163.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/shinerio" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">shinerio</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://shinerio.cc/2021/12/18/java/Reactor编程（二）/';
        this.page.identifier = '2021/12/18/java/Reactor编程（二）/';
        this.page.title = 'Reactor编程（二）';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//shinerio.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
