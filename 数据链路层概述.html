<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据链路层概述 - Shinerio's Blog</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./assets/css/style.css">
</head>
<body class="article-page" id="theme-body">
    <div class="page-wrapper">
        <header class="page-header">
            <div class="container">
                <nav class="page-nav">
                    <div class="nav-links">
                        <a href="index.html" class="nav-link ">Home</a>
                        <a href="articles.html" class="nav-link ">Articles</a>
                        <a href="search.html" class="nav-link ">Search</a>
                    </div>
                    <div class="theme-toggle-container">
                        <button id="theme-toggle" aria-label="Toggle dark mode" class="theme-toggle-btn">
                            <span class="sun-icon">☀️</span>
                            <span class="moon-icon">🌙</span>
                        </button>
                    </div>
                </nav>
            </div>
        </header>
        <main class="page-main">
            <div class="container">
                <article>
    <header>
        <h1>数据链路层概述</h1>
        <time datetime="2020-04-22T00:00:00.000Z">2020年4月22日</time>
        <div class="tags">
            
            <span class="tag">计算机网络</span>
            
        </div>
    </header>
    <section class="content">
        {<p>数据链路层使用的信道主要分为以下两种：</p>
<ul>
<li>点对点信道，使用一对一的点对点的通信方式</li>
<li>广播信道，使用一对多的广播通信方式，广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ul>
<h2>0.1. 数据链路</h2>
<p>当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用<strong>网络适配器</strong>来实现这些协议。一般适配器都包括了<strong>数据链路层</strong>和<strong>物理层</strong>这两层功能。</p>
<p>网络适配器的功能包括:</p>
<ol>
<li><strong>数据封装</strong> 网络适配器的主要功能之一是数据封装。当计算机需要发送数据时，适配器会接收来自高层协议的数据，并在数据前面添加物理层的头部信息，构成完整的数据帧。这个过程称为数据封装。</li>
<li><strong>数据编码和解码</strong> 适配器还负责将数字数据编码成可在网络介质上传输的形式，如通过调制将数据编码为电子信号。接收数据时，适配器会对接收到的编码过的信号进行解码，恢复出原始数字数据。</li>
<li><strong>介质访问控制</strong> 当多台设备同时尝试在共享介质(如以太网)上发送数据时，就会出现冲突。适配器利用介质访问控制(MAC)机制来协调设备对网络的访问，避免冲突。常见的MAC机制有CSMA/CD(载波监听多路访问/冲突检测)。PS：现代交换机的出现已经不会出现冲突。</li>
<li><strong>地址识别</strong> 每个网络适配器都有一个唯一的物理地址(MAC地址)，用于在局域网中识别和定位设备。适配器会检查接收到的数据帧的目标MAC地址，只接收发往自己的数据，避免不必要的处理。</li>
<li><strong>错误检测和纠正</strong> 适配器通常会对接收到的数据进行循环冗余检验(CRC)，检测数据在传输过程中是否发生错误。某些适配器还支持纠正少量的比特错误。</li>
</ol>
<h2>0.2. 基本问题</h2>
<p>数据链路层使用物理层提供的服务在通信信道上发送和接收比特。数据链路层解决的主要问题包括：</p>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错控制</li>
</ul>
<!--more-->

<h3>0.2.1. 封装成帧</h3>
<p>封装成帧（帧同步）就是在将网络层的IP数据报的前后分别添加首部和尾部。不同数据链路层协议的帧首部和尾部包含的信息有明确规定，帧的首部和尾部有帧开始符和帧结束符，称之为<font color=red>帧界定符</font>。每一种数据链路层协议都规定了所能够传输的帧的数据部分的上限，即MTU（Maximum Transmission Unit），以太网的MTU为1500字节。</p>
<blockquote>
<p>1500字节是考虑到传输效率以及传输时间而折中选择的一个值</p>
</blockquote>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428143139.png" alt=""></p>
<h3>0.2.2. 透明传输</h3>
<p>透明表示一个实际存在的事物看起来好像不存在一样，该层上传输的数据的内容、格式及编码没有限制，也没有必要解释信息结构的意义。</p>
<p>比如使用SOH(Start Of Header)--0x01和EOT(End Of Transmission)--0x04来表示，这样数据链路层就可以识别出帧的开始和结束。如果数据部分出现SOH或EOT，则采用<font color=red>字节填充</font>的方式，比如在SOH和EOT前面分别插入一个转义字符ESC--0x1B，在接收端的数据链路层将数据交递给网络层之前删除这个插入的转义字符。</p>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428152202.png" alt=""></p>
<h3>0.2.3. 差错控制</h3>
<p>现实的通信链路并不是理想的，比特在传输过程中可能会产生差错（1变0，0变1），这就叫做比特差错。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了循环冗余检验CRC(Cyclic Redundancy Check）的差错检验技术来判定一帧是否在传输过程中发生了错误，一旦发生错误就可以采用反馈重传的方法来纠正。发送数据前先计算<font color=red>帧的数据部分</font>得出FCS添加在数据部分后，接收端收到数据后进行同样的CRC计算与接收到的FCS字段进行比较，判断数据有无差错。<br>在数据链路层，发送端帧检验序列FCS的生成和接收端的CRC检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。</p>
<p>这里需要强调下数据链路层提供的查错控制仅仅是<strong>无比特差错</strong>，无法处理<strong>帧丢失</strong>、<strong>帧重复</strong>、<strong>帧失序</strong>。</p>
<p>我们知道，过去 OSI 的观点是:必须让数据链路层向上提供可靠传输。因此在CRC检错的基础上，增加了<strong>帧编号</strong>、<strong>确认</strong>和<strong>重传机制</strong>。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史士兽经起到很好的作用。但现在的通信线路的质量已经大大提高了，因通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法:</p>
<ul>
<li>对于通信质量良好的<strong>有线传输链路</strong>，数据链路层协议不使用确认和业传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议(例如，运输层的 TCP 协议)来完成。目前数据链路层广泛使用的以太网就不提供可靠性保证。</li>
<li>对十通信质量较差的<strong>无线传输链路</strong>，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务</li>
</ul>
<h2>0.3. 点到点信道的数据链路</h2>
<p>在通信线路质量较差的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此，能实现可靠传输的高级数据链路控制HDLC (High-level Data Link Control)就成为当时比较流行的数据链路层协议。但现在HDLC已很少使用了。对于点对点的链路，简单得多的点对点协议 PPP (Point-to-Point Protocol)则是目前使用得最广泛的数据链路层协议。IETF 在设计互联网体系结构时把其中最复杂的部分放在 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。IETF 把“简单”作为首要的需求。</p>
<p>点到点信道指的是一条链路上就一个发送端和接收端的信道，通常用在广域网链路。点到点的信道不会发生碰撞，因此比较简单，使用PPP协议控制。</p>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428153923.png" alt=""></p>
<h3>0.3.1. 组成部分</h3>
<p>PPP协议主要分成三个部分：</p>
<ul>
<li><font color=red>高级数据链路控制协议（HDLC）</font>：将IP数据报封装到串行链路，支持同步传输和异步传输。因为计算机内的I/O通信是并行的，而链路传输则是按比特流的串行，因此需要协议的封装转换，一般由网络适配器完成。</li>
<li><font color=red>链路控制协议（LCP）</font>：建立、配置和测试链路连接，用来协商一些选项。</li>
<li><font color=red>网络控制协议（NCP）</font>：用于支持上层的不同的网络协议。</li>
</ul>
<p>!!! note 同步传输与异步传输<br>    同步传输（Synchronous Transmission）以数据帧为单位传输数据，可采用字符形式或位组合形式的帧同步信号，在短距离的高速传输中，该时钟信号可由专门的时钟线路传输，由发送端或接收端提供专用于同步的时钟信号。计算机网络采用同步传输方式时，常将时钟同步信号（前同步码）植入数据信号帧中，以实现接收端与发送端的时钟同步。异步传输（Asynchronous Transmission）以字符为单位传输数据，发送端和接收端具有相互独立的时钟（频率相差不能太多），并且两者中任一方都不向对方提供时钟同步信号。</p>
<h3>0.3.2. 工作过程</h3>
<ol>
<li>用户的PC机通过调制解调器呼叫路由器，路由器就能够检测到调制解调器发出的载波信号，在双方建立了物理层的连接之后，PPP协议就进入“链路建立”状态，其目的是建立链路层的LCP连接。</li>
<li>LCP开始发送配置请求帧，进行协商一些配置选项，包括链路上的最大帧长、所使用的鉴别协议，以及不适用的PPP帧中的地址和控制字段等。LCP的配置请求帧依旧是一个PPP帧，其协议字段置为LCP对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：（一）配置确认帧：所有选项都接受；（二）配置否认帧：所有选项都理解但不能接受；（三）配置拒绝帧：选项有的无法识别或不能接受，需要协商</li>
<li>协商结束后双方建立了LCP链路，接着就进入鉴别阶段，在这一状态下，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若鉴别失败，则转到“链路终止”状态，成功则进入“网络层协议”状态。</li>
<li>在“网络层协议”状态，PPP链路两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组，总之也许PPP协议两端的网络层可能运行不同的网络层协议，但是都可以使用一个PPP协议进行通信。</li>
</ol>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428154652.png" alt=""></p>
<h3>0.3.3. PPP协议帧格式</h3>
<ul>
<li><font color=red>F</font>：PPP协议帧界定符0x7E</li>
<li><font color=red>A</font>：在PPP协议中，因为进行通信的只有两方，因此一方发送的数据总是另一方接收，这一点PPP协议不像以太网协议一样，必须使用MAC地址来表明数据帧的发送者和接收者。PPP协议中的Address字段取值<strong>固定为0xff</strong></li>
<li><font color=red>C</font>：字段的值为0x03，无实际意义</li>
<li><font color=red>协议</font>：数据中的协议类型，0x0021-IP数据报；0xC021-LCP数据；0x8021-NCP数据等</li>
<li><font color=red>FCS</font>: 长度16bit，用于帧校验。一个设备在收到PPP帧后会进行PPP帧校验，如果发现PPP在传输过程中出错，该帧会被立即丢弃。<strong>PPP协议没有纠错和重传机制</strong>。</li>
</ul>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428160127.png" alt=""></p>
<p>为了实现透明传输，还需要对PPP协议进行帧填充，同步传输和异步传输由于机制不同，采用的填充方法也不同。</p>
<ul>
<li><font color=red>同步传输</font>。数据以帧为单位，PPP协议采用零比特填充。PPP协议的帧界定符0x7E对应的二进制为01111110，即有6个连续的1。为了避免在数据字段出现帧界定符，因此在每当发送方的数据链路层在数据中遇到连续的5个1，便自动在插入一个比特0，接收方将5个连续1后面的0自动去除。<code>011011111111111010转换为01101111101111101010-&gt;还原为011011111111111010</code></li>
<li><font color=red>异步传输</font>：数据传输以字节为单位，使用0x7D作为PPP帧的转义符，并使用字节填充。把信息字段中出现的每一个0x7E字节转变成为2字节序列（0x7D，0x5E），每一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成为2字节序列（0x7D，0x5D）。</li>
</ul>
<p>ppp协议本身无法直接跨交换机或路由器通信，ppp协议设计上为点对点链路层协议。可以通过PPPoE协议在以太网上传输。</p>
<p><a href="https://zhuanlan.zhihu.com/p/653263236">PPP协议和PPPoE协议</a></p>
<h2>0.4. 广播信道</h2>
<p>广播信道是指一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。现在以太网已经成为了事实的局域网标准，采用CSMA/CD协议。</p>
<p>CSMA/CD(Carrier Sense Multiple Access/Collision Detection，载波多重访问/碰撞检测）工作原理：</p>
<ol>
<li>【开始】如果线路空闲，则启动传输，否则跳转到第4步。</li>
<li>【发送】如果检测到冲突，继续发送数据直到达到最小回报时间（min echo receive interval）以确保所有其他转发器和终端检测到冲突，而后跳转到第4步。</li>
<li>【成功传输】向更高层的网络协议报告发送成功，退出传输模式。</li>
<li>【线路繁忙】持续等待直到线路空闲。</li>
<li>【线路空闲】在尚未达到最大尝试次数之前，每隔一段随机时间转到第1步重新尝试。</li>
<li>【超过最大尝试传输次数】向更高层的网络协议报告发送失败，退出传输模式。</li>
</ol>
<p>!!! note 以太网为什么不采用信道复用<br>    主要还是为了降低成本。通常局域网的物理层的传输主要是基于基带传输，CSMA/CD其实可以某种程度上认为是时分复用的技术，而频分复用则需要考虑频谱带宽问题，需要用到调制解调器。如今的以太网其实已经不怎么需要CSMA/CD协议了，交换机的出现取代了集线器。集线器中每一个端口都在同一个冲突域，所有数据包都跑在一条物理链路上，因此需要CSMA/CD协调，而交换机可以隔离冲突域（路由器可以隔离广播域），每一个端口都是独立的冲突域，现在的交换机都采用双绞线作为媒介，发送信道和接收信道独立，工作在全双工模式下，因此不会出现冲突。</p>
<h2>0.5. MAC子层和LLC子层</h2>
<p>由于广域网采用点对点通信方式，不存在介质冲突问题，而局域网是共享介质的，因此局域网内的数据链路层需要分为MAC（Media Access Control，媒体访问控制）子层和LLC（Logic Link Control，逻辑链路控制）子层。其中MAC子层的一项重要功能就是仲裁介质的使用权（CSMA/CD）。</p>
<h3>0.5.1. MAC子层</h3>
<p>MAC子层是局域网中数据链路层的下层部分，主要功能有：</p>
<ul>
<li>提供定址及媒体访问的控制方式，使得不同设备或网络上的节点可以在多点的网络上通信，而不会互相冲突</li>
<li>数据帧的封装/解封装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。MAC子层作为LLC子层及物理层之间沟通的介质，提供了一种寻址的方法，即MAC地址。MAC地址是唯一的，每个网络适配器的MAC地址都不一样，因此可以在同一子网中发送数据包到特定的目的设备。</li>
</ul>
<p>!!! note MAC地址<br>    Mac地址是数据链路层地址，长度为6字节（48）位，用于唯一标识网络适配器。一台主机拥有多少个网络适配器就有多少个Mac地址。Mac地址通常使用6组，每组2位16进制数表示，每组之间冒号隔开。如<code>82:17:0d:2d:9d:00</code></p>
<p>MAC帧格式</p>
<p><img src="https://shinerio.oss-cn-beijing.aliyuncs.com/blog_images/uncategory/20200428180335.png" alt=""></p>
<p>我们发现MAC帧没有帧开始界定符，那么我们如何区分不同帧呢。其实以太网发送的数据使用了物理层编码违禁法，利用曼彻斯特编码(从高到低跳变表示“1”，从低到高跳变表示“0”)，每个码元正中间一定有一次电压转换，当发送方把一个以太网帧发送完毕后，就不在发送其他码元了，因此发送方网络适配器的接口上的电压也就不再变换了。这样接收方就可以知道以太网帧的结束位置了。</p>
<h3>0.5.2. LLC子层</h3>
<p>逻辑链路控制子层是局域网中数据链路层的上层部分，用户的数据链路服务通过LLC子层为网络层提供统一的接口。该子层通过在IP包上加了8位的源服务存取点和目的服务存取点（用于标识以太网帧所携带的上层数据类型）来保证在不同网络类型中传输。另外，有一个8或16位的控制字段用于像流控制的辅助功能。</p>
<p>LLC子层提供了两种无连接和一种面向连接的操作方式：</p>
<ul>
<li><font color=red>无回复的无连接方式</font>：它允许发送帧时：给单一的目的地址（单点传输）、给相同网络中的多个目的地址（多点传输）、给网络中的所有地址（广播传输）。多点和广播传输在同一信息需要发送到整个网络的情况下可以减少网络流量。单点传输不能保证接收端收到帧的次序和发送时的次序相同。发送端甚至无法确定接收端是否收到了帧。</li>
<li><font color=red>面向连接的操作方式</font>。给每个帧进行编号，接收端就能保证它们按发送的次序接收，并且没有帧丢失。利用滑动窗口控制协议可以让快的发送端也能流到慢的接收端。</li>
<li><font color=red>有回复的无连接方式</font>。它仅限于点到点通信。</li>
</ul>
}
    </section>
</article>
            </div>
        </main>
        <footer class="page-footer">
            <div class="container">
                <p>&copy; 2026 Shinerio's Blog. All rights reserved.</p>
            </div>
        </footer>
    </div>

    <script>
        // Theme switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('theme-toggle');
            const body = document.getElementById('theme-body');

            // Check for saved theme preference or respect OS preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

            // Set initial theme
            if (savedTheme === 'dark' || (!savedTheme && prefersDarkScheme.matches)) {
                body.setAttribute('data-theme', 'dark');
            } else {
                body.removeAttribute('data-theme'); // light theme
            }

            // Toggle theme function
            function toggleTheme() {
                if (body.getAttribute('data-theme') === 'dark') {
                    body.removeAttribute('data-theme');
                    localStorage.setItem('theme', 'light');
                } else {
                    body.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                }
            }

            // Add event listener to theme toggle button
            themeToggle.addEventListener('click', toggleTheme);

            // Listen for OS theme changes
            prefersDarkScheme.addEventListener('change', function(e) {
                if (!localStorage.getItem('theme')) {
                    if (e.matches) {
                        body.setAttribute('data-theme', 'dark');
                    } else {
                        body.removeAttribute('data-theme');
                    }
                }
            });

            // Search functionality
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const searchResults = document.getElementById('search-results');
            const searchSuggestions = document.getElementById('search-suggestions');
            const searchTypeRadios = document.querySelectorAll('input[name="search-type"]');

            if (searchInput && searchButton) {
                let searchData = null;

                // Load search data
                async function loadSearchData() {
                    try {
                        const response = await fetch('./assets/js/search-data.json');
                        if (response.ok) {
                            searchData = await response.json();
                        } else {
                            console.error('Failed to load search data:', response.status);
                        }
                    } catch (error) {
                        console.error('Error loading search data:', error);
                    }
                }

                // Initialize search data
                loadSearchData();

                // Debounce function to limit search calls
                function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }

                // Get selected search type
                function getSelectedSearchType() {
                    const selectedRadio = document.querySelector('input[name="search-type"]:checked');
                    return selectedRadio ? selectedRadio.value : 'all';
                }

                // Perform search
                function performSearch(query) {
                    if (!searchData || !query.trim()) {
                        searchResults.innerHTML = '';
                        searchSuggestions.innerHTML = '';
                        return;
                    }

                    const queryTerms = query.toLowerCase().split(/\s+/).filter(term => term.length > 0);
                    const searchType = getSelectedSearchType();

                    if (queryTerms.length === 0) {
                        searchResults.innerHTML = '';
                        return;
                    }

                    const results = [];

                    // Search through articles
                    searchData.articles.forEach(article => {
                        let score = 0;
                        let snippet = '';

                        // Get content based on search type
                        const lowerTitle = article.title.toLowerCase();
                        const lowerContent = article.content.toLowerCase();
                        const lowerTags = article.tags.join(' ').toLowerCase();

                        queryTerms.forEach(term => {
                            switch(searchType) {
                                case 'title':
                                    // Only title matches count
                                    if (lowerTitle.includes(term)) {
                                        score += 10;
                                    }
                                    break;
                                case 'content':
                                    // Only content matches count (fixed to exclude title matches)
                                    if (lowerContent.includes(term)) {
                                        score += 1;
                                    }
                                    break;
                                case 'all':
                                default:
                                    // Both title and content matches count
                                    if (lowerTitle.includes(term)) {
                                        score += 10;
                                    }
                                    if (lowerContent.includes(term)) {
                                        score += 1;
                                    }
                                    // Tag matches get medium-high score
                                    if (lowerTags.includes(term)) {
                                        score += 5;
                                    }
                                    break;
                            }
                        });

                        if (score > 0) {
                            // Generate snippet based on search type
                            let content = '';

                            if (searchType === 'title') {
                                // For title-only search, show title content
                                content = article.title.substring(0, 200);
                            } else if (searchType === 'content') {
                                // For content-only search, show content excerpt
                                content = article.content.substring(0, 200);
                            } else {
                                // For all search, show content with title as context
                                content = article.content.substring(0, 200);
                            }

                            // Find first occurrence of query term in content for snippet
                            queryTerms.forEach(term => {
                                let searchIn = content.toLowerCase();
                                if (searchType === 'title') {
                                    searchIn = lowerTitle;
                                } else if (searchType === 'content') {
                                    searchIn = lowerContent;
                                }

                                const index = searchIn.indexOf(term);
                                if (index !== -1) {
                                    // Expand snippet around the match
                                    let start, end;
                                    if (searchType === 'title') {
                                        start = Math.max(0, index - 15);
                                        end = Math.min(content.length, index + term.length + 35);
                                    } else {
                                        start = Math.max(0, index - 30);
                                        end = Math.min(content.length, index + term.length + 70);
                                    }

                                    content = (start > 0 ? '...' : '') +
                                              content.substring(start, end) +
                                              (end < (searchType === 'title' ? article.title.length : article.content.length) ? '...' : '');

                                    // Highlight the term in the snippet
                                    const searchContent = searchType === 'title' ? article.title : article.content;
                                    const adjustedIndex = searchType === 'title' ?
                                        Math.min(index, article.title.length - 1) :
                                        Math.min(index, article.content.length - 1);

                                    content = content.replace(
                                        new RegExp(`(${escapeRegExp(term)})`, 'gi'),
                                        '<mark>$1</mark>'
                                    );
                                }
                            });

                            results.push({
                                article: article,
                                score: score,
                                snippet: content
                            });
                        }
                    });

                    // Sort results by score
                    results.sort((a, b) => b.score - a.score);

                    // Display results
                    displaySearchResults(results);
                }

                // Display search results
                function displaySearchResults(results) {
                    if (results.length === 0) {
                        searchResults.innerHTML = '<p class="no-results">未找到匹配的文章</p>';
                        return;
                    }

                    const resultsHTML = results.map(result => `
                        <div class="search-result-item">
                            <h3 class="search-result-title">
                                <a href="./${result.article.slug}.html">${highlightQueryTerms(result.article.title, document.querySelector('#search-input').value)}</a>
                            </h3>
                            <div class="search-result-meta">
                                ${result.article.tags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                            </div>
                            <p class="search-result-excerpt">${result.snippet}</p>
                        </div>
                    `).join('');

                    searchResults.innerHTML = resultsHTML;
                }

                // Highlight query terms in text
                function highlightQueryTerms(text, query) {
                    if (!query.trim()) return text;

                    const queryTerms = query.split(/\s+/).filter(term => term.length > 0);
                    let highlightedText = text;

                    queryTerms.forEach(term => {
                        const regex = new RegExp(`(${escapeRegExp(term)})`, 'gi');
                        highlightedText = highlightedText.replace(regex, '<mark>$1</mark>');
                    });

                    return highlightedText;
                }

                // Escape special regex characters
                function escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                // Event listener for search button
                searchButton.addEventListener('click', function() {
                    const query = searchInput.value;
                    performSearch(query);
                });

                // Event listener for Enter key
                searchInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        const query = searchInput.value;
                        performSearch(query);
                    }
                });

                // Add debounced input handler for live search (optional)
                const debouncedSearch = debounce(function() {
                    const query = searchInput.value;
                    performSearch(query);
                }, 300);

                searchInput.addEventListener('input', debouncedSearch);

                // Add event listeners for search type radios
                searchTypeRadios.forEach(radio => {
                    radio.addEventListener('change', function() {
                        const query = searchInput.value;
                        if (query.trim()) {
                            performSearch(query);
                        }
                    });
                });
            }
        });
    </script>
</body>
</html>